{
    "sourceFile": "main/st7789.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1731789723592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731789735676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,83 +41,84 @@\n \r\n \r\n void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n {\r\n-    esp_err_t ret;\r\n+\tesp_err_t ret;\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n-    if (GPIO_CS >= 0) {\r\n-        gpio_reset_pin(GPIO_CS);\r\n-        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_CS, 0);\r\n-    }\r\n+\tESP_LOGI(TAG, \"GPIO_CS=%d\",GPIO_CS);\r\n+\tif ( GPIO_CS >= 0 ) {\r\n+\t\t//gpio_pad_select_gpio( GPIO_CS );\r\n+\t\tgpio_reset_pin( GPIO_CS );\r\n+\t\tgpio_set_direction( GPIO_CS, GPIO_MODE_OUTPUT );\r\n+\t\tgpio_set_level( GPIO_CS, 0 );\r\n+\t}\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n-    gpio_reset_pin(GPIO_DC);\r\n-    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n-    gpio_set_level(GPIO_DC, 0);\r\n+\tESP_LOGI(TAG, \"GPIO_DC=%d\",GPIO_DC);\r\n+\t//gpio_pad_select_gpio( GPIO_DC );\r\n+\tgpio_reset_pin( GPIO_DC );\r\n+\tgpio_set_direction( GPIO_DC, GPIO_MODE_OUTPUT );\r\n+\tgpio_set_level( GPIO_DC, 0 );\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n-    if (GPIO_RESET >= 0) {\r\n-        gpio_reset_pin(GPIO_RESET);\r\n-        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n-        delayMS(100);\r\n-    }\r\n+\tESP_LOGI(TAG, \"GPIO_RESET=%d\",GPIO_RESET);\r\n+\tif ( GPIO_RESET >= 0 ) {\r\n+\t\t//gpio_pad_select_gpio( GPIO_RESET );\r\n+\t\tgpio_reset_pin( GPIO_RESET );\r\n+\t\tgpio_set_direction( GPIO_RESET, GPIO_MODE_OUTPUT );\r\n+\t\tgpio_set_level( GPIO_RESET, 1 );\r\n+\t\tdelayMS(100);\r\n+\t\tgpio_set_level( GPIO_RESET, 0 );\r\n+\t\tdelayMS(100);\r\n+\t\tgpio_set_level( GPIO_RESET, 1 );\r\n+\t\tdelayMS(100);\r\n+\t}\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 1); // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n+\tESP_LOGI(TAG, \"GPIO_BL=%d\",GPIO_BL);\r\n+\tif ( GPIO_BL >= 0 ) {\r\n+\t\t//gpio_pad_select_gpio(GPIO_BL);\r\n+\t\tgpio_reset_pin(GPIO_BL);\r\n+\t\tgpio_set_direction( GPIO_BL, GPIO_MODE_OUTPUT );\r\n+\t\tgpio_set_level( GPIO_BL, 0 );\r\n+\t}\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n-    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n-    spi_bus_config_t buscfg = {\r\n-        .mosi_io_num = GPIO_MOSI,\r\n-        .miso_io_num = -1,\r\n-        .sclk_io_num = GPIO_SCLK,\r\n-        .quadwp_io_num = -1,\r\n-        .quadhd_io_num = -1,\r\n-        .max_transfer_sz = 0,\r\n-        .flags = 0\r\n-    };\r\n+\tESP_LOGI(TAG, \"GPIO_MOSI=%d\",GPIO_MOSI);\r\n+\tESP_LOGI(TAG, \"GPIO_SCLK=%d\",GPIO_SCLK);\r\n+\tspi_bus_config_t buscfg = {\r\n+\t\t.mosi_io_num = GPIO_MOSI,\r\n+\t\t.miso_io_num = -1,\r\n+\t\t.sclk_io_num = GPIO_SCLK,\r\n+\t\t.quadwp_io_num = -1,\r\n+\t\t.quadhd_io_num = -1,\r\n+\t\t.max_transfer_sz = 0,\r\n+\t\t.flags = 0\r\n+\t};\r\n \r\n-    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n-    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n+\tret = spi_bus_initialize( HOST_ID, &buscfg, SPI_DMA_CH_AUTO );\r\n+\tESP_LOGD(TAG, \"spi_bus_initialize=%d\",ret);\r\n+\tassert(ret==ESP_OK);\r\n \r\n-    spi_device_interface_config_t devcfg;\r\n-    memset(&devcfg, 0, sizeof(devcfg));\r\n-    devcfg.clock_speed_hz = SPI_Frequency;\r\n-    devcfg.queue_size = 7;\r\n-    devcfg.mode = 2;\r\n-    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+\tspi_device_interface_config_t devcfg;\r\n+\tmemset(&devcfg, 0, sizeof(devcfg));\r\n+\tdevcfg.clock_speed_hz = SPI_Frequency;\r\n+\tdevcfg.queue_size = 7;\r\n+\tdevcfg.mode = 2;\r\n+\tdevcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n \r\n-    if (GPIO_CS >= 0) {\r\n-        devcfg.spics_io_num = GPIO_CS;\r\n-    } else {\r\n-        devcfg.spics_io_num = -1;\r\n-    }\r\n-\r\n-    spi_device_handle_t handle;\r\n-    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n-    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    dev->_dc = GPIO_DC;\r\n-    dev->_bl = GPIO_BL;\r\n-    dev->_SPIHandle = handle;\r\n+\tif ( GPIO_CS >= 0 ) {\r\n+\t\tdevcfg.spics_io_num = GPIO_CS;\r\n+\t} else {\r\n+\t\tdevcfg.spics_io_num = -1;\r\n+\t}\r\n+\t\r\n+\tspi_device_handle_t handle;\r\n+\tret = spi_bus_add_device( HOST_ID, &devcfg, &handle);\r\n+\tESP_LOGD(TAG, \"spi_bus_add_device=%d\",ret);\r\n+\tassert(ret==ESP_OK);\r\n+\tdev->_dc = GPIO_DC;\r\n+\tdev->_bl = GPIO_BL;\r\n+\tdev->_SPIHandle = handle;\r\n }\r\n \r\n \r\n-\r\n bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n {\r\n \tspi_transaction_t SPITransaction;\r\n \tesp_err_t ret;\r\n"
                },
                {
                    "date": 1731789742256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,10 +115,10 @@\n \tdev->_dc = GPIO_DC;\r\n \tdev->_bl = GPIO_BL;\r\n \tdev->_SPIHandle = handle;\r\n }\r\n+// ja ja\r\n \r\n-\r\n bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n {\r\n \tspi_transaction_t SPITransaction;\r\n \tesp_err_t ret;\r\n"
                },
                {
                    "date": 1731789758262,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,84 +41,82 @@\n \r\n \r\n void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n {\r\n-\tesp_err_t ret;\r\n+    esp_err_t ret;\r\n \r\n-\tESP_LOGI(TAG, \"GPIO_CS=%d\",GPIO_CS);\r\n-\tif ( GPIO_CS >= 0 ) {\r\n-\t\t//gpio_pad_select_gpio( GPIO_CS );\r\n-\t\tgpio_reset_pin( GPIO_CS );\r\n-\t\tgpio_set_direction( GPIO_CS, GPIO_MODE_OUTPUT );\r\n-\t\tgpio_set_level( GPIO_CS, 0 );\r\n-\t}\r\n+    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n+    if (GPIO_CS >= 0) {\r\n+        gpio_reset_pin(GPIO_CS);\r\n+        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_CS, 0);\r\n+    }\r\n \r\n-\tESP_LOGI(TAG, \"GPIO_DC=%d\",GPIO_DC);\r\n-\t//gpio_pad_select_gpio( GPIO_DC );\r\n-\tgpio_reset_pin( GPIO_DC );\r\n-\tgpio_set_direction( GPIO_DC, GPIO_MODE_OUTPUT );\r\n-\tgpio_set_level( GPIO_DC, 0 );\r\n+    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n+    gpio_reset_pin(GPIO_DC);\r\n+    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n+    gpio_set_level(GPIO_DC, 0);\r\n \r\n-\tESP_LOGI(TAG, \"GPIO_RESET=%d\",GPIO_RESET);\r\n-\tif ( GPIO_RESET >= 0 ) {\r\n-\t\t//gpio_pad_select_gpio( GPIO_RESET );\r\n-\t\tgpio_reset_pin( GPIO_RESET );\r\n-\t\tgpio_set_direction( GPIO_RESET, GPIO_MODE_OUTPUT );\r\n-\t\tgpio_set_level( GPIO_RESET, 1 );\r\n-\t\tdelayMS(100);\r\n-\t\tgpio_set_level( GPIO_RESET, 0 );\r\n-\t\tdelayMS(100);\r\n-\t\tgpio_set_level( GPIO_RESET, 1 );\r\n-\t\tdelayMS(100);\r\n-\t}\r\n+    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n+    if (GPIO_RESET >= 0) {\r\n+        gpio_reset_pin(GPIO_RESET);\r\n+        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n+        delayMS(100);\r\n+    }\r\n \r\n-\tESP_LOGI(TAG, \"GPIO_BL=%d\",GPIO_BL);\r\n-\tif ( GPIO_BL >= 0 ) {\r\n-\t\t//gpio_pad_select_gpio(GPIO_BL);\r\n-\t\tgpio_reset_pin(GPIO_BL);\r\n-\t\tgpio_set_direction( GPIO_BL, GPIO_MODE_OUTPUT );\r\n-\t\tgpio_set_level( GPIO_BL, 0 );\r\n-\t}\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 1); // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n \r\n-\tESP_LOGI(TAG, \"GPIO_MOSI=%d\",GPIO_MOSI);\r\n-\tESP_LOGI(TAG, \"GPIO_SCLK=%d\",GPIO_SCLK);\r\n-\tspi_bus_config_t buscfg = {\r\n-\t\t.mosi_io_num = GPIO_MOSI,\r\n-\t\t.miso_io_num = -1,\r\n-\t\t.sclk_io_num = GPIO_SCLK,\r\n-\t\t.quadwp_io_num = -1,\r\n-\t\t.quadhd_io_num = -1,\r\n-\t\t.max_transfer_sz = 0,\r\n-\t\t.flags = 0\r\n-\t};\r\n+    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n+    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n+    spi_bus_config_t buscfg = {\r\n+        .mosi_io_num = GPIO_MOSI,\r\n+        .miso_io_num = -1,\r\n+        .sclk_io_num = GPIO_SCLK,\r\n+        .quadwp_io_num = -1,\r\n+        .quadhd_io_num = -1,\r\n+        .max_transfer_sz = 0,\r\n+        .flags = 0\r\n+    };\r\n \r\n-\tret = spi_bus_initialize( HOST_ID, &buscfg, SPI_DMA_CH_AUTO );\r\n-\tESP_LOGD(TAG, \"spi_bus_initialize=%d\",ret);\r\n-\tassert(ret==ESP_OK);\r\n+    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n+    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n \r\n-\tspi_device_interface_config_t devcfg;\r\n-\tmemset(&devcfg, 0, sizeof(devcfg));\r\n-\tdevcfg.clock_speed_hz = SPI_Frequency;\r\n-\tdevcfg.queue_size = 7;\r\n-\tdevcfg.mode = 2;\r\n-\tdevcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+    spi_device_interface_config_t devcfg;\r\n+    memset(&devcfg, 0, sizeof(devcfg));\r\n+    devcfg.clock_speed_hz = SPI_Frequency;\r\n+    devcfg.queue_size = 7;\r\n+    devcfg.mode = 2;\r\n+    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n \r\n-\tif ( GPIO_CS >= 0 ) {\r\n-\t\tdevcfg.spics_io_num = GPIO_CS;\r\n-\t} else {\r\n-\t\tdevcfg.spics_io_num = -1;\r\n-\t}\r\n-\t\r\n-\tspi_device_handle_t handle;\r\n-\tret = spi_bus_add_device( HOST_ID, &devcfg, &handle);\r\n-\tESP_LOGD(TAG, \"spi_bus_add_device=%d\",ret);\r\n-\tassert(ret==ESP_OK);\r\n-\tdev->_dc = GPIO_DC;\r\n-\tdev->_bl = GPIO_BL;\r\n-\tdev->_SPIHandle = handle;\r\n+    if (GPIO_CS >= 0) {\r\n+        devcfg.spics_io_num = GPIO_CS;\r\n+    } else {\r\n+        devcfg.spics_io_num = -1;\r\n+    }\r\n+\r\n+    spi_device_handle_t handle;\r\n+    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n+    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    dev->_dc = GPIO_DC;\r\n+    dev->_bl = GPIO_BL;\r\n+    dev->_SPIHandle = handle;\r\n }\r\n-// ja ja\r\n \r\n+\r\n bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n {\r\n \tspi_transaction_t SPITransaction;\r\n \tesp_err_t ret;\r\n"
                },
                {
                    "date": 1731798302647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,944 @@\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+#include <math.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+\r\n+#include <driver/spi_master.h>\r\n+#include <driver/gpio.h>\r\n+#include \"esp_log.h\"\r\n+\r\n+#include \"st7789.h\"\r\n+\r\n+#define TAG \"ST7789\"\r\n+#define\t_DEBUG_ 0\r\n+\r\n+#if 0\r\n+#ifdef CONFIG_IDF_TARGET_ESP32\r\n+#define LCD_HOST HSPI_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32S2\r\n+#define LCD_HOST SPI2_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32S3\r\n+#define LCD_HOST SPI2_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32C3\r\n+#define LCD_HOST SPI2_HOST\r\n+#endif\r\n+#endif\r\n+\r\n+#if CONFIG_SPI2_HOST\r\n+#define HOST_ID SPI2_HOST\r\n+#elif CONFIG_SPI3_HOST\r\n+#define HOST_ID SPI3_HOST\r\n+#endif\r\n+\r\n+static const int SPI_Command_Mode = 0;\r\n+static const int SPI_Data_Mode = 1;\r\n+static const int SPI_Frequency = SPI_MASTER_FREQ_20M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_26M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_80M;\r\n+\r\n+\r\n+void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n+{\r\n+    esp_err_t ret;\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n+    if (GPIO_CS >= 0) {\r\n+        gpio_reset_pin(GPIO_CS);\r\n+        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_CS, 0);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n+    gpio_reset_pin(GPIO_DC);\r\n+    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n+    gpio_set_level(GPIO_DC, 0);\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n+    if (GPIO_RESET >= 0) {\r\n+        gpio_reset_pin(GPIO_RESET);\r\n+        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n+        delayMS(100);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 0); // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n+    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n+    spi_bus_config_t buscfg = {\r\n+        .mosi_io_num = GPIO_MOSI,\r\n+        .miso_io_num = -1,\r\n+        .sclk_io_num = GPIO_SCLK,\r\n+        .quadwp_io_num = -1,\r\n+        .quadhd_io_num = -1,\r\n+        .max_transfer_sz = 0,\r\n+        .flags = 0\r\n+    };\r\n+\r\n+    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n+    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    spi_device_interface_config_t devcfg;\r\n+    memset(&devcfg, 0, sizeof(devcfg));\r\n+    devcfg.clock_speed_hz = SPI_Frequency;\r\n+    devcfg.queue_size = 7;\r\n+    devcfg.mode = 2;\r\n+    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+\r\n+    if (GPIO_CS >= 0) {\r\n+        devcfg.spics_io_num = GPIO_CS;\r\n+    } else {\r\n+        devcfg.spics_io_num = -1;\r\n+    }\r\n+\r\n+    spi_device_handle_t handle;\r\n+    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n+    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    dev->_dc = GPIO_DC;\r\n+    dev->_bl = GPIO_BL;\r\n+    dev->_SPIHandle = handle;\r\n+}\r\n+\r\n+\r\n+bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n+{\r\n+\tspi_transaction_t SPITransaction;\r\n+\tesp_err_t ret;\r\n+\r\n+\tif ( DataLength > 0 ) {\r\n+\t\tmemset( &SPITransaction, 0, sizeof( spi_transaction_t ) );\r\n+\t\tSPITransaction.length = DataLength * 8;\r\n+\t\tSPITransaction.tx_buffer = Data;\r\n+#if 1\r\n+\t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n+#else\r\n+\t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n+#endif\r\n+\t\tassert(ret==ESP_OK); \r\n+\t}\r\n+\r\n+\treturn true;\r\n+}\r\n+\r\n+bool spi_master_write_command(TFT_t * dev, uint8_t cmd)\r\n+{\r\n+\tstatic uint8_t Byte = 0;\r\n+\tByte = cmd;\r\n+\tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n+}\r\n+\r\n+bool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n+{\r\n+\tstatic uint8_t Byte = 0;\r\n+\tByte = data;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n+}\r\n+\r\n+\r\n+bool spi_master_write_data_word(TFT_t * dev, uint16_t data)\r\n+{\r\n+\tstatic uint8_t Byte[2];\r\n+\tByte[0] = (data >> 8) & 0xFF;\r\n+\tByte[1] = data & 0xFF;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n+}\r\n+\r\n+bool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n+{\r\n+\tstatic uint8_t Byte[4];\r\n+\tByte[0] = (addr1 >> 8) & 0xFF;\r\n+\tByte[1] = addr1 & 0xFF;\r\n+\tByte[2] = (addr2 >> 8) & 0xFF;\r\n+\tByte[3] = addr2 & 0xFF;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n+}\r\n+\r\n+bool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n+{\r\n+\tstatic uint8_t Byte[1024];\r\n+\tint index = 0;\r\n+\tfor(int i=0;i<size;i++) {\r\n+\t\tByte[index++] = (color >> 8) & 0xFF;\r\n+\t\tByte[index++] = color & 0xFF;\r\n+\t}\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n+}\r\n+\r\n+// Add 202001\r\n+bool spi_master_write_colors(TFT_t * dev, uint16_t * colors, uint16_t size)\r\n+{\r\n+\tstatic uint8_t Byte[1024];\r\n+\tint index = 0;\r\n+\tfor(int i=0;i<size;i++) {\r\n+\t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n+\t\tByte[index++] = colors[i] & 0xFF;\r\n+\t}\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n+}\r\n+\r\n+void delayMS(int ms) {\r\n+\tint _ms = ms + (portTICK_PERIOD_MS - 1);\r\n+\tTickType_t xTicksToDelay = _ms / portTICK_PERIOD_MS;\r\n+\tESP_LOGD(TAG, \"ms=%d _ms=%d portTICK_PERIOD_MS=%\"PRIu32\" xTicksToDelay=%\"PRIu32,ms,_ms,portTICK_PERIOD_MS,xTicksToDelay);\r\n+\tvTaskDelay(xTicksToDelay);\r\n+}\r\n+\r\n+\r\n+void lcdInit(TFT_t * dev, int width, int height, int offsetx, int offsety)\r\n+{\r\n+\tdev->_width = width;\r\n+\tdev->_height = height;\r\n+\tdev->_offsetx = offsetx;\r\n+\tdev->_offsety = offsety;\r\n+\tdev->_font_direction = DIRECTION0;\r\n+\tdev->_font_fill = false;\r\n+\tdev->_font_underline = false;\r\n+\r\n+\tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n+\tdelayMS(150);\r\n+\r\n+\tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n+\tdelayMS(255);\r\n+\t\r\n+\tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n+\tspi_master_write_data_byte(dev, 0x55);\r\n+\tdelayMS(10);\r\n+\t\r\n+\tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\r\n+\tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n+\r\n+\tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n+\r\n+\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n+\tdelayMS(10);\r\n+\r\n+\tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n+\tdelayMS(10);\r\n+\r\n+\tspi_master_write_command(dev, 0x29);\t//Display ON\r\n+\tdelayMS(255);\r\n+\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 1 );\r\n+\t}\r\n+}\r\n+\r\n+\r\n+// Draw pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// color:color\r\n+void lcdDrawPixel(TFT_t * dev, uint16_t x, uint16_t y, uint16_t color){\r\n+\tif (x >= dev->_width) return;\r\n+\tif (y >= dev->_height) return;\r\n+\r\n+\tuint16_t _x = x + dev->_offsetx;\r\n+\tuint16_t _y = y + dev->_offsety;\r\n+\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x, _x);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y, _y);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tspi_master_write_data_word(dev, color);\r\n+}\r\n+\r\n+\r\n+// Draw multi pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// size:Number of colors\r\n+// colors:colors\r\n+void lcdDrawMultiPixels(TFT_t * dev, uint16_t x, uint16_t y, uint16_t size, uint16_t * colors) {\r\n+\tif (x+size > dev->_width) return;\r\n+\tif (y >= dev->_height) return;\r\n+\r\n+\tuint16_t _x1 = x + dev->_offsetx;\r\n+\tuint16_t _x2 = _x1 + (size-1);\r\n+\tuint16_t _y1 = y + dev->_offsety;\r\n+\tuint16_t _y2 = _y1;\r\n+\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x1, _x2);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y1, _y2);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tspi_master_write_colors(dev, colors, size);\r\n+}\r\n+\r\n+// Draw rectangle of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End X coordinate\r\n+// y2:End Y coordinate\r\n+// color:color\r\n+void lcdDrawFillRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tif (x1 >= dev->_width) return;\r\n+\tif (x2 >= dev->_width) x2=dev->_width-1;\r\n+\tif (y1 >= dev->_height) return;\r\n+\tif (y2 >= dev->_height) y2=dev->_height-1;\r\n+\r\n+\tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n+\tuint16_t _x1 = x1 + dev->_offsetx;\r\n+\tuint16_t _x2 = x2 + dev->_offsetx;\r\n+\tuint16_t _y1 = y1 + dev->_offsety;\r\n+\tuint16_t _y2 = y2 + dev->_offsety;\r\n+\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x1, _x2);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y1, _y2);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tfor(int i=_x1;i<=_x2;i++){\r\n+\t\tuint16_t size = _y2-_y1+1;\r\n+\t\tspi_master_write_color(dev, color, size);\r\n+#if 0\r\n+\t\tfor(j=y1;j<=y2;j++){\r\n+\t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n+\t\t\tspi_master_write_data_word(dev, color);\r\n+\t\t}\r\n+#endif\r\n+\t}\r\n+}\r\n+\r\n+// Display OFF\r\n+void lcdDisplayOff(TFT_t * dev) {\r\n+\tspi_master_write_command(dev, 0x28);\t//Display off\r\n+}\r\n+ \r\n+// Display ON\r\n+void lcdDisplayOn(TFT_t * dev) {\r\n+\tspi_master_write_command(dev, 0x29);\t//Display on\r\n+}\r\n+\r\n+// Fill screen\r\n+// color:color\r\n+void lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n+\tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n+}\r\n+\r\n+// Draw line\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color \r\n+void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tint i;\r\n+\tint dx,dy;\r\n+\tint sx,sy;\r\n+\tint E;\r\n+\r\n+\t/* distance between two points */\r\n+\tdx = ( x2 > x1 ) ? x2 - x1 : x1 - x2;\r\n+\tdy = ( y2 > y1 ) ? y2 - y1 : y1 - y2;\r\n+\r\n+\t/* direction of two point */\r\n+\tsx = ( x2 > x1 ) ? 1 : -1;\r\n+\tsy = ( y2 > y1 ) ? 1 : -1;\r\n+\r\n+\t/* inclination < 1 */\r\n+\tif ( dx > dy ) {\r\n+\t\tE = -dx;\r\n+\t\tfor ( i = 0 ; i <= dx ; i++ ) {\r\n+\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n+\t\t\tx1 += sx;\r\n+\t\t\tE += 2 * dy;\r\n+\t\t\tif ( E >= 0 ) {\r\n+\t\t\ty1 += sy;\r\n+\t\t\tE -= 2 * dx;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/* inclination >= 1 */\r\n+\t} else {\r\n+\t\tE = -dy;\r\n+\t\tfor ( i = 0 ; i <= dy ; i++ ) {\r\n+\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n+\t\t\ty1 += sy;\r\n+\t\t\tE += 2 * dx;\r\n+\t\t\tif ( E >= 0 ) {\r\n+\t\t\t\tx1 += sx;\r\n+\t\t\t\tE -= 2 * dy;\r\n+\t\t\t}\r\n+\t\t}\r\n+\t}\r\n+}\r\n+\r\n+// Draw rectangle\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n+\tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n+\tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n+}\r\n+\r\n+// Draw rectangle with angle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of rectangle\r\n+// h:Height of rectangle\r\n+// angle:Angle of rectangle\r\n+// color:color\r\n+\r\n+//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tdouble xd,yd,rd;\r\n+\tint x1,y1;\r\n+\tint x2,y2;\r\n+\tint x3,y3;\r\n+\tint x4,y4;\r\n+\trd = -angle * M_PI / 180.0;\r\n+\txd = 0.0 - w/2;\r\n+\tyd = h/2;\r\n+\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tyd = 0.0 - yd;\r\n+\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = w/2;\r\n+\tyd = h/2;\r\n+\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tyd = 0.0 - yd;\r\n+\tx4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+\tlcdDrawLine(dev, x2, y2, x4, y4, color);\r\n+\tlcdDrawLine(dev, x3, y3, x4, y4, color);\r\n+}\r\n+\r\n+// Draw triangle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of triangle\r\n+// h:Height of triangle\r\n+// angle:Angle of triangle\r\n+// color:color\r\n+\r\n+//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tdouble xd,yd,rd;\r\n+\tint x1,y1;\r\n+\tint x2,y2;\r\n+\tint x3,y3;\r\n+\trd = -angle * M_PI / 180.0;\r\n+\txd = 0.0;\r\n+\tyd = h/2;\r\n+\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = w/2;\r\n+\tyd = 0.0 - yd;\r\n+\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = 0.0 - w/2;\r\n+\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+\tlcdDrawLine(dev, x2, y2, x3, y3, color);\r\n+}\r\n+\r\n+// Draw circle\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\tdo{\r\n+\t\tlcdDrawPixel(dev, x0-x, y0+y, color); \r\n+\t\tlcdDrawPixel(dev, x0-y, y0-x, color); \r\n+\t\tlcdDrawPixel(dev, x0+x, y0-y, color); \r\n+\t\tlcdDrawPixel(dev, x0+y, y0+x, color); \r\n+\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n+\t} while(y<0);\r\n+}\r\n+\r\n+// Draw circle of filling\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\tint ChangeX;\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\tChangeX=1;\r\n+\tdo{\r\n+\t\tif(ChangeX) {\r\n+\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n+\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n+\t\t} // endif\r\n+\t\tChangeX=(old_err=err)<=x;\r\n+\t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\r\n+\t} while(y<=0);\r\n+} \r\n+\r\n+// Draw rectangle with round corner\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\tunsigned char temp;\r\n+\r\n+\tif(x1>x2) {\r\n+\t\ttemp=x1; x1=x2; x2=temp;\r\n+\t} // endif\r\n+\t  \r\n+\tif(y1>y2) {\r\n+\t\ttemp=y1; y1=y2; y2=temp;\r\n+\t} // endif\r\n+\r\n+\tESP_LOGD(TAG, \"x1=%d x2=%d delta=%d r=%d\",x1, x2, x2-x1, r);\r\n+\tESP_LOGD(TAG, \"y1=%d y2=%d delta=%d r=%d\",y1, y2, y2-y1, r);\r\n+\tif (x2-x1 < r) return; // Add 20190517\r\n+\tif (y2-y1 < r) return; // Add 20190517\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\r\n+\tdo{\r\n+\t\tif(x) {\r\n+\t\t\tlcdDrawPixel(dev, x1+r-x, y1+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x2-r+x, y1+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x1+r-x, y2-r-y, color); \r\n+\t\t\tlcdDrawPixel(dev, x2-r+x, y2-r-y, color);\r\n+\t\t} // endif \r\n+\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n+\t} while(y<0);\r\n+\r\n+\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n+\tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n+\tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n+\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n+\tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n+\tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n+} \r\n+\r\n+// Draw arrow\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the botom\r\n+// color:color\r\n+// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n+void lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tdouble Vx= x1 - x0;\r\n+\tdouble Vy= y1 - y0;\r\n+\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n+\t//\t printf(\"v=%f\\n\",v);\r\n+\tdouble Ux= Vx/v;\r\n+\tdouble Uy= Vy/v;\r\n+\r\n+\tuint16_t L[2],R[2];\r\n+\tL[0]= x1 - Uy*w - Ux*v;\r\n+\tL[1]= y1 + Ux*w - Uy*v;\r\n+\tR[0]= x1 + Uy*w - Ux*v;\r\n+\tR[1]= y1 - Ux*w - Uy*v;\r\n+\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\r\n+\t//lcdDrawLine(x0,y0,x1,y1,color);\r\n+\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+}\r\n+\r\n+\r\n+// Draw arrow of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the botom\r\n+// color:color\r\n+void lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tdouble Vx= x1 - x0;\r\n+\tdouble Vy= y1 - y0;\r\n+\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n+\t//printf(\"v=%f\\n\",v);\r\n+\tdouble Ux= Vx/v;\r\n+\tdouble Uy= Vy/v;\r\n+\r\n+\tuint16_t L[2],R[2];\r\n+\tL[0]= x1 - Uy*w - Ux*v;\r\n+\tL[1]= y1 + Ux*w - Uy*v;\r\n+\tR[0]= x1 + Uy*w - Ux*v;\r\n+\tR[1]= y1 - Ux*w - Uy*v;\r\n+\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\r\n+\tlcdDrawLine(dev, x0, y0, x1, y1, color);\r\n+\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+\r\n+\tint ww;\r\n+\tfor(ww=w-1;ww>0;ww--) {\r\n+\t\tL[0]= x1 - Uy*ww - Ux*v;\r\n+\t\tL[1]= y1 + Ux*ww - Uy*v;\r\n+\t\tR[0]= x1 + Uy*ww - Ux*v;\r\n+\t\tR[1]= y1 - Ux*ww - Uy*v;\r\n+\t\t//printf(\"Fill>L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\t\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\t\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\t}\r\n+}\r\n+\r\n+\r\n+// RGB565 conversion\r\n+// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n+// Bit image \"RRRRRGGGGGGBBBBB\"\r\n+uint16_t rgb565_conv(uint16_t r,uint16_t g,uint16_t b) {\r\n+\treturn (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n+}\r\n+\r\n+// Draw ASCII character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// ascii: ascii code\r\n+// color:color\r\n+int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n+\tuint16_t xx,yy,bit,ofs;\r\n+\tunsigned char fonts[128]; // font pattern\r\n+\tunsigned char pw, ph;\r\n+\tint h,w;\r\n+\tuint16_t mask;\r\n+\tbool rc;\r\n+\r\n+\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n+\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n+\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n+\tif (!rc) return 0;\r\n+\r\n+\tint16_t xd1 = 0;\r\n+\tint16_t yd1 = 0;\r\n+\tint16_t xd2 = 0;\r\n+\tint16_t yd2 = 0;\r\n+\tuint16_t xss = 0;\r\n+\tuint16_t yss = 0;\r\n+\tint16_t xsd = 0;\r\n+\tint16_t ysd = 0;\r\n+\tint16_t next = 0;\r\n+\tuint16_t x0  = 0;\r\n+\tuint16_t x1  = 0;\r\n+\tuint16_t y0  = 0;\r\n+\tuint16_t y1  = 0;\r\n+\tif (dev->_font_direction == 0) {\r\n+\t\txd1 = +1;\r\n+\t\tyd1 = +1; //-1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y - (ph - 1);\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x + pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y - (ph-1);\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n+\t} else if (dev->_font_direction == 2) {\r\n+\t\txd1 = -1;\r\n+\t\tyd1 = -1; //+1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y + ph + 1;\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x - pw;\r\n+\r\n+\t\tx0\t= x - (pw-1);\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y + (ph-1);\r\n+\t} else if (dev->_font_direction == 1) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = -1;\r\n+\t\tyd2 = +1; //-1;\r\n+\t\txss =  x + ph;\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y + pw; //y - pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x + (ph-1);\r\n+\t\ty1\t= y + (pw-1);\r\n+\t} else if (dev->_font_direction == 3) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = +1;\r\n+\t\tyd2 = -1; //+1;\r\n+\t\txss =  x - (ph - 1);\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y - pw; //y + pw;\r\n+\r\n+\t\tx0\t= x - (ph-1);\r\n+\t\ty0\t= y - (pw-1);\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y;\r\n+\t}\r\n+\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\r\n+\tint bits;\r\n+\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n+\tofs = 0;\r\n+\tyy = yss;\r\n+\txx = xss;\r\n+\tfor(h=0;h<ph;h++) {\r\n+\t\tif(xsd) xx = xss;\r\n+\t\tif(ysd) yy = yss;\r\n+\t\t//for(w=0;w<(pw/8);w++) {\r\n+\t\tbits = pw;\r\n+\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n+\t\t\tmask = 0x80;\r\n+\t\t\tfor(bit=0;bit<8;bit++) {\r\n+\t\t\t\tbits--;\r\n+\t\t\t\tif (bits < 0) continue;\r\n+\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n+\t\t\t\tif (fonts[ofs] & mask) {\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\txx = xx + xd1;\r\n+\t\t\t\tyy = yy + yd2;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t}\r\n+\t\t\tofs++;\r\n+\t\t}\r\n+\t\tyy = yy + yd1;\r\n+\t\txx = xx + xd2;\r\n+\t}\r\n+\r\n+\tif (next < 0) next = 0;\r\n+\treturn next;\r\n+}\r\n+\r\n+int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n+\tint length = strlen((char *)ascii);\r\n+\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tfor(int i=0;i<length;i++) {\r\n+\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+\r\n+// Draw Non-Alphanumeric character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// code:character code\r\n+// color:color\r\n+int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n+\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n+\tif (dev->_font_direction == 0)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 1)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 2)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 3)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+#if 0\r\n+// Draw UTF8 character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utf8:UTF8 code\r\n+// color:color\r\n+int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n+\tuint16_t sjis[1];\r\n+\r\n+\tsjis[0] = UTF2SJIS(utf8);\r\n+\tif(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n+\treturn lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n+}\r\n+\r\n+// Draw UTF8 string\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utfs:UTF8 string\r\n+// color:color\r\n+int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n+\r\n+\tint i;\r\n+\tint spos;\r\n+\tuint16_t sjis[64];\r\n+\tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n+\tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n+\tfor(i=0;i<spos;i++) {\r\n+\t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+#endif\r\n+\r\n+// Set font direction\r\n+// dir:Direction\r\n+void lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n+\tdev->_font_direction = dir;\r\n+}\r\n+\r\n+// Set font filling\r\n+// color:fill color\r\n+void lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n+\tdev->_font_fill = true;\r\n+\tdev->_font_fill_color = color;\r\n+}\r\n+\r\n+// UnSet font filling\r\n+void lcdUnsetFontFill(TFT_t * dev) {\r\n+\tdev->_font_fill = false;\r\n+}\r\n+\r\n+// Set font underline\r\n+// color:frame color\r\n+void lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n+\tdev->_font_underline = true;\r\n+\tdev->_font_underline_color = color;\r\n+}\r\n+\r\n+// UnSet font underline\r\n+void lcdUnsetFontUnderLine(TFT_t * dev) {\r\n+\tdev->_font_underline = false;\r\n+}\r\n+\r\n+// Backlight OFF\r\n+void lcdBacklightOff(TFT_t * dev) {\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 0 );\r\n+\t}\r\n+}\r\n+\r\n+// Backlight ON\r\n+void lcdBacklightOn(TFT_t * dev) {\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 1 );\r\n+\t}\r\n+}\r\n+\r\n+// Display Inversion Off\r\n+void lcdInversionOff(TFT_t * dev) {\r\n+\tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n+}\r\n+\r\n+// Display Inversion On\r\n+void lcdInversionOn(TFT_t * dev) {\r\n+\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n+}\r\n"
                },
                {
                    "date": 1731802370194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -355,993 +355,56 @@\n // x2:End   X coordinate\r\n // y2:End   Y coordinate\r\n // color:color \r\n void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tint i;\r\n-\tint dx,dy;\r\n-\tint sx,sy;\r\n-\tint E;\r\n+    int i;\r\n+    int dx, dy;\r\n+    int sx, sy;\r\n+    int E;\r\n \r\n-\t/* distance between two points */\r\n-\tdx = ( x2 > x1 ) ? x2 - x1 : x1 - x2;\r\n-\tdy = ( y2 > y1 ) ? y2 - y1 : y1 - y2;\r\n+    /* distance between two points */\r\n+    dx = (x2 > x1) ? x2 - x1 : x1 - x2;\r\n+    dy = (y2 > y1) ? y2 - y1 : y1 - y2;\r\n \r\n-\t/* direction of two point */\r\n-\tsx = ( x2 > x1 ) ? 1 : -1;\r\n-\tsy = ( y2 > y1 ) ? 1 : -1;\r\n+    /* direction of two points */\r\n+    sx = (x2 > x1) ? 1 : -1;\r\n+    sy = (y2 > y1) ? 1 : -1;\r\n \r\n-\t/* inclination < 1 */\r\n-\tif ( dx > dy ) {\r\n-\t\tE = -dx;\r\n-\t\tfor ( i = 0 ; i <= dx ; i++ ) {\r\n-\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n-\t\t\tx1 += sx;\r\n-\t\t\tE += 2 * dy;\r\n-\t\t\tif ( E >= 0 ) {\r\n-\t\t\ty1 += sy;\r\n-\t\t\tE -= 2 * dx;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/* inclination >= 1 */\r\n-\t} else {\r\n-\t\tE = -dy;\r\n-\t\tfor ( i = 0 ; i <= dy ; i++ ) {\r\n-\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n-\t\t\ty1 += sy;\r\n-\t\t\tE += 2 * dx;\r\n-\t\t\tif ( E >= 0 ) {\r\n-\t\t\t\tx1 += sx;\r\n-\t\t\t\tE -= 2 * dy;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n-// Draw rectangle\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n-\tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n-\tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n-}\r\n-\r\n-// Draw rectangle with angle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of rectangle\r\n-// h:Height of rectangle\r\n-// angle:Angle of rectangle\r\n-// color:color\r\n-\r\n-//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-\tdouble xd,yd,rd;\r\n-\tint x1,y1;\r\n-\tint x2,y2;\r\n-\tint x3,y3;\r\n-\tint x4,y4;\r\n-\trd = -angle * M_PI / 180.0;\r\n-\txd = 0.0 - w/2;\r\n-\tyd = h/2;\r\n-\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tyd = 0.0 - yd;\r\n-\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = w/2;\r\n-\tyd = h/2;\r\n-\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tyd = 0.0 - yd;\r\n-\tx4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-\tlcdDrawLine(dev, x2, y2, x4, y4, color);\r\n-\tlcdDrawLine(dev, x3, y3, x4, y4, color);\r\n-}\r\n-\r\n-// Draw triangle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of triangle\r\n-// h:Height of triangle\r\n-// angle:Angle of triangle\r\n-// color:color\r\n-\r\n-//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-\tdouble xd,yd,rd;\r\n-\tint x1,y1;\r\n-\tint x2,y2;\r\n-\tint x3,y3;\r\n-\trd = -angle * M_PI / 180.0;\r\n-\txd = 0.0;\r\n-\tyd = h/2;\r\n-\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = w/2;\r\n-\tyd = 0.0 - yd;\r\n-\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = 0.0 - w/2;\r\n-\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-\tlcdDrawLine(dev, x2, y2, x3, y3, color);\r\n-}\r\n-\r\n-// Draw circle\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\tdo{\r\n-\t\tlcdDrawPixel(dev, x0-x, y0+y, color); \r\n-\t\tlcdDrawPixel(dev, x0-y, y0-x, color); \r\n-\t\tlcdDrawPixel(dev, x0+x, y0-y, color); \r\n-\t\tlcdDrawPixel(dev, x0+y, y0+x, color); \r\n-\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n-\t} while(y<0);\r\n-}\r\n-\r\n-// Draw circle of filling\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\tint ChangeX;\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\tChangeX=1;\r\n-\tdo{\r\n-\t\tif(ChangeX) {\r\n-\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n-\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n-\t\t} // endif\r\n-\t\tChangeX=(old_err=err)<=x;\r\n-\t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\r\n-\t} while(y<=0);\r\n-} \r\n-\r\n-// Draw rectangle with round corner\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\tunsigned char temp;\r\n-\r\n-\tif(x1>x2) {\r\n-\t\ttemp=x1; x1=x2; x2=temp;\r\n-\t} // endif\r\n-\t  \r\n-\tif(y1>y2) {\r\n-\t\ttemp=y1; y1=y2; y2=temp;\r\n-\t} // endif\r\n-\r\n-\tESP_LOGD(TAG, \"x1=%d x2=%d delta=%d r=%d\",x1, x2, x2-x1, r);\r\n-\tESP_LOGD(TAG, \"y1=%d y2=%d delta=%d r=%d\",y1, y2, y2-y1, r);\r\n-\tif (x2-x1 < r) return; // Add 20190517\r\n-\tif (y2-y1 < r) return; // Add 20190517\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\r\n-\tdo{\r\n-\t\tif(x) {\r\n-\t\t\tlcdDrawPixel(dev, x1+r-x, y1+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x2-r+x, y1+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x1+r-x, y2-r-y, color); \r\n-\t\t\tlcdDrawPixel(dev, x2-r+x, y2-r-y, color);\r\n-\t\t} // endif \r\n-\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n-\t} while(y<0);\r\n-\r\n-\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n-\tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n-\tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n-\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n-\tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n-\tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n-} \r\n-\r\n-// Draw arrow\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the botom\r\n-// color:color\r\n-// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n-void lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n-\tdouble Vx= x1 - x0;\r\n-\tdouble Vy= y1 - y0;\r\n-\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n-\t//\t printf(\"v=%f\\n\",v);\r\n-\tdouble Ux= Vx/v;\r\n-\tdouble Uy= Vy/v;\r\n-\r\n-\tuint16_t L[2],R[2];\r\n-\tL[0]= x1 - Uy*w - Ux*v;\r\n-\tL[1]= y1 + Ux*w - Uy*v;\r\n-\tR[0]= x1 + Uy*w - Ux*v;\r\n-\tR[1]= y1 - Ux*w - Uy*v;\r\n-\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\r\n-\t//lcdDrawLine(x0,y0,x1,y1,color);\r\n-\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-}\r\n-\r\n-\r\n-// Draw arrow of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the botom\r\n-// color:color\r\n-void lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n-\tdouble Vx= x1 - x0;\r\n-\tdouble Vy= y1 - y0;\r\n-\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n-\t//printf(\"v=%f\\n\",v);\r\n-\tdouble Ux= Vx/v;\r\n-\tdouble Uy= Vy/v;\r\n-\r\n-\tuint16_t L[2],R[2];\r\n-\tL[0]= x1 - Uy*w - Ux*v;\r\n-\tL[1]= y1 + Ux*w - Uy*v;\r\n-\tR[0]= x1 + Uy*w - Ux*v;\r\n-\tR[1]= y1 - Ux*w - Uy*v;\r\n-\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\r\n-\tlcdDrawLine(dev, x0, y0, x1, y1, color);\r\n-\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-\r\n-\tint ww;\r\n-\tfor(ww=w-1;ww>0;ww--) {\r\n-\t\tL[0]= x1 - Uy*ww - Ux*v;\r\n-\t\tL[1]= y1 + Ux*ww - Uy*v;\r\n-\t\tR[0]= x1 + Uy*ww - Ux*v;\r\n-\t\tR[1]= y1 - Ux*ww - Uy*v;\r\n-\t\t//printf(\"Fill>L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\t\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\t\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\t}\r\n-}\r\n-\r\n-\r\n-// RGB565 conversion\r\n-// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n-// Bit image \"RRRRRGGGGGGBBBBB\"\r\n-uint16_t rgb565_conv(uint16_t r,uint16_t g,uint16_t b) {\r\n-\treturn (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n-}\r\n-\r\n-// Draw ASCII character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// ascii: ascii code\r\n-// color:color\r\n-int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n-\tuint16_t xx,yy,bit,ofs;\r\n-\tunsigned char fonts[128]; // font pattern\r\n-\tunsigned char pw, ph;\r\n-\tint h,w;\r\n-\tuint16_t mask;\r\n-\tbool rc;\r\n-\r\n-\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n-\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n-\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n-\tif (!rc) return 0;\r\n-\r\n-\tint16_t xd1 = 0;\r\n-\tint16_t yd1 = 0;\r\n-\tint16_t xd2 = 0;\r\n-\tint16_t yd2 = 0;\r\n-\tuint16_t xss = 0;\r\n-\tuint16_t yss = 0;\r\n-\tint16_t xsd = 0;\r\n-\tint16_t ysd = 0;\r\n-\tint16_t next = 0;\r\n-\tuint16_t x0  = 0;\r\n-\tuint16_t x1  = 0;\r\n-\tuint16_t y0  = 0;\r\n-\tuint16_t y1  = 0;\r\n-\tif (dev->_font_direction == 0) {\r\n-\t\txd1 = +1;\r\n-\t\tyd1 = +1; //-1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y - (ph - 1);\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x + pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y - (ph-1);\r\n-\t\tx1\t= x + (pw-1);\r\n-\t\ty1\t= y;\r\n-\t} else if (dev->_font_direction == 2) {\r\n-\t\txd1 = -1;\r\n-\t\tyd1 = -1; //+1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y + ph + 1;\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x - pw;\r\n-\r\n-\t\tx0\t= x - (pw-1);\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y + (ph-1);\r\n-\t} else if (dev->_font_direction == 1) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = -1;\r\n-\t\tyd2 = +1; //-1;\r\n-\t\txss =  x + ph;\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y + pw; //y - pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x + (ph-1);\r\n-\t\ty1\t= y + (pw-1);\r\n-\t} else if (dev->_font_direction == 3) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = +1;\r\n-\t\tyd2 = -1; //+1;\r\n-\t\txss =  x - (ph - 1);\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y - pw; //y + pw;\r\n-\r\n-\t\tx0\t= x - (ph-1);\r\n-\t\ty0\t= y - (pw-1);\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y;\r\n-\t}\r\n-\r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n-\r\n-\tint bits;\r\n-\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n-\tofs = 0;\r\n-\tyy = yss;\r\n-\txx = xss;\r\n-\tfor(h=0;h<ph;h++) {\r\n-\t\tif(xsd) xx = xss;\r\n-\t\tif(ysd) yy = yss;\r\n-\t\t//for(w=0;w<(pw/8);w++) {\r\n-\t\tbits = pw;\r\n-\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n-\t\t\tmask = 0x80;\r\n-\t\t\tfor(bit=0;bit<8;bit++) {\r\n-\t\t\t\tbits--;\r\n-\t\t\t\tif (bits < 0) continue;\r\n-\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n-\t\t\t\tif (fonts[ofs] & mask) {\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n-\t\t\t\t}\r\n-\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\txx = xx + xd1;\r\n-\t\t\t\tyy = yy + yd2;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t}\r\n-\t\t\tofs++;\r\n-\t\t}\r\n-\t\tyy = yy + yd1;\r\n-\t\txx = xx + xd2;\r\n-\t}\r\n-\r\n-\tif (next < 0) next = 0;\r\n-\treturn next;\r\n-}\r\n-\r\n-int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n-\tint length = strlen((char *)ascii);\r\n-\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n-\tfor(int i=0;i<length;i++) {\r\n-\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-\r\n-// Draw Non-Alphanumeric character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// code:character code\r\n-// color:color\r\n-int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n-\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n-\tif (dev->_font_direction == 0)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 1)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 2)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 3)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-#if 0\r\n-// Draw UTF8 character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utf8:UTF8 code\r\n-// color:color\r\n-int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n-\tuint16_t sjis[1];\r\n-\r\n-\tsjis[0] = UTF2SJIS(utf8);\r\n-\tif(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n-\treturn lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n-}\r\n-\r\n-// Draw UTF8 string\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utfs:UTF8 string\r\n-// color:color\r\n-int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n-\r\n-\tint i;\r\n-\tint spos;\r\n-\tuint16_t sjis[64];\r\n-\tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n-\tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n-\tfor(i=0;i<spos;i++) {\r\n-\t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-#endif\r\n-\r\n-// Set font direction\r\n-// dir:Direction\r\n-void lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n-\tdev->_font_direction = dir;\r\n-}\r\n-\r\n-// Set font filling\r\n-// color:fill color\r\n-void lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n-\tdev->_font_fill = true;\r\n-\tdev->_font_fill_color = color;\r\n-}\r\n-\r\n-// UnSet font filling\r\n-void lcdUnsetFontFill(TFT_t * dev) {\r\n-\tdev->_font_fill = false;\r\n-}\r\n-\r\n-// Set font underline\r\n-// color:frame color\r\n-void lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n-\tdev->_font_underline = true;\r\n-\tdev->_font_underline_color = color;\r\n-}\r\n-\r\n-// UnSet font underline\r\n-void lcdUnsetFontUnderLine(TFT_t * dev) {\r\n-\tdev->_font_underline = false;\r\n-}\r\n-\r\n-// Backlight OFF\r\n-void lcdBacklightOff(TFT_t * dev) {\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 0 );\r\n-\t}\r\n-}\r\n-\r\n-// Backlight ON\r\n-void lcdBacklightOn(TFT_t * dev) {\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 1 );\r\n-\t}\r\n-}\r\n-\r\n-// Display Inversion Off\r\n-void lcdInversionOff(TFT_t * dev) {\r\n-\tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n-}\r\n-\r\n-// Display Inversion On\r\n-void lcdInversionOn(TFT_t * dev) {\r\n-\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n-}\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-#include <math.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-\r\n-#include <driver/spi_master.h>\r\n-#include <driver/gpio.h>\r\n-#include \"esp_log.h\"\r\n-\r\n-#include \"st7789.h\"\r\n-\r\n-#define TAG \"ST7789\"\r\n-#define\t_DEBUG_ 0\r\n-\r\n-#if 0\r\n-#ifdef CONFIG_IDF_TARGET_ESP32\r\n-#define LCD_HOST HSPI_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32S2\r\n-#define LCD_HOST SPI2_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32S3\r\n-#define LCD_HOST SPI2_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32C3\r\n-#define LCD_HOST SPI2_HOST\r\n-#endif\r\n-#endif\r\n-\r\n-#if CONFIG_SPI2_HOST\r\n-#define HOST_ID SPI2_HOST\r\n-#elif CONFIG_SPI3_HOST\r\n-#define HOST_ID SPI3_HOST\r\n-#endif\r\n-\r\n-static const int SPI_Command_Mode = 0;\r\n-static const int SPI_Data_Mode = 1;\r\n-static const int SPI_Frequency = SPI_MASTER_FREQ_20M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_26M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_80M;\r\n-\r\n-\r\n-void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n-{\r\n-    esp_err_t ret;\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n-    if (GPIO_CS >= 0) {\r\n-        gpio_reset_pin(GPIO_CS);\r\n-        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_CS, 0);\r\n+    /* inclination < 1 */\r\n+    if (dx > dy) {\r\n+        E = -dx;\r\n+        for (i = 0; i <= dx; i++) {\r\n+            lcdDrawPixel(dev, x1, y1, color);\r\n+            x1 += sx;\r\n+            E += 2 * dy;\r\n+            if (E >= 0) {\r\n+                y1 += sy;\r\n+                E -= 2 * dx;\r\n+            }\r\n+            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n+                vTaskDelay(1); // Yield to other tasks\r\n+            }\r\n+        }\r\n     }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n-    gpio_reset_pin(GPIO_DC);\r\n-    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n-    gpio_set_level(GPIO_DC, 0);\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n-    if (GPIO_RESET >= 0) {\r\n-        gpio_reset_pin(GPIO_RESET);\r\n-        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n-        delayMS(100);\r\n+    /* inclination >= 1 */\r\n+    else {\r\n+        E = -dy;\r\n+        for (i = 0; i <= dy; i++) {\r\n+            lcdDrawPixel(dev, x1, y1, color);\r\n+            y1 += sy;\r\n+            E += 2 * dx;\r\n+            if (E >= 0) {\r\n+                x1 += sx;\r\n+                E -= 2 * dy;\r\n+            }\r\n+            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n+                vTaskDelay(1); // Yield to other tasks\r\n+            }\r\n+        }\r\n     }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 1); // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n-    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n-    spi_bus_config_t buscfg = {\r\n-        .mosi_io_num = GPIO_MOSI,\r\n-        .miso_io_num = -1,\r\n-        .sclk_io_num = GPIO_SCLK,\r\n-        .quadwp_io_num = -1,\r\n-        .quadhd_io_num = -1,\r\n-        .max_transfer_sz = 0,\r\n-        .flags = 0\r\n-    };\r\n-\r\n-    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n-    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    spi_device_interface_config_t devcfg;\r\n-    memset(&devcfg, 0, sizeof(devcfg));\r\n-    devcfg.clock_speed_hz = SPI_Frequency;\r\n-    devcfg.queue_size = 7;\r\n-    devcfg.mode = 2;\r\n-    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n-\r\n-    if (GPIO_CS >= 0) {\r\n-        devcfg.spics_io_num = GPIO_CS;\r\n-    } else {\r\n-        devcfg.spics_io_num = -1;\r\n-    }\r\n-\r\n-    spi_device_handle_t handle;\r\n-    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n-    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    dev->_dc = GPIO_DC;\r\n-    dev->_bl = GPIO_BL;\r\n-    dev->_SPIHandle = handle;\r\n }\r\n \r\n \r\n-bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n-{\r\n-\tspi_transaction_t SPITransaction;\r\n-\tesp_err_t ret;\r\n-\r\n-\tif ( DataLength > 0 ) {\r\n-\t\tmemset( &SPITransaction, 0, sizeof( spi_transaction_t ) );\r\n-\t\tSPITransaction.length = DataLength * 8;\r\n-\t\tSPITransaction.tx_buffer = Data;\r\n-#if 1\r\n-\t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n-#else\r\n-\t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n-#endif\r\n-\t\tassert(ret==ESP_OK); \r\n-\t}\r\n-\r\n-\treturn true;\r\n-}\r\n-\r\n-bool spi_master_write_command(TFT_t * dev, uint8_t cmd)\r\n-{\r\n-\tstatic uint8_t Byte = 0;\r\n-\tByte = cmd;\r\n-\tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n-}\r\n-\r\n-bool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n-{\r\n-\tstatic uint8_t Byte = 0;\r\n-\tByte = data;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n-}\r\n-\r\n-\r\n-bool spi_master_write_data_word(TFT_t * dev, uint16_t data)\r\n-{\r\n-\tstatic uint8_t Byte[2];\r\n-\tByte[0] = (data >> 8) & 0xFF;\r\n-\tByte[1] = data & 0xFF;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n-}\r\n-\r\n-bool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n-{\r\n-\tstatic uint8_t Byte[4];\r\n-\tByte[0] = (addr1 >> 8) & 0xFF;\r\n-\tByte[1] = addr1 & 0xFF;\r\n-\tByte[2] = (addr2 >> 8) & 0xFF;\r\n-\tByte[3] = addr2 & 0xFF;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n-}\r\n-\r\n-bool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n-{\r\n-\tstatic uint8_t Byte[1024];\r\n-\tint index = 0;\r\n-\tfor(int i=0;i<size;i++) {\r\n-\t\tByte[index++] = (color >> 8) & 0xFF;\r\n-\t\tByte[index++] = color & 0xFF;\r\n-\t}\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n-}\r\n-\r\n-// Add 202001\r\n-bool spi_master_write_colors(TFT_t * dev, uint16_t * colors, uint16_t size)\r\n-{\r\n-\tstatic uint8_t Byte[1024];\r\n-\tint index = 0;\r\n-\tfor(int i=0;i<size;i++) {\r\n-\t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n-\t\tByte[index++] = colors[i] & 0xFF;\r\n-\t}\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n-}\r\n-\r\n-void delayMS(int ms) {\r\n-\tint _ms = ms + (portTICK_PERIOD_MS - 1);\r\n-\tTickType_t xTicksToDelay = _ms / portTICK_PERIOD_MS;\r\n-\tESP_LOGD(TAG, \"ms=%d _ms=%d portTICK_PERIOD_MS=%\"PRIu32\" xTicksToDelay=%\"PRIu32,ms,_ms,portTICK_PERIOD_MS,xTicksToDelay);\r\n-\tvTaskDelay(xTicksToDelay);\r\n-}\r\n-\r\n-\r\n-void lcdInit(TFT_t * dev, int width, int height, int offsetx, int offsety)\r\n-{\r\n-\tdev->_width = width;\r\n-\tdev->_height = height;\r\n-\tdev->_offsetx = offsetx;\r\n-\tdev->_offsety = offsety;\r\n-\tdev->_font_direction = DIRECTION0;\r\n-\tdev->_font_fill = false;\r\n-\tdev->_font_underline = false;\r\n-\r\n-\tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n-\tdelayMS(150);\r\n-\r\n-\tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n-\tdelayMS(255);\r\n-\t\r\n-\tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n-\tspi_master_write_data_byte(dev, 0x55);\r\n-\tdelayMS(10);\r\n-\t\r\n-\tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\r\n-\tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n-\r\n-\tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n-\r\n-\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n-\tdelayMS(10);\r\n-\r\n-\tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n-\tdelayMS(10);\r\n-\r\n-\tspi_master_write_command(dev, 0x29);\t//Display ON\r\n-\tdelayMS(255);\r\n-\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 1 );\r\n-\t}\r\n-}\r\n-\r\n-\r\n-// Draw pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// color:color\r\n-void lcdDrawPixel(TFT_t * dev, uint16_t x, uint16_t y, uint16_t color){\r\n-\tif (x >= dev->_width) return;\r\n-\tif (y >= dev->_height) return;\r\n-\r\n-\tuint16_t _x = x + dev->_offsetx;\r\n-\tuint16_t _y = y + dev->_offsety;\r\n-\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x, _x);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y, _y);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tspi_master_write_data_word(dev, color);\r\n-}\r\n-\r\n-\r\n-// Draw multi pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// size:Number of colors\r\n-// colors:colors\r\n-void lcdDrawMultiPixels(TFT_t * dev, uint16_t x, uint16_t y, uint16_t size, uint16_t * colors) {\r\n-\tif (x+size > dev->_width) return;\r\n-\tif (y >= dev->_height) return;\r\n-\r\n-\tuint16_t _x1 = x + dev->_offsetx;\r\n-\tuint16_t _x2 = _x1 + (size-1);\r\n-\tuint16_t _y1 = y + dev->_offsety;\r\n-\tuint16_t _y2 = _y1;\r\n-\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x1, _x2);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y1, _y2);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tspi_master_write_colors(dev, colors, size);\r\n-}\r\n-\r\n-// Draw rectangle of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End X coordinate\r\n-// y2:End Y coordinate\r\n-// color:color\r\n-void lcdDrawFillRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tif (x1 >= dev->_width) return;\r\n-\tif (x2 >= dev->_width) x2=dev->_width-1;\r\n-\tif (y1 >= dev->_height) return;\r\n-\tif (y2 >= dev->_height) y2=dev->_height-1;\r\n-\r\n-\tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n-\tuint16_t _x1 = x1 + dev->_offsetx;\r\n-\tuint16_t _x2 = x2 + dev->_offsetx;\r\n-\tuint16_t _y1 = y1 + dev->_offsety;\r\n-\tuint16_t _y2 = y2 + dev->_offsety;\r\n-\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x1, _x2);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y1, _y2);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tfor(int i=_x1;i<=_x2;i++){\r\n-\t\tuint16_t size = _y2-_y1+1;\r\n-\t\tspi_master_write_color(dev, color, size);\r\n-#if 0\r\n-\t\tfor(j=y1;j<=y2;j++){\r\n-\t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n-\t\t\tspi_master_write_data_word(dev, color);\r\n-\t\t}\r\n-#endif\r\n-\t}\r\n-}\r\n-\r\n-// Display OFF\r\n-void lcdDisplayOff(TFT_t * dev) {\r\n-\tspi_master_write_command(dev, 0x28);\t//Display off\r\n-}\r\n- \r\n-// Display ON\r\n-void lcdDisplayOn(TFT_t * dev) {\r\n-\tspi_master_write_command(dev, 0x29);\t//Display on\r\n-}\r\n-\r\n-// Fill screen\r\n-// color:color\r\n-void lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n-\tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n-}\r\n-\r\n-// Draw line\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color \r\n-void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tint i;\r\n-\tint dx,dy;\r\n-\tint sx,sy;\r\n-\tint E;\r\n-\r\n-\t/* distance between two points */\r\n-\tdx = ( x2 > x1 ) ? x2 - x1 : x1 - x2;\r\n-\tdy = ( y2 > y1 ) ? y2 - y1 : y1 - y2;\r\n-\r\n-\t/* direction of two point */\r\n-\tsx = ( x2 > x1 ) ? 1 : -1;\r\n-\tsy = ( y2 > y1 ) ? 1 : -1;\r\n-\r\n-\t/* inclination < 1 */\r\n-\tif ( dx > dy ) {\r\n-\t\tE = -dx;\r\n-\t\tfor ( i = 0 ; i <= dx ; i++ ) {\r\n-\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n-\t\t\tx1 += sx;\r\n-\t\t\tE += 2 * dy;\r\n-\t\t\tif ( E >= 0 ) {\r\n-\t\t\ty1 += sy;\r\n-\t\t\tE -= 2 * dx;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\t/* inclination >= 1 */\r\n-\t} else {\r\n-\t\tE = -dy;\r\n-\t\tfor ( i = 0 ; i <= dy ; i++ ) {\r\n-\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n-\t\t\ty1 += sy;\r\n-\t\t\tE += 2 * dx;\r\n-\t\t\tif ( E >= 0 ) {\r\n-\t\t\t\tx1 += sx;\r\n-\t\t\t\tE -= 2 * dy;\r\n-\t\t\t}\r\n-\t\t}\r\n-\t}\r\n-}\r\n-\r\n // Draw rectangle\r\n // x1:Start X coordinate\r\n // y1:Start Y coordinate\r\n // x2:End   X coordinate\r\n"
                },
                {
                    "date": 1731805996446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,8 +129,9 @@\n \t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n #else\r\n \t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n #endif\r\n+\t\tESP_LOGD(TAG, \"spi_device_transmit returned %d\", ret);\r\n \t\tassert(ret==ESP_OK); \r\n \t}\r\n \r\n \treturn true;\r\n@@ -140,16 +141,18 @@\n {\r\n \tstatic uint8_t Byte = 0;\r\n \tByte = cmd;\r\n \tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Command: 0x%02X\", cmd);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n }\r\n \r\n bool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n {\r\n \tstatic uint8_t Byte = 0;\r\n \tByte = data;\r\n \tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Data Byte: 0x%02X\", data);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n }\r\n \r\n \r\n@@ -158,8 +161,9 @@\n \tstatic uint8_t Byte[2];\r\n \tByte[0] = (data >> 8) & 0xFF;\r\n \tByte[1] = data & 0xFF;\r\n \tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Data Word: 0x%04X\", data);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n }\r\n \r\n bool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n@@ -169,8 +173,9 @@\n \tByte[1] = addr1 & 0xFF;\r\n \tByte[2] = (addr2 >> 8) & 0xFF;\r\n \tByte[3] = addr2 & 0xFF;\r\n \tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Addr: 0x%04X, 0x%04X\", addr1, addr2);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n }\r\n \r\n bool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n@@ -181,8 +186,9 @@\n \t\tByte[index++] = (color >> 8) & 0xFF;\r\n \t\tByte[index++] = color & 0xFF;\r\n \t}\r\n \tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Color: 0x%04X, Size: %d\", color, size);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n }\r\n \r\n // Add 202001\r\n@@ -194,8 +200,9 @@\n \t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n \t\tByte[index++] = colors[i] & 0xFF;\r\n \t}\r\n \tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Colors: Size: %d\", size);\r\n \treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n }\r\n \r\n void delayMS(int ms) {\r\n@@ -215,44 +222,50 @@\n \tdev->_font_direction = DIRECTION0;\r\n \tdev->_font_fill = false;\r\n \tdev->_font_underline = false;\r\n \r\n+\tESP_LOGI(TAG, \"Initializing LCD\");\r\n+\r\n+\tESP_LOGI(TAG, \"Sending Software Reset\");\r\n \tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n \tdelayMS(150);\r\n \r\n+\tESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n \tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n \tdelayMS(255);\r\n \t\r\n+\tESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n \tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n \tspi_master_write_data_byte(dev, 0x55);\r\n \tdelayMS(10);\r\n \t\r\n+\tESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n \tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n \tspi_master_write_data_byte(dev, 0x00);\r\n \r\n+\tESP_LOGI(TAG, \"Setting Column Address Set\");\r\n \tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n+\tspi_master_write_addr(dev, 0x0000, 0x00F0);\r\n \r\n+\tESP_LOGI(TAG, \"Setting Row Address Set\");\r\n \tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n+\tspi_master_write_addr(dev, 0x0000, 0x00F0);\r\n \r\n+\tESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n \tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n \tdelayMS(10);\r\n \r\n+\tESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n \tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n \tdelayMS(10);\r\n \r\n+\tESP_LOGI(TAG, \"Turning Display On\");\r\n \tspi_master_write_command(dev, 0x29);\t//Display ON\r\n \tdelayMS(255);\r\n \r\n \tif(dev->_bl >= 0) {\r\n \t\tgpio_set_level( dev->_bl, 1 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n \t}\r\n }\r\n \r\n \r\n@@ -266,8 +279,9 @@\n \r\n \tuint16_t _x = x + dev->_offsetx;\r\n \tuint16_t _y = y + dev->_offsety;\r\n \r\n+\tESP_LOGD(TAG, \"lcdDrawPixel: x=%d y=%d color=0x%04X\", _x, _y, color);\r\n \tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n \tspi_master_write_addr(dev, _x, _x);\r\n \tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n \tspi_master_write_addr(dev, _y, _y);\r\n@@ -289,8 +303,9 @@\n \tuint16_t _x2 = _x1 + (size-1);\r\n \tuint16_t _y1 = y + dev->_offsety;\r\n \tuint16_t _y2 = _y1;\r\n \r\n+\tESP_LOGD(TAG, \"lcdDrawMultiPixels: x=%d y=%d size=%d\", _x1, _y1, size);\r\n \tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n \tspi_master_write_addr(dev, _x1, _x2);\r\n \tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n \tspi_master_write_addr(dev, _y1, _y2);\r\n@@ -309,8 +324,9 @@\n \tif (x2 >= dev->_width) x2=dev->_width-1;\r\n \tif (y1 >= dev->_height) return;\r\n \tif (y2 >= dev->_height) y2=dev->_height-1;\r\n \r\n+\tESP_LOGD(TAG,\"lcdDrawFillRect: x1=%d y1=%d x2=%d y2=%d color=0x%04X\",x1, y1, x2, y2, color);\r\n \tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n \tuint16_t _x1 = x1 + dev->_offsetx;\r\n \tuint16_t _x2 = x2 + dev->_offsetx;\r\n \tuint16_t _y1 = y1 + dev->_offsety;\r\n@@ -322,8 +338,9 @@\n \tspi_master_write_addr(dev, _y1, _y2);\r\n \tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n \tfor(int i=_x1;i<=_x2;i++){\r\n \t\tuint16_t size = _y2-_y1+1;\r\n+\t\tESP_LOGD(TAG, \"lcdDrawFillRect: Writing color=0x%04X size=%d at x=%d\", color, size, i);\r\n \t\tspi_master_write_color(dev, color, size);\r\n #if 0\r\n \t\tfor(j=y1;j<=y2;j++){\r\n \t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n@@ -334,19 +351,22 @@\n }\r\n \r\n // Display OFF\r\n void lcdDisplayOff(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Off\");\r\n \tspi_master_write_command(dev, 0x28);\t//Display off\r\n }\r\n- \r\n+\r\n // Display ON\r\n void lcdDisplayOn(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display On\");\r\n \tspi_master_write_command(dev, 0x29);\t//Display on\r\n }\r\n \r\n // Fill screen\r\n // color:color\r\n void lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGI(TAG, \"Filling screen with color=0x%04X\", color);\r\n \tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n }\r\n \r\n // Draw line\r\n@@ -355,8 +375,9 @@\n // x2:End   X coordinate\r\n // y2:End   Y coordinate\r\n // color:color \r\n void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    ESP_LOGD(TAG, \"Drawing line from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n     int i;\r\n     int dx, dy;\r\n     int sx, sy;\r\n     int E;\r\n@@ -410,8 +431,9 @@\n // x2:End   X coordinate\r\n // y2:End   Y coordinate\r\n // color:color\r\n void lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rectangle from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n \tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n \tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n \tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n \tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n@@ -428,8 +450,9 @@\n //When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n // x1 = x * cos(angle) - y * sin(angle)\r\n // y1 = x * sin(angle) + y * cos(angle)\r\n void lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rotated rectangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n \tdouble xd,yd,rd;\r\n \tint x1,y1;\r\n \tint x2,y2;\r\n \tint x3,y3;\r\n@@ -470,8 +493,9 @@\n //When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n // x1 = x * cos(angle) - y * sin(angle)\r\n // y1 = x * sin(angle) + y * cos(angle)\r\n void lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rotated triangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n \tdouble xd,yd,rd;\r\n \tint x1,y1;\r\n \tint x2,y2;\r\n \tint x3,y3;\r\n@@ -500,8 +524,9 @@\n // y0:Central Y coordinate\r\n // r:radius\r\n // color:color\r\n void lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n \tint x;\r\n \tint y;\r\n \tint err;\r\n \tint old_err;\r\n@@ -524,8 +549,9 @@\n // y0:Central Y coordinate\r\n // r:radius\r\n // color:color\r\n void lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing filled circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n \tint x;\r\n \tint y;\r\n \tint err;\r\n \tint old_err;\r\n@@ -535,12 +561,14 @@\n \ty=-r;\r\n \terr=2-2*r;\r\n \tChangeX=1;\r\n \tdo{\r\n-\t\tif(ChangeX) {\r\n-\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n-\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n-\t\t} // endif\r\n+\t\tif(x) {\r\n+\t\t\tlcdDrawPixel(dev, x0+r-x, y0+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x0+x, y0+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x0+r-x, y0+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x0+x, y0+y, color);\r\n+\t\t} // endif \r\n \t\tChangeX=(old_err=err)<=x;\r\n \t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n \t\tif (old_err>y || err>x) err+=++y*2+1;\r\n \t} while(y<=0);\r\n@@ -553,8 +581,9 @@\n // y2:End   Y coordinate\r\n // r:radius\r\n // color:color\r\n void lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rounded rectangle: x1=%d y1=%d x2=%d y2=%d r=%d color=0x%04X\",x1, y1, x2, y2, r, color);\r\n \tint x;\r\n \tint y;\r\n \tint err;\r\n \tint old_err;\r\n@@ -587,12 +616,12 @@\n \t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n \t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n \t} while(y<0);\r\n \r\n-\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n+\tESP_LOGD(TAG, \"Drawing horizontal lines for rounded rectangle\");\r\n \tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n \tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n-\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n+\tESP_LOGD(TAG, \"Drawing vertical lines for rounded rectangle\");\r\n \tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n \tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n } \r\n \r\n@@ -604,8 +633,9 @@\n // w:Width of the botom\r\n // color:color\r\n // Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n void lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n \tdouble Vx= x1 - x0;\r\n \tdouble Vy= y1 - y0;\r\n \tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n \t//\t printf(\"v=%f\\n\",v);\r\n@@ -633,8 +663,9 @@\n // y2:End   Y coordinate\r\n // w:Width of the botom\r\n // color:color\r\n void lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing filled arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n \tdouble Vx= x1 - x0;\r\n \tdouble Vy= y1 - y0;\r\n \tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n \t//printf(\"v=%f\\n\",v);\r\n@@ -700,11 +731,11 @@\n \tint16_t xsd = 0;\r\n \tint16_t ysd = 0;\r\n \tint16_t next = 0;\r\n \tuint16_t x0  = 0;\r\n-\tuint16_t x1  = 0;\r\n+\tuint16_t x1_val  = 0;\r\n \tuint16_t y0  = 0;\r\n-\tuint16_t y1  = 0;\r\n+\tuint16_t y1_val  = 0;\r\n \tif (dev->_font_direction == 0) {\r\n \t\txd1 = +1;\r\n \t\tyd1 = +1; //-1;\r\n \t\txd2 =  0;\r\n@@ -716,10 +747,10 @@\n \t\tnext = x + pw;\r\n \r\n \t\tx0\t= x;\r\n \t\ty0\t= y - (ph-1);\r\n-\t\tx1\t= x + (pw-1);\r\n-\t\ty1\t= y;\r\n+\t\tx1_val\t= x + (pw-1);\r\n+\t\ty1_val\t= y;\r\n \t} else if (dev->_font_direction == 2) {\r\n \t\txd1 = -1;\r\n \t\tyd1 = -1; //+1;\r\n \t\txd2 =  0;\r\n@@ -731,10 +762,10 @@\n \t\tnext = x - pw;\r\n \r\n \t\tx0\t= x - (pw-1);\r\n \t\ty0\t= y;\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y + (ph-1);\r\n+\t\tx1_val\t= x;\r\n+\t\ty1_val\t= y + (ph-1);\r\n \t} else if (dev->_font_direction == 1) {\r\n \t\txd1 =  0;\r\n \t\tyd1 =  0;\r\n \t\txd2 = -1;\r\n@@ -746,10 +777,10 @@\n \t\tnext = y + pw; //y - pw;\r\n \r\n \t\tx0\t= x;\r\n \t\ty0\t= y;\r\n-\t\tx1\t= x + (ph-1);\r\n-\t\ty1\t= y + (pw-1);\r\n+\t\tx1_val\t= x + (ph-1);\r\n+\t\ty1_val\t= y + (pw-1);\r\n \t} else if (dev->_font_direction == 3) {\r\n \t\txd1 =  0;\r\n \t\tyd1 =  0;\r\n \t\txd2 = +1;\r\n@@ -761,13 +792,16 @@\n \t\tnext = y - pw; //y + pw;\r\n \r\n \t\tx0\t= x - (ph-1);\r\n \t\ty0\t= y - (pw-1);\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y;\r\n+\t\tx1_val\t= x;\r\n+\t\ty1_val\t= y;\r\n \t}\r\n \r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\tif (dev->_font_fill) {\r\n+\t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\t\tlcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\t}\r\n \r\n \tint bits;\r\n \tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n \tofs = 0;\r\n@@ -793,9 +827,9 @@\n \t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n \t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n \t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n \t\t\t\txx = xx + xd1;\r\n-\t\t\t\tyy = yy + yd2;\r\n+\t\t\t\tyy = yy + ysd;\r\n \t\t\t\tmask = mask >> 1;\r\n \t\t\t}\r\n \t\t\tofs++;\r\n \t\t}\r\n@@ -809,8 +843,9 @@\n \r\n int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n \tint length = strlen((char *)ascii);\r\n \tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n \tfor(int i=0;i<length;i++) {\r\n \t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n \t\tif (dev->_font_direction == 0)\r\n \t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n@@ -834,9 +869,9 @@\n // y:Y coordinate\r\n // code:character code\r\n // color:color\r\n int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n-\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n+\tESP_LOGD(TAG, \"Drawing code: 0x%02X at x=%d y=%d color=0x%04X\", code, x, y, color);\r\n \tif (dev->_font_direction == 0)\r\n \t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n \tif (dev->_font_direction == 1)\r\n \t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n@@ -876,8 +911,9 @@\n \tint spos;\r\n \tuint16_t sjis[64];\r\n \tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n \tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n+\tESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n \tfor(i=0;i<spos;i++) {\r\n \t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n \t\tif (dev->_font_direction == 0)\r\n \t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n@@ -898,54 +934,63 @@\n \r\n // Set font direction\r\n // dir:Direction\r\n void lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n+\tESP_LOGD(TAG, \"Setting font direction to %d\", dir);\r\n \tdev->_font_direction = dir;\r\n }\r\n \r\n // Set font filling\r\n // color:fill color\r\n void lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Enabling font fill with color=0x%04X\", color);\r\n \tdev->_font_fill = true;\r\n \tdev->_font_fill_color = color;\r\n }\r\n \r\n // UnSet font filling\r\n void lcdUnsetFontFill(TFT_t * dev) {\r\n+\tESP_LOGD(TAG, \"Disabling font fill\");\r\n \tdev->_font_fill = false;\r\n }\r\n \r\n // Set font underline\r\n // color:frame color\r\n void lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Enabling font underline with color=0x%04X\", color);\r\n \tdev->_font_underline = true;\r\n \tdev->_font_underline_color = color;\r\n }\r\n \r\n // UnSet font underline\r\n void lcdUnsetFontUnderLine(TFT_t * dev) {\r\n+\tESP_LOGD(TAG, \"Disabling font underline\");\r\n \tdev->_font_underline = false;\r\n }\r\n \r\n // Backlight OFF\r\n void lcdBacklightOff(TFT_t * dev) {\r\n \tif(dev->_bl >= 0) {\r\n \t\tgpio_set_level( dev->_bl, 0 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned off\");\r\n \t}\r\n }\r\n \r\n // Backlight ON\r\n void lcdBacklightOn(TFT_t * dev) {\r\n \tif(dev->_bl >= 0) {\r\n \t\tgpio_set_level( dev->_bl, 1 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned on\");\r\n \t}\r\n }\r\n \r\n // Display Inversion Off\r\n void lcdInversionOff(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Inversion Off\");\r\n \tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n }\r\n \r\n // Display Inversion On\r\n void lcdInversionOn(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Inversion On\");\r\n \tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n }\r\n"
                },
                {
                    "date": 1731806374250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,9 +243,12 @@\n \tspi_master_write_data_byte(dev, 0x00);\r\n \r\n \tESP_LOGI(TAG, \"Setting Column Address Set\");\r\n \tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n-\tspi_master_write_addr(dev, 0x0000, 0x00F0);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n \r\n \tESP_LOGI(TAG, \"Setting Row Address Set\");\r\n \tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n \tspi_master_write_addr(dev, 0x0000, 0x00F0);\r\n"
                },
                {
                    "date": 1731806383541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -250,9 +250,12 @@\n \tspi_master_write_data_byte(dev, 0xF0);\r\n \r\n \tESP_LOGI(TAG, \"Setting Row Address Set\");\r\n \tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n-\tspi_master_write_addr(dev, 0x0000, 0x00F0);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n \r\n \tESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n \tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n \tdelayMS(10);\r\n@@ -564,14 +567,12 @@\n \ty=-r;\r\n \terr=2-2*r;\r\n \tChangeX=1;\r\n \tdo{\r\n-\t\tif(x) {\r\n-\t\t\tlcdDrawPixel(dev, x0+r-x, y0+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x0+x, y0+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x0+r-x, y0+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x0+x, y0+y, color);\r\n-\t\t} // endif \r\n+\t\tif(ChangeX) {\r\n+\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n+\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n+\t\t} // endif\r\n \t\tChangeX=(old_err=err)<=x;\r\n \t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n \t\tif (old_err>y || err>x) err+=++y*2+1;\r\n \t} while(y<=0);\r\n"
                },
                {
                    "date": 1731806393296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -621,8 +621,9 @@\n \t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n \t} while(y<0);\r\n \r\n \tESP_LOGD(TAG, \"Drawing horizontal lines for rounded rectangle\");\r\n+\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n \tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n \tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n \tESP_LOGD(TAG, \"Drawing vertical lines for rounded rectangle\");\r\n \tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n"
                },
                {
                    "date": 1731806398765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -625,8 +625,9 @@\n \tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n \tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n \tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n \tESP_LOGD(TAG, \"Drawing vertical lines for rounded rectangle\");\r\n+\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n \tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n \tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n } \r\n \r\n"
                },
                {
                    "date": 1731806405336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -737,11 +737,11 @@\n \tint16_t xsd = 0;\r\n \tint16_t ysd = 0;\r\n \tint16_t next = 0;\r\n \tuint16_t x0  = 0;\r\n-\tuint16_t x1_val  = 0;\r\n+\tuint16_t x1  = 0;\r\n \tuint16_t y0  = 0;\r\n-\tuint16_t y1_val  = 0;\r\n+\tuint16_t y1  = 0;\r\n \tif (dev->_font_direction == 0) {\r\n \t\txd1 = +1;\r\n \t\tyd1 = +1; //-1;\r\n \t\txd2 =  0;\r\n@@ -753,10 +753,10 @@\n \t\tnext = x + pw;\r\n \r\n \t\tx0\t= x;\r\n \t\ty0\t= y - (ph-1);\r\n-\t\tx1_val\t= x + (pw-1);\r\n-\t\ty1_val\t= y;\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n \t} else if (dev->_font_direction == 2) {\r\n \t\txd1 = -1;\r\n \t\tyd1 = -1; //+1;\r\n \t\txd2 =  0;\r\n"
                },
                {
                    "date": 1731806410718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1002 @@\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+#include <math.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+\r\n+#include <driver/spi_master.h>\r\n+#include <driver/gpio.h>\r\n+#include \"esp_log.h\"\r\n+\r\n+#include \"st7789.h\"\r\n+\r\n+#define TAG \"ST7789\"\r\n+#define\t_DEBUG_ 0\r\n+\r\n+#if 0\r\n+#ifdef CONFIG_IDF_TARGET_ESP32\r\n+#define LCD_HOST HSPI_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32S2\r\n+#define LCD_HOST SPI2_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32S3\r\n+#define LCD_HOST SPI2_HOST\r\n+#elif defined CONFIG_IDF_TARGET_ESP32C3\r\n+#define LCD_HOST SPI2_HOST\r\n+#endif\r\n+#endif\r\n+\r\n+#if CONFIG_SPI2_HOST\r\n+#define HOST_ID SPI2_HOST\r\n+#elif CONFIG_SPI3_HOST\r\n+#define HOST_ID SPI3_HOST\r\n+#endif\r\n+\r\n+static const int SPI_Command_Mode = 0;\r\n+static const int SPI_Data_Mode = 1;\r\n+static const int SPI_Frequency = SPI_MASTER_FREQ_20M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_26M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n+//static const int SPI_Frequency = SPI_MASTER_FREQ_80M;\r\n+\r\n+\r\n+void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n+{\r\n+    esp_err_t ret;\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n+    if (GPIO_CS >= 0) {\r\n+        gpio_reset_pin(GPIO_CS);\r\n+        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_CS, 0);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n+    gpio_reset_pin(GPIO_DC);\r\n+    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n+    gpio_set_level(GPIO_DC, 0);\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n+    if (GPIO_RESET >= 0) {\r\n+        gpio_reset_pin(GPIO_RESET);\r\n+        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n+        delayMS(100);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 0); // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n+    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n+    spi_bus_config_t buscfg = {\r\n+        .mosi_io_num = GPIO_MOSI,\r\n+        .miso_io_num = -1,\r\n+        .sclk_io_num = GPIO_SCLK,\r\n+        .quadwp_io_num = -1,\r\n+        .quadhd_io_num = -1,\r\n+        .max_transfer_sz = 0,\r\n+        .flags = 0\r\n+    };\r\n+\r\n+    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n+    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    spi_device_interface_config_t devcfg;\r\n+    memset(&devcfg, 0, sizeof(devcfg));\r\n+    devcfg.clock_speed_hz = SPI_Frequency;\r\n+    devcfg.queue_size = 7;\r\n+    devcfg.mode = 2;\r\n+    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+\r\n+    if (GPIO_CS >= 0) {\r\n+        devcfg.spics_io_num = GPIO_CS;\r\n+    } else {\r\n+        devcfg.spics_io_num = -1;\r\n+    }\r\n+\r\n+    spi_device_handle_t handle;\r\n+    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n+    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    dev->_dc = GPIO_DC;\r\n+    dev->_bl = GPIO_BL;\r\n+    dev->_SPIHandle = handle;\r\n+}\r\n+\r\n+\r\n+bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n+{\r\n+\tspi_transaction_t SPITransaction;\r\n+\tesp_err_t ret;\r\n+\r\n+\tif ( DataLength > 0 ) {\r\n+\t\tmemset( &SPITransaction, 0, sizeof( spi_transaction_t ) );\r\n+\t\tSPITransaction.length = DataLength * 8;\r\n+\t\tSPITransaction.tx_buffer = Data;\r\n+#if 1\r\n+\t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n+#else\r\n+\t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n+#endif\r\n+\t\tESP_LOGD(TAG, \"spi_device_transmit returned %d\", ret);\r\n+\t\tassert(ret==ESP_OK); \r\n+\t}\r\n+\r\n+\treturn true;\r\n+}\r\n+\r\n+bool spi_master_write_command(TFT_t * dev, uint8_t cmd)\r\n+{\r\n+\tstatic uint8_t Byte = 0;\r\n+\tByte = cmd;\r\n+\tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Command: 0x%02X\", cmd);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n+}\r\n+\r\n+bool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n+{\r\n+\tstatic uint8_t Byte = 0;\r\n+\tByte = data;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Data Byte: 0x%02X\", data);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n+}\r\n+\r\n+\r\n+bool spi_master_write_data_word(TFT_t * dev, uint16_t data)\r\n+{\r\n+\tstatic uint8_t Byte[2];\r\n+\tByte[0] = (data >> 8) & 0xFF;\r\n+\tByte[1] = data & 0xFF;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Data Word: 0x%04X\", data);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n+}\r\n+\r\n+bool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n+{\r\n+\tstatic uint8_t Byte[4];\r\n+\tByte[0] = (addr1 >> 8) & 0xFF;\r\n+\tByte[1] = addr1 & 0xFF;\r\n+\tByte[2] = (addr2 >> 8) & 0xFF;\r\n+\tByte[3] = addr2 & 0xFF;\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Addr: 0x%04X, 0x%04X\", addr1, addr2);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n+}\r\n+\r\n+bool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n+{\r\n+\tstatic uint8_t Byte[1024];\r\n+\tint index = 0;\r\n+\tfor(int i=0;i<size;i++) {\r\n+\t\tByte[index++] = (color >> 8) & 0xFF;\r\n+\t\tByte[index++] = color & 0xFF;\r\n+\t}\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Color: 0x%04X, Size: %d\", color, size);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n+}\r\n+\r\n+// Add 202001\r\n+bool spi_master_write_colors(TFT_t * dev, uint16_t * colors, uint16_t size)\r\n+{\r\n+\tstatic uint8_t Byte[1024];\r\n+\tint index = 0;\r\n+\tfor(int i=0;i<size;i++) {\r\n+\t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n+\t\tByte[index++] = colors[i] & 0xFF;\r\n+\t}\r\n+\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n+\tESP_LOGD(TAG, \"SPI Write Colors: Size: %d\", size);\r\n+\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n+}\r\n+\r\n+void delayMS(int ms) {\r\n+\tint _ms = ms + (portTICK_PERIOD_MS - 1);\r\n+\tTickType_t xTicksToDelay = _ms / portTICK_PERIOD_MS;\r\n+\tESP_LOGD(TAG, \"ms=%d _ms=%d portTICK_PERIOD_MS=%\"PRIu32\" xTicksToDelay=%\"PRIu32,ms,_ms,portTICK_PERIOD_MS,xTicksToDelay);\r\n+\tvTaskDelay(xTicksToDelay);\r\n+}\r\n+\r\n+\r\n+void lcdInit(TFT_t * dev, int width, int height, int offsetx, int offsety)\r\n+{\r\n+\tdev->_width = width;\r\n+\tdev->_height = height;\r\n+\tdev->_offsetx = offsetx;\r\n+\tdev->_offsety = offsety;\r\n+\tdev->_font_direction = DIRECTION0;\r\n+\tdev->_font_fill = false;\r\n+\tdev->_font_underline = false;\r\n+\r\n+\tESP_LOGI(TAG, \"Initializing LCD\");\r\n+\r\n+\tESP_LOGI(TAG, \"Sending Software Reset\");\r\n+\tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n+\tdelayMS(150);\r\n+\r\n+\tESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n+\tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n+\tdelayMS(255);\r\n+\t\r\n+\tESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n+\tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n+\tspi_master_write_data_byte(dev, 0x55);\r\n+\tdelayMS(10);\r\n+\t\r\n+\tESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n+\tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\r\n+\tESP_LOGI(TAG, \"Setting Column Address Set\");\r\n+\tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n+\r\n+\tESP_LOGI(TAG, \"Setting Row Address Set\");\r\n+\tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0x00);\r\n+\tspi_master_write_data_byte(dev, 0xF0);\r\n+\r\n+\tESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n+\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n+\tdelayMS(10);\r\n+\r\n+\tESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n+\tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n+\tdelayMS(10);\r\n+\r\n+\tESP_LOGI(TAG, \"Turning Display On\");\r\n+\tspi_master_write_command(dev, 0x29);\t//Display ON\r\n+\tdelayMS(255);\r\n+\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 1 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n+\t}\r\n+}\r\n+\r\n+\r\n+// Draw pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// color:color\r\n+void lcdDrawPixel(TFT_t * dev, uint16_t x, uint16_t y, uint16_t color){\r\n+\tif (x >= dev->_width) return;\r\n+\tif (y >= dev->_height) return;\r\n+\r\n+\tuint16_t _x = x + dev->_offsetx;\r\n+\tuint16_t _y = y + dev->_offsety;\r\n+\r\n+\tESP_LOGD(TAG, \"lcdDrawPixel: x=%d y=%d color=0x%04X\", _x, _y, color);\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x, _x);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y, _y);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tspi_master_write_data_word(dev, color);\r\n+}\r\n+\r\n+\r\n+// Draw multi pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// size:Number of colors\r\n+// colors:colors\r\n+void lcdDrawMultiPixels(TFT_t * dev, uint16_t x, uint16_t y, uint16_t size, uint16_t * colors) {\r\n+\tif (x+size > dev->_width) return;\r\n+\tif (y >= dev->_height) return;\r\n+\r\n+\tuint16_t _x1 = x + dev->_offsetx;\r\n+\tuint16_t _x2 = _x1 + (size-1);\r\n+\tuint16_t _y1 = y + dev->_offsety;\r\n+\tuint16_t _y2 = _y1;\r\n+\r\n+\tESP_LOGD(TAG, \"lcdDrawMultiPixels: x=%d y=%d size=%d\", _x1, _y1, size);\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x1, _x2);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y1, _y2);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tspi_master_write_colors(dev, colors, size);\r\n+}\r\n+\r\n+// Draw rectangle of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End X coordinate\r\n+// y2:End Y coordinate\r\n+// color:color\r\n+void lcdDrawFillRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tif (x1 >= dev->_width) return;\r\n+\tif (x2 >= dev->_width) x2=dev->_width-1;\r\n+\tif (y1 >= dev->_height) return;\r\n+\tif (y2 >= dev->_height) y2=dev->_height-1;\r\n+\r\n+\tESP_LOGD(TAG,\"lcdDrawFillRect: x1=%d y1=%d x2=%d y2=%d color=0x%04X\",x1, y1, x2, y2, color);\r\n+\tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n+\tuint16_t _x1 = x1 + dev->_offsetx;\r\n+\tuint16_t _x2 = x2 + dev->_offsetx;\r\n+\tuint16_t _y1 = y1 + dev->_offsety;\r\n+\tuint16_t _y2 = y2 + dev->_offsety;\r\n+\r\n+\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n+\tspi_master_write_addr(dev, _x1, _x2);\r\n+\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n+\tspi_master_write_addr(dev, _y1, _y2);\r\n+\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n+\tfor(int i=_x1;i<=_x2;i++){\r\n+\t\tuint16_t size = _y2-_y1+1;\r\n+\t\tESP_LOGD(TAG, \"lcdDrawFillRect: Writing color=0x%04X size=%d at x=%d\", color, size, i);\r\n+\t\tspi_master_write_color(dev, color, size);\r\n+#if 0\r\n+\t\tfor(j=y1;j<=y2;j++){\r\n+\t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n+\t\t\tspi_master_write_data_word(dev, color);\r\n+\t\t}\r\n+#endif\r\n+\t}\r\n+}\r\n+\r\n+// Display OFF\r\n+void lcdDisplayOff(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Off\");\r\n+\tspi_master_write_command(dev, 0x28);\t//Display off\r\n+}\r\n+\r\n+// Display ON\r\n+void lcdDisplayOn(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display On\");\r\n+\tspi_master_write_command(dev, 0x29);\t//Display on\r\n+}\r\n+\r\n+// Fill screen\r\n+// color:color\r\n+void lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGI(TAG, \"Filling screen with color=0x%04X\", color);\r\n+\tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n+}\r\n+\r\n+// Draw line\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color \r\n+void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    ESP_LOGD(TAG, \"Drawing line from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n+    int i;\r\n+    int dx, dy;\r\n+    int sx, sy;\r\n+    int E;\r\n+\r\n+    /* distance between two points */\r\n+    dx = (x2 > x1) ? x2 - x1 : x1 - x2;\r\n+    dy = (y2 > y1) ? y2 - y1 : y1 - y2;\r\n+\r\n+    /* direction of two points */\r\n+    sx = (x2 > x1) ? 1 : -1;\r\n+    sy = (y2 > y1) ? 1 : -1;\r\n+\r\n+    /* inclination < 1 */\r\n+    if (dx > dy) {\r\n+        E = -dx;\r\n+        for (i = 0; i <= dx; i++) {\r\n+            lcdDrawPixel(dev, x1, y1, color);\r\n+            x1 += sx;\r\n+            E += 2 * dy;\r\n+            if (E >= 0) {\r\n+                y1 += sy;\r\n+                E -= 2 * dx;\r\n+            }\r\n+            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n+                vTaskDelay(1); // Yield to other tasks\r\n+            }\r\n+        }\r\n+    }\r\n+    /* inclination >= 1 */\r\n+    else {\r\n+        E = -dy;\r\n+        for (i = 0; i <= dy; i++) {\r\n+            lcdDrawPixel(dev, x1, y1, color);\r\n+            y1 += sy;\r\n+            E += 2 * dx;\r\n+            if (E >= 0) {\r\n+                x1 += sx;\r\n+                E -= 2 * dy;\r\n+            }\r\n+            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n+                vTaskDelay(1); // Yield to other tasks\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+\r\n+// Draw rectangle\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rectangle from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n+\tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n+\tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n+}\r\n+\r\n+// Draw rectangle with angle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of rectangle\r\n+// h:Height of rectangle\r\n+// angle:Angle of rectangle\r\n+// color:color\r\n+\r\n+//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rotated rectangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n+\tdouble xd,yd,rd;\r\n+\tint x1,y1;\r\n+\tint x2,y2;\r\n+\tint x3,y3;\r\n+\tint x4,y4;\r\n+\trd = -angle * M_PI / 180.0;\r\n+\txd = 0.0 - w/2;\r\n+\tyd = h/2;\r\n+\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tyd = 0.0 - yd;\r\n+\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = w/2;\r\n+\tyd = h/2;\r\n+\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tyd = 0.0 - yd;\r\n+\tx4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+\tlcdDrawLine(dev, x2, y2, x4, y4, color);\r\n+\tlcdDrawLine(dev, x3, y3, x4, y4, color);\r\n+}\r\n+\r\n+// Draw triangle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of triangle\r\n+// h:Height of triangle\r\n+// angle:Angle of triangle\r\n+// color:color\r\n+\r\n+//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rotated triangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n+\tdouble xd,yd,rd;\r\n+\tint x1,y1;\r\n+\tint x2,y2;\r\n+\tint x3,y3;\r\n+\trd = -angle * M_PI / 180.0;\r\n+\txd = 0.0;\r\n+\tyd = h/2;\r\n+\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = w/2;\r\n+\tyd = 0.0 - yd;\r\n+\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\txd = 0.0 - w/2;\r\n+\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+\tlcdDrawLine(dev, x2, y2, x3, y3, color);\r\n+}\r\n+\r\n+// Draw circle\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\tdo{\r\n+\t\tlcdDrawPixel(dev, x0-x, y0+y, color); \r\n+\t\tlcdDrawPixel(dev, x0-y, y0-x, color); \r\n+\t\tlcdDrawPixel(dev, x0+x, y0-y, color); \r\n+\t\tlcdDrawPixel(dev, x0+y, y0+x, color); \r\n+\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n+\t} while(y<0);\r\n+}\r\n+\r\n+// Draw circle of filling\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing filled circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\tint ChangeX;\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\tChangeX=1;\r\n+\tdo{\r\n+\t\tif(ChangeX) {\r\n+\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n+\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n+\t\t} // endif\r\n+\t\tChangeX=(old_err=err)<=x;\r\n+\t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\r\n+\t} while(y<=0);\r\n+} \r\n+\r\n+// Draw rectangle with round corner\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing rounded rectangle: x1=%d y1=%d x2=%d y2=%d r=%d color=0x%04X\",x1, y1, x2, y2, r, color);\r\n+\tint x;\r\n+\tint y;\r\n+\tint err;\r\n+\tint old_err;\r\n+\tunsigned char temp;\r\n+\r\n+\tif(x1>x2) {\r\n+\t\ttemp=x1; x1=x2; x2=temp;\r\n+\t} // endif\r\n+\t  \r\n+\tif(y1>y2) {\r\n+\t\ttemp=y1; y1=y2; y2=temp;\r\n+\t} // endif\r\n+\r\n+\tESP_LOGD(TAG, \"x1=%d x2=%d delta=%d r=%d\",x1, x2, x2-x1, r);\r\n+\tESP_LOGD(TAG, \"y1=%d y2=%d delta=%d r=%d\",y1, y2, y2-y1, r);\r\n+\tif (x2-x1 < r) return; // Add 20190517\r\n+\tif (y2-y1 < r) return; // Add 20190517\r\n+\r\n+\tx=0;\r\n+\ty=-r;\r\n+\terr=2-2*r;\r\n+\r\n+\tdo{\r\n+\t\tif(x) {\r\n+\t\t\tlcdDrawPixel(dev, x1+r-x, y1+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x2-r+x, y1+r+y, color); \r\n+\t\t\tlcdDrawPixel(dev, x1+r-x, y2-r-y, color); \r\n+\t\t\tlcdDrawPixel(dev, x2-r+x, y2-r-y, color);\r\n+\t\t} // endif \r\n+\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n+\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n+\t} while(y<0);\r\n+\r\n+\tESP_LOGD(TAG, \"Drawing horizontal lines for rounded rectangle\");\r\n+\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n+\tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n+\tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n+\tESP_LOGD(TAG, \"Drawing vertical lines for rounded rectangle\");\r\n+\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n+\tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n+\tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n+} \r\n+\r\n+// Draw arrow\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the botom\r\n+// color:color\r\n+// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n+void lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n+\tdouble Vx= x1 - x0;\r\n+\tdouble Vy= y1 - y0;\r\n+\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n+\t//\t printf(\"v=%f\\n\",v);\r\n+\tdouble Ux= Vx/v;\r\n+\tdouble Uy= Vy/v;\r\n+\r\n+\tuint16_t L[2],R[2];\r\n+\tL[0]= x1 - Uy*w - Ux*v;\r\n+\tL[1]= y1 + Ux*w - Uy*v;\r\n+\tR[0]= x1 + Uy*w - Ux*v;\r\n+\tR[1]= y1 - Ux*w - Uy*v;\r\n+\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\r\n+\t//lcdDrawLine(x0,y0,x1,y1,color);\r\n+\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+}\r\n+\r\n+\r\n+// Draw arrow of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the botom\r\n+// color:color\r\n+void lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing filled arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n+\tdouble Vx= x1 - x0;\r\n+\tdouble Vy= y1 - y0;\r\n+\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n+\t//printf(\"v=%f\\n\",v);\r\n+\tdouble Ux= Vx/v;\r\n+\tdouble Uy= Vy/v;\r\n+\r\n+\tuint16_t L[2],R[2];\r\n+\tL[0]= x1 - Uy*w - Ux*v;\r\n+\tL[1]= y1 + Ux*w - Uy*v;\r\n+\tR[0]= x1 + Uy*w - Ux*v;\r\n+\tR[1]= y1 - Ux*w - Uy*v;\r\n+\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\r\n+\tlcdDrawLine(dev, x0, y0, x1, y1, color);\r\n+\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+\r\n+\tint ww;\r\n+\tfor(ww=w-1;ww>0;ww--) {\r\n+\t\tL[0]= x1 - Uy*ww - Ux*v;\r\n+\t\tL[1]= y1 + Ux*ww - Uy*v;\r\n+\t\tR[0]= x1 + Uy*ww - Ux*v;\r\n+\t\tR[1]= y1 - Ux*ww - Uy*v;\r\n+\t\t//printf(\"Fill>L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n+\t\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+\t\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+\t}\r\n+}\r\n+\r\n+\r\n+// RGB565 conversion\r\n+// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n+// Bit image \"RRRRRGGGGGGBBBBB\"\r\n+uint16_t rgb565_conv(uint16_t r,uint16_t g,uint16_t b) {\r\n+\treturn (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n+}\r\n+\r\n+// Draw ASCII character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// ascii: ascii code\r\n+// color:color\r\n+int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n+\tuint16_t xx,yy,bit,ofs;\r\n+\tunsigned char fonts[128]; // font pattern\r\n+\tunsigned char pw, ph;\r\n+\tint h,w;\r\n+\tuint16_t mask;\r\n+\tbool rc;\r\n+\r\n+\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n+\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n+\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n+\tif (!rc) return 0;\r\n+\r\n+\tint16_t xd1 = 0;\r\n+\tint16_t yd1 = 0;\r\n+\tint16_t xd2 = 0;\r\n+\tint16_t yd2 = 0;\r\n+\tuint16_t xss = 0;\r\n+\tuint16_t yss = 0;\r\n+\tint16_t xsd = 0;\r\n+\tint16_t ysd = 0;\r\n+\tint16_t next = 0;\r\n+\tuint16_t x0  = 0;\r\n+\tuint16_t x1  = 0;\r\n+\tuint16_t y0  = 0;\r\n+\tuint16_t y1  = 0;\r\n+\tif (dev->_font_direction == 0) {\r\n+\t\txd1 = +1;\r\n+\t\tyd1 = +1; //-1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y - (ph - 1);\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x + pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y - (ph-1);\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n+\t} else if (dev->_font_direction == 2) {\r\n+\t\txd1 = -1;\r\n+\t\tyd1 = -1; //+1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y + ph + 1;\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x - pw;\r\n+\r\n+\t\tx0\t= x - (pw-1);\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y + (ph-1);\r\n+\t} else if (dev->_font_direction == 1) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = -1;\r\n+\t\tyd2 = +1; //-1;\r\n+\t\txss =  x + ph;\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y + pw; //y - pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x + (ph-1);\r\n+\t\ty1\t= y + (pw-1);\r\n+\t} else if (dev->_font_direction == 3) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = +1;\r\n+\t\tyd2 = -1; //+1;\r\n+\t\txss =  x - (ph - 1);\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y - pw; //y + pw;\r\n+\r\n+\t\tx0\t= x - (ph-1);\r\n+\t\ty0\t= y - (pw-1);\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y;\r\n+\t}\r\n+\r\n+\tif (dev->_font_fill) {\r\n+\t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\t\tlcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\t}\r\n+\r\n+\tint bits;\r\n+\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n+\tofs = 0;\r\n+\tyy = yss;\r\n+\txx = xss;\r\n+\tfor(h=0;h<ph;h++) {\r\n+\t\tif(xsd) xx = xss;\r\n+\t\tif(ysd) yy = yss;\r\n+\t\t//for(w=0;w<(pw/8);w++) {\r\n+\t\tbits = pw;\r\n+\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n+\t\t\tmask = 0x80;\r\n+\t\t\tfor(bit=0;bit<8;bit++) {\r\n+\t\t\t\tbits--;\r\n+\t\t\t\tif (bits < 0) continue;\r\n+\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n+\t\t\t\tif (fonts[ofs] & mask) {\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\txx = xx + xd1;\r\n+\t\t\t\tyy = yy + ysd;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t}\r\n+\t\t\tofs++;\r\n+\t\t}\r\n+\t\tyy = yy + yd1;\r\n+\t\txx = xx + xd2;\r\n+\t}\r\n+\r\n+\tif (next < 0) next = 0;\r\n+\treturn next;\r\n+}\r\n+\r\n+int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n+\tint length = strlen((char *)ascii);\r\n+\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n+\tfor(int i=0;i<length;i++) {\r\n+\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+\r\n+// Draw Non-Alphanumeric character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// code:character code\r\n+// color:color\r\n+int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Drawing code: 0x%02X at x=%d y=%d color=0x%04X\", code, x, y, color);\r\n+\tif (dev->_font_direction == 0)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 1)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 2)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 3)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+#if 0\r\n+// Draw UTF8 character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utf8:UTF8 code\r\n+// color:color\r\n+int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n+\tuint16_t sjis[1];\r\n+\r\n+\tsjis[0] = UTF2SJIS(utf8);\r\n+\tif(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n+\treturn lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n+}\r\n+\r\n+// Draw UTF8 string\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utfs:UTF8 string\r\n+// color:color\r\n+int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n+\r\n+\tint i;\r\n+\tint spos;\r\n+\tuint16_t sjis[64];\r\n+\tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n+\tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n+\tESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n+\tfor(i=0;i<spos;i++) {\r\n+\t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+#endif\r\n+\r\n+// Set font direction\r\n+// dir:Direction\r\n+void lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n+\tESP_LOGD(TAG, \"Setting font direction to %d\", dir);\r\n+\tdev->_font_direction = dir;\r\n+}\r\n+\r\n+// Set font filling\r\n+// color:fill color\r\n+void lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Enabling font fill with color=0x%04X\", color);\r\n+\tdev->_font_fill = true;\r\n+\tdev->_font_fill_color = color;\r\n+}\r\n+\r\n+// UnSet font filling\r\n+void lcdUnsetFontFill(TFT_t * dev) {\r\n+\tESP_LOGD(TAG, \"Disabling font fill\");\r\n+\tdev->_font_fill = false;\r\n+}\r\n+\r\n+// Set font underline\r\n+// color:frame color\r\n+void lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n+\tESP_LOGD(TAG, \"Enabling font underline with color=0x%04X\", color);\r\n+\tdev->_font_underline = true;\r\n+\tdev->_font_underline_color = color;\r\n+}\r\n+\r\n+// UnSet font underline\r\n+void lcdUnsetFontUnderLine(TFT_t * dev) {\r\n+\tESP_LOGD(TAG, \"Disabling font underline\");\r\n+\tdev->_font_underline = false;\r\n+}\r\n+\r\n+// Backlight OFF\r\n+void lcdBacklightOff(TFT_t * dev) {\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 0 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned off\");\r\n+\t}\r\n+}\r\n+\r\n+// Backlight ON\r\n+void lcdBacklightOn(TFT_t * dev) {\r\n+\tif(dev->_bl >= 0) {\r\n+\t\tgpio_set_level( dev->_bl, 1 );\r\n+\t\tESP_LOGI(TAG, \"Backlight turned on\");\r\n+\t}\r\n+}\r\n+\r\n+// Display Inversion Off\r\n+void lcdInversionOff(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Inversion Off\");\r\n+\tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n+}\r\n+\r\n+// Display Inversion On\r\n+void lcdInversionOn(TFT_t * dev) {\r\n+\tESP_LOGI(TAG, \"Turning Display Inversion On\");\r\n+\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n+}\r\n"
                },
                {
                    "date": 1731806420349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -802,11 +802,9 @@\n \t\tx1\t= x;\r\n \t\ty1\t= y;\r\n \t}\r\n \r\n-\tif (dev->_font_fill) {\r\n-\t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n-\t\tlcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n \t}\r\n \r\n \tint bits;\r\n \tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n@@ -999,1006 +997,4 @@\n void lcdInversionOn(TFT_t * dev) {\r\n \tESP_LOGI(TAG, \"Turning Display Inversion On\");\r\n \tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n }\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-#include <math.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-\r\n-#include <driver/spi_master.h>\r\n-#include <driver/gpio.h>\r\n-#include \"esp_log.h\"\r\n-\r\n-#include \"st7789.h\"\r\n-\r\n-#define TAG \"ST7789\"\r\n-#define\t_DEBUG_ 0\r\n-\r\n-#if 0\r\n-#ifdef CONFIG_IDF_TARGET_ESP32\r\n-#define LCD_HOST HSPI_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32S2\r\n-#define LCD_HOST SPI2_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32S3\r\n-#define LCD_HOST SPI2_HOST\r\n-#elif defined CONFIG_IDF_TARGET_ESP32C3\r\n-#define LCD_HOST SPI2_HOST\r\n-#endif\r\n-#endif\r\n-\r\n-#if CONFIG_SPI2_HOST\r\n-#define HOST_ID SPI2_HOST\r\n-#elif CONFIG_SPI3_HOST\r\n-#define HOST_ID SPI3_HOST\r\n-#endif\r\n-\r\n-static const int SPI_Command_Mode = 0;\r\n-static const int SPI_Data_Mode = 1;\r\n-static const int SPI_Frequency = SPI_MASTER_FREQ_20M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_26M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n-//static const int SPI_Frequency = SPI_MASTER_FREQ_80M;\r\n-\r\n-\r\n-void spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n-{\r\n-    esp_err_t ret;\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n-    if (GPIO_CS >= 0) {\r\n-        gpio_reset_pin(GPIO_CS);\r\n-        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_CS, 0);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n-    gpio_reset_pin(GPIO_DC);\r\n-    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n-    gpio_set_level(GPIO_DC, 0);\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n-    if (GPIO_RESET >= 0) {\r\n-        gpio_reset_pin(GPIO_RESET);\r\n-        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n-        delayMS(100);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 0); // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n-    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n-    spi_bus_config_t buscfg = {\r\n-        .mosi_io_num = GPIO_MOSI,\r\n-        .miso_io_num = -1,\r\n-        .sclk_io_num = GPIO_SCLK,\r\n-        .quadwp_io_num = -1,\r\n-        .quadhd_io_num = -1,\r\n-        .max_transfer_sz = 0,\r\n-        .flags = 0\r\n-    };\r\n-\r\n-    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n-    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    spi_device_interface_config_t devcfg;\r\n-    memset(&devcfg, 0, sizeof(devcfg));\r\n-    devcfg.clock_speed_hz = SPI_Frequency;\r\n-    devcfg.queue_size = 7;\r\n-    devcfg.mode = 2;\r\n-    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n-\r\n-    if (GPIO_CS >= 0) {\r\n-        devcfg.spics_io_num = GPIO_CS;\r\n-    } else {\r\n-        devcfg.spics_io_num = -1;\r\n-    }\r\n-\r\n-    spi_device_handle_t handle;\r\n-    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n-    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    dev->_dc = GPIO_DC;\r\n-    dev->_bl = GPIO_BL;\r\n-    dev->_SPIHandle = handle;\r\n-}\r\n-\r\n-\r\n-bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n-{\r\n-\tspi_transaction_t SPITransaction;\r\n-\tesp_err_t ret;\r\n-\r\n-\tif ( DataLength > 0 ) {\r\n-\t\tmemset( &SPITransaction, 0, sizeof( spi_transaction_t ) );\r\n-\t\tSPITransaction.length = DataLength * 8;\r\n-\t\tSPITransaction.tx_buffer = Data;\r\n-#if 1\r\n-\t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n-#else\r\n-\t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n-#endif\r\n-\t\tESP_LOGD(TAG, \"spi_device_transmit returned %d\", ret);\r\n-\t\tassert(ret==ESP_OK); \r\n-\t}\r\n-\r\n-\treturn true;\r\n-}\r\n-\r\n-bool spi_master_write_command(TFT_t * dev, uint8_t cmd)\r\n-{\r\n-\tstatic uint8_t Byte = 0;\r\n-\tByte = cmd;\r\n-\tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Command: 0x%02X\", cmd);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n-}\r\n-\r\n-bool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n-{\r\n-\tstatic uint8_t Byte = 0;\r\n-\tByte = data;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Data Byte: 0x%02X\", data);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n-}\r\n-\r\n-\r\n-bool spi_master_write_data_word(TFT_t * dev, uint16_t data)\r\n-{\r\n-\tstatic uint8_t Byte[2];\r\n-\tByte[0] = (data >> 8) & 0xFF;\r\n-\tByte[1] = data & 0xFF;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Data Word: 0x%04X\", data);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n-}\r\n-\r\n-bool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n-{\r\n-\tstatic uint8_t Byte[4];\r\n-\tByte[0] = (addr1 >> 8) & 0xFF;\r\n-\tByte[1] = addr1 & 0xFF;\r\n-\tByte[2] = (addr2 >> 8) & 0xFF;\r\n-\tByte[3] = addr2 & 0xFF;\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Addr: 0x%04X, 0x%04X\", addr1, addr2);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n-}\r\n-\r\n-bool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n-{\r\n-\tstatic uint8_t Byte[1024];\r\n-\tint index = 0;\r\n-\tfor(int i=0;i<size;i++) {\r\n-\t\tByte[index++] = (color >> 8) & 0xFF;\r\n-\t\tByte[index++] = color & 0xFF;\r\n-\t}\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Color: 0x%04X, Size: %d\", color, size);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n-}\r\n-\r\n-// Add 202001\r\n-bool spi_master_write_colors(TFT_t * dev, uint16_t * colors, uint16_t size)\r\n-{\r\n-\tstatic uint8_t Byte[1024];\r\n-\tint index = 0;\r\n-\tfor(int i=0;i<size;i++) {\r\n-\t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n-\t\tByte[index++] = colors[i] & 0xFF;\r\n-\t}\r\n-\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n-\tESP_LOGD(TAG, \"SPI Write Colors: Size: %d\", size);\r\n-\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n-}\r\n-\r\n-void delayMS(int ms) {\r\n-\tint _ms = ms + (portTICK_PERIOD_MS - 1);\r\n-\tTickType_t xTicksToDelay = _ms / portTICK_PERIOD_MS;\r\n-\tESP_LOGD(TAG, \"ms=%d _ms=%d portTICK_PERIOD_MS=%\"PRIu32\" xTicksToDelay=%\"PRIu32,ms,_ms,portTICK_PERIOD_MS,xTicksToDelay);\r\n-\tvTaskDelay(xTicksToDelay);\r\n-}\r\n-\r\n-\r\n-void lcdInit(TFT_t * dev, int width, int height, int offsetx, int offsety)\r\n-{\r\n-\tdev->_width = width;\r\n-\tdev->_height = height;\r\n-\tdev->_offsetx = offsetx;\r\n-\tdev->_offsety = offsety;\r\n-\tdev->_font_direction = DIRECTION0;\r\n-\tdev->_font_fill = false;\r\n-\tdev->_font_underline = false;\r\n-\r\n-\tESP_LOGI(TAG, \"Initializing LCD\");\r\n-\r\n-\tESP_LOGI(TAG, \"Sending Software Reset\");\r\n-\tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n-\tdelayMS(150);\r\n-\r\n-\tESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n-\tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n-\tdelayMS(255);\r\n-\t\r\n-\tESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n-\tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n-\tspi_master_write_data_byte(dev, 0x55);\r\n-\tdelayMS(10);\r\n-\t\r\n-\tESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n-\tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\r\n-\tESP_LOGI(TAG, \"Setting Column Address Set\");\r\n-\tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n-\r\n-\tESP_LOGI(TAG, \"Setting Row Address Set\");\r\n-\tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0x00);\r\n-\tspi_master_write_data_byte(dev, 0xF0);\r\n-\r\n-\tESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n-\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n-\tdelayMS(10);\r\n-\r\n-\tESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n-\tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n-\tdelayMS(10);\r\n-\r\n-\tESP_LOGI(TAG, \"Turning Display On\");\r\n-\tspi_master_write_command(dev, 0x29);\t//Display ON\r\n-\tdelayMS(255);\r\n-\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 1 );\r\n-\t\tESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n-\t}\r\n-}\r\n-\r\n-\r\n-// Draw pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// color:color\r\n-void lcdDrawPixel(TFT_t * dev, uint16_t x, uint16_t y, uint16_t color){\r\n-\tif (x >= dev->_width) return;\r\n-\tif (y >= dev->_height) return;\r\n-\r\n-\tuint16_t _x = x + dev->_offsetx;\r\n-\tuint16_t _y = y + dev->_offsety;\r\n-\r\n-\tESP_LOGD(TAG, \"lcdDrawPixel: x=%d y=%d color=0x%04X\", _x, _y, color);\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x, _x);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y, _y);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tspi_master_write_data_word(dev, color);\r\n-}\r\n-\r\n-\r\n-// Draw multi pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// size:Number of colors\r\n-// colors:colors\r\n-void lcdDrawMultiPixels(TFT_t * dev, uint16_t x, uint16_t y, uint16_t size, uint16_t * colors) {\r\n-\tif (x+size > dev->_width) return;\r\n-\tif (y >= dev->_height) return;\r\n-\r\n-\tuint16_t _x1 = x + dev->_offsetx;\r\n-\tuint16_t _x2 = _x1 + (size-1);\r\n-\tuint16_t _y1 = y + dev->_offsety;\r\n-\tuint16_t _y2 = _y1;\r\n-\r\n-\tESP_LOGD(TAG, \"lcdDrawMultiPixels: x=%d y=%d size=%d\", _x1, _y1, size);\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x1, _x2);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y1, _y2);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tspi_master_write_colors(dev, colors, size);\r\n-}\r\n-\r\n-// Draw rectangle of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End X coordinate\r\n-// y2:End Y coordinate\r\n-// color:color\r\n-void lcdDrawFillRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tif (x1 >= dev->_width) return;\r\n-\tif (x2 >= dev->_width) x2=dev->_width-1;\r\n-\tif (y1 >= dev->_height) return;\r\n-\tif (y2 >= dev->_height) y2=dev->_height-1;\r\n-\r\n-\tESP_LOGD(TAG,\"lcdDrawFillRect: x1=%d y1=%d x2=%d y2=%d color=0x%04X\",x1, y1, x2, y2, color);\r\n-\tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n-\tuint16_t _x1 = x1 + dev->_offsetx;\r\n-\tuint16_t _x2 = x2 + dev->_offsetx;\r\n-\tuint16_t _y1 = y1 + dev->_offsety;\r\n-\tuint16_t _y2 = y2 + dev->_offsety;\r\n-\r\n-\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n-\tspi_master_write_addr(dev, _x1, _x2);\r\n-\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n-\tspi_master_write_addr(dev, _y1, _y2);\r\n-\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n-\tfor(int i=_x1;i<=_x2;i++){\r\n-\t\tuint16_t size = _y2-_y1+1;\r\n-\t\tESP_LOGD(TAG, \"lcdDrawFillRect: Writing color=0x%04X size=%d at x=%d\", color, size, i);\r\n-\t\tspi_master_write_color(dev, color, size);\r\n-#if 0\r\n-\t\tfor(j=y1;j<=y2;j++){\r\n-\t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n-\t\t\tspi_master_write_data_word(dev, color);\r\n-\t\t}\r\n-#endif\r\n-\t}\r\n-}\r\n-\r\n-// Display OFF\r\n-void lcdDisplayOff(TFT_t * dev) {\r\n-\tESP_LOGI(TAG, \"Turning Display Off\");\r\n-\tspi_master_write_command(dev, 0x28);\t//Display off\r\n-}\r\n-\r\n-// Display ON\r\n-void lcdDisplayOn(TFT_t * dev) {\r\n-\tESP_LOGI(TAG, \"Turning Display On\");\r\n-\tspi_master_write_command(dev, 0x29);\t//Display on\r\n-}\r\n-\r\n-// Fill screen\r\n-// color:color\r\n-void lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n-\tESP_LOGI(TAG, \"Filling screen with color=0x%04X\", color);\r\n-\tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n-}\r\n-\r\n-// Draw line\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color \r\n-void lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    ESP_LOGD(TAG, \"Drawing line from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n-    int i;\r\n-    int dx, dy;\r\n-    int sx, sy;\r\n-    int E;\r\n-\r\n-    /* distance between two points */\r\n-    dx = (x2 > x1) ? x2 - x1 : x1 - x2;\r\n-    dy = (y2 > y1) ? y2 - y1 : y1 - y2;\r\n-\r\n-    /* direction of two points */\r\n-    sx = (x2 > x1) ? 1 : -1;\r\n-    sy = (y2 > y1) ? 1 : -1;\r\n-\r\n-    /* inclination < 1 */\r\n-    if (dx > dy) {\r\n-        E = -dx;\r\n-        for (i = 0; i <= dx; i++) {\r\n-            lcdDrawPixel(dev, x1, y1, color);\r\n-            x1 += sx;\r\n-            E += 2 * dy;\r\n-            if (E >= 0) {\r\n-                y1 += sy;\r\n-                E -= 2 * dx;\r\n-            }\r\n-            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n-                vTaskDelay(1); // Yield to other tasks\r\n-            }\r\n-        }\r\n-    }\r\n-    /* inclination >= 1 */\r\n-    else {\r\n-        E = -dy;\r\n-        for (i = 0; i <= dy; i++) {\r\n-            lcdDrawPixel(dev, x1, y1, color);\r\n-            y1 += sy;\r\n-            E += 2 * dx;\r\n-            if (E >= 0) {\r\n-                x1 += sx;\r\n-                E -= 2 * dy;\r\n-            }\r\n-            if (i % 50 == 0) { // Adjust the modulo value as needed\r\n-                vTaskDelay(1); // Yield to other tasks\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-\r\n-// Draw rectangle\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing rectangle from (%d, %d) to (%d, %d) with color=0x%04X\", x1, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n-\tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n-\tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n-}\r\n-\r\n-// Draw rectangle with angle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of rectangle\r\n-// h:Height of rectangle\r\n-// angle:Angle of rectangle\r\n-// color:color\r\n-\r\n-//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing rotated rectangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n-\tdouble xd,yd,rd;\r\n-\tint x1,y1;\r\n-\tint x2,y2;\r\n-\tint x3,y3;\r\n-\tint x4,y4;\r\n-\trd = -angle * M_PI / 180.0;\r\n-\txd = 0.0 - w/2;\r\n-\tyd = h/2;\r\n-\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tyd = 0.0 - yd;\r\n-\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = w/2;\r\n-\tyd = h/2;\r\n-\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tyd = 0.0 - yd;\r\n-\tx4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-\tlcdDrawLine(dev, x2, y2, x4, y4, color);\r\n-\tlcdDrawLine(dev, x3, y3, x4, y4, color);\r\n-}\r\n-\r\n-// Draw triangle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of triangle\r\n-// h:Height of triangle\r\n-// angle:Angle of triangle\r\n-// color:color\r\n-\r\n-//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing rotated triangle: xc=%d yc=%d w=%d h=%d angle=%d color=0x%04X\", xc, yc, w, h, angle, color);\r\n-\tdouble xd,yd,rd;\r\n-\tint x1,y1;\r\n-\tint x2,y2;\r\n-\tint x3,y3;\r\n-\trd = -angle * M_PI / 180.0;\r\n-\txd = 0.0;\r\n-\tyd = h/2;\r\n-\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = w/2;\r\n-\tyd = 0.0 - yd;\r\n-\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\txd = 0.0 - w/2;\r\n-\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-\tlcdDrawLine(dev, x2, y2, x3, y3, color);\r\n-}\r\n-\r\n-// Draw circle\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\tdo{\r\n-\t\tlcdDrawPixel(dev, x0-x, y0+y, color); \r\n-\t\tlcdDrawPixel(dev, x0-y, y0-x, color); \r\n-\t\tlcdDrawPixel(dev, x0+x, y0-y, color); \r\n-\t\tlcdDrawPixel(dev, x0+y, y0+x, color); \r\n-\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n-\t} while(y<0);\r\n-}\r\n-\r\n-// Draw circle of filling\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing filled circle: x0=%d y0=%d r=%d color=0x%04X\", x0, y0, r, color);\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\tint ChangeX;\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\tChangeX=1;\r\n-\tdo{\r\n-\t\tif(ChangeX) {\r\n-\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n-\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n-\t\t} // endif\r\n-\t\tChangeX=(old_err=err)<=x;\r\n-\t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\r\n-\t} while(y<=0);\r\n-} \r\n-\r\n-// Draw rectangle with round corner\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing rounded rectangle: x1=%d y1=%d x2=%d y2=%d r=%d color=0x%04X\",x1, y1, x2, y2, r, color);\r\n-\tint x;\r\n-\tint y;\r\n-\tint err;\r\n-\tint old_err;\r\n-\tunsigned char temp;\r\n-\r\n-\tif(x1>x2) {\r\n-\t\ttemp=x1; x1=x2; x2=temp;\r\n-\t} // endif\r\n-\t  \r\n-\tif(y1>y2) {\r\n-\t\ttemp=y1; y1=y2; y2=temp;\r\n-\t} // endif\r\n-\r\n-\tESP_LOGD(TAG, \"x1=%d x2=%d delta=%d r=%d\",x1, x2, x2-x1, r);\r\n-\tESP_LOGD(TAG, \"y1=%d y2=%d delta=%d r=%d\",y1, y2, y2-y1, r);\r\n-\tif (x2-x1 < r) return; // Add 20190517\r\n-\tif (y2-y1 < r) return; // Add 20190517\r\n-\r\n-\tx=0;\r\n-\ty=-r;\r\n-\terr=2-2*r;\r\n-\r\n-\tdo{\r\n-\t\tif(x) {\r\n-\t\t\tlcdDrawPixel(dev, x1+r-x, y1+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x2-r+x, y1+r+y, color); \r\n-\t\t\tlcdDrawPixel(dev, x1+r-x, y2-r-y, color); \r\n-\t\t\tlcdDrawPixel(dev, x2-r+x, y2-r-y, color);\r\n-\t\t} // endif \r\n-\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n-\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n-\t} while(y<0);\r\n-\r\n-\tESP_LOGD(TAG, \"Drawing horizontal lines for rounded rectangle\");\r\n-\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n-\tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n-\tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n-\tESP_LOGD(TAG, \"Drawing vertical lines for rounded rectangle\");\r\n-\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n-\tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n-\tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n-} \r\n-\r\n-// Draw arrow\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the botom\r\n-// color:color\r\n-// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n-void lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n-\tdouble Vx= x1 - x0;\r\n-\tdouble Vy= y1 - y0;\r\n-\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n-\t//\t printf(\"v=%f\\n\",v);\r\n-\tdouble Ux= Vx/v;\r\n-\tdouble Uy= Vy/v;\r\n-\r\n-\tuint16_t L[2],R[2];\r\n-\tL[0]= x1 - Uy*w - Ux*v;\r\n-\tL[1]= y1 + Ux*w - Uy*v;\r\n-\tR[0]= x1 + Uy*w - Ux*v;\r\n-\tR[1]= y1 - Ux*w - Uy*v;\r\n-\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\r\n-\t//lcdDrawLine(x0,y0,x1,y1,color);\r\n-\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-}\r\n-\r\n-\r\n-// Draw arrow of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the botom\r\n-// color:color\r\n-void lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing filled arrow: from=(%d, %d) to=(%d, %d) w=%d color=0x%04X\", x0, y0, x1, y1, w, color);\r\n-\tdouble Vx= x1 - x0;\r\n-\tdouble Vy= y1 - y0;\r\n-\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n-\t//printf(\"v=%f\\n\",v);\r\n-\tdouble Ux= Vx/v;\r\n-\tdouble Uy= Vy/v;\r\n-\r\n-\tuint16_t L[2],R[2];\r\n-\tL[0]= x1 - Uy*w - Ux*v;\r\n-\tL[1]= y1 + Ux*w - Uy*v;\r\n-\tR[0]= x1 + Uy*w - Ux*v;\r\n-\tR[1]= y1 - Ux*w - Uy*v;\r\n-\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\r\n-\tlcdDrawLine(dev, x0, y0, x1, y1, color);\r\n-\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-\r\n-\tint ww;\r\n-\tfor(ww=w-1;ww>0;ww--) {\r\n-\t\tL[0]= x1 - Uy*ww - Ux*v;\r\n-\t\tL[1]= y1 + Ux*ww - Uy*v;\r\n-\t\tR[0]= x1 + Uy*ww - Ux*v;\r\n-\t\tR[1]= y1 - Ux*ww - Uy*v;\r\n-\t\t//printf(\"Fill>L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n-\t\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-\t\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-\t}\r\n-}\r\n-\r\n-\r\n-// RGB565 conversion\r\n-// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n-// Bit image \"RRRRRGGGGGGBBBBB\"\r\n-uint16_t rgb565_conv(uint16_t r,uint16_t g,uint16_t b) {\r\n-\treturn (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n-}\r\n-\r\n-// Draw ASCII character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// ascii: ascii code\r\n-// color:color\r\n-int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n-\tuint16_t xx,yy,bit,ofs;\r\n-\tunsigned char fonts[128]; // font pattern\r\n-\tunsigned char pw, ph;\r\n-\tint h,w;\r\n-\tuint16_t mask;\r\n-\tbool rc;\r\n-\r\n-\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n-\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n-\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n-\tif (!rc) return 0;\r\n-\r\n-\tint16_t xd1 = 0;\r\n-\tint16_t yd1 = 0;\r\n-\tint16_t xd2 = 0;\r\n-\tint16_t yd2 = 0;\r\n-\tuint16_t xss = 0;\r\n-\tuint16_t yss = 0;\r\n-\tint16_t xsd = 0;\r\n-\tint16_t ysd = 0;\r\n-\tint16_t next = 0;\r\n-\tuint16_t x0  = 0;\r\n-\tuint16_t x1  = 0;\r\n-\tuint16_t y0  = 0;\r\n-\tuint16_t y1  = 0;\r\n-\tif (dev->_font_direction == 0) {\r\n-\t\txd1 = +1;\r\n-\t\tyd1 = +1; //-1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y - (ph - 1);\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x + pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y - (ph-1);\r\n-\t\tx1\t= x + (pw-1);\r\n-\t\ty1\t= y;\r\n-\t} else if (dev->_font_direction == 2) {\r\n-\t\txd1 = -1;\r\n-\t\tyd1 = -1; //+1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y + ph + 1;\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x - pw;\r\n-\r\n-\t\tx0\t= x - (pw-1);\r\n-\t\ty0\t= y;\r\n-\t\tx1_val\t= x;\r\n-\t\ty1_val\t= y + (ph-1);\r\n-\t} else if (dev->_font_direction == 1) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = -1;\r\n-\t\tyd2 = +1; //-1;\r\n-\t\txss =  x + ph;\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y + pw; //y - pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y;\r\n-\t\tx1_val\t= x + (ph-1);\r\n-\t\ty1_val\t= y + (pw-1);\r\n-\t} else if (dev->_font_direction == 3) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = +1;\r\n-\t\tyd2 = -1; //+1;\r\n-\t\txss =  x - (ph - 1);\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y - pw; //y + pw;\r\n-\r\n-\t\tx0\t= x - (ph-1);\r\n-\t\ty0\t= y - (pw-1);\r\n-\t\tx1_val\t= x;\r\n-\t\ty1_val\t= y;\r\n-\t}\r\n-\r\n-\tif (dev->_font_fill) {\r\n-\t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n-\t\tlcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n-\t}\r\n-\r\n-\tint bits;\r\n-\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n-\tofs = 0;\r\n-\tyy = yss;\r\n-\txx = xss;\r\n-\tfor(h=0;h<ph;h++) {\r\n-\t\tif(xsd) xx = xss;\r\n-\t\tif(ysd) yy = yss;\r\n-\t\t//for(w=0;w<(pw/8);w++) {\r\n-\t\tbits = pw;\r\n-\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n-\t\t\tmask = 0x80;\r\n-\t\t\tfor(bit=0;bit<8;bit++) {\r\n-\t\t\t\tbits--;\r\n-\t\t\t\tif (bits < 0) continue;\r\n-\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n-\t\t\t\tif (fonts[ofs] & mask) {\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n-\t\t\t\t}\r\n-\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\txx = xx + xd1;\r\n-\t\t\t\tyy = yy + ysd;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t}\r\n-\t\t\tofs++;\r\n-\t\t}\r\n-\t\tyy = yy + yd1;\r\n-\t\txx = xx + xd2;\r\n-\t}\r\n-\r\n-\tif (next < 0) next = 0;\r\n-\treturn next;\r\n-}\r\n-\r\n-int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n-\tint length = strlen((char *)ascii);\r\n-\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n-\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n-\tfor(int i=0;i<length;i++) {\r\n-\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-\r\n-// Draw Non-Alphanumeric character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// code:character code\r\n-// color:color\r\n-int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Drawing code: 0x%02X at x=%d y=%d color=0x%04X\", code, x, y, color);\r\n-\tif (dev->_font_direction == 0)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 1)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 2)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 3)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-#if 0\r\n-// Draw UTF8 character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utf8:UTF8 code\r\n-// color:color\r\n-int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n-\tuint16_t sjis[1];\r\n-\r\n-\tsjis[0] = UTF2SJIS(utf8);\r\n-\tif(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n-\treturn lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n-}\r\n-\r\n-// Draw UTF8 string\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utfs:UTF8 string\r\n-// color:color\r\n-int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n-\r\n-\tint i;\r\n-\tint spos;\r\n-\tuint16_t sjis[64];\r\n-\tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n-\tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n-\tESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n-\tfor(i=0;i<spos;i++) {\r\n-\t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-#endif\r\n-\r\n-// Set font direction\r\n-// dir:Direction\r\n-void lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n-\tESP_LOGD(TAG, \"Setting font direction to %d\", dir);\r\n-\tdev->_font_direction = dir;\r\n-}\r\n-\r\n-// Set font filling\r\n-// color:fill color\r\n-void lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Enabling font fill with color=0x%04X\", color);\r\n-\tdev->_font_fill = true;\r\n-\tdev->_font_fill_color = color;\r\n-}\r\n-\r\n-// UnSet font filling\r\n-void lcdUnsetFontFill(TFT_t * dev) {\r\n-\tESP_LOGD(TAG, \"Disabling font fill\");\r\n-\tdev->_font_fill = false;\r\n-}\r\n-\r\n-// Set font underline\r\n-// color:frame color\r\n-void lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n-\tESP_LOGD(TAG, \"Enabling font underline with color=0x%04X\", color);\r\n-\tdev->_font_underline = true;\r\n-\tdev->_font_underline_color = color;\r\n-}\r\n-\r\n-// UnSet font underline\r\n-void lcdUnsetFontUnderLine(TFT_t * dev) {\r\n-\tESP_LOGD(TAG, \"Disabling font underline\");\r\n-\tdev->_font_underline = false;\r\n-}\r\n-\r\n-// Backlight OFF\r\n-void lcdBacklightOff(TFT_t * dev) {\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 0 );\r\n-\t\tESP_LOGI(TAG, \"Backlight turned off\");\r\n-\t}\r\n-}\r\n-\r\n-// Backlight ON\r\n-void lcdBacklightOn(TFT_t * dev) {\r\n-\tif(dev->_bl >= 0) {\r\n-\t\tgpio_set_level( dev->_bl, 1 );\r\n-\t\tESP_LOGI(TAG, \"Backlight turned on\");\r\n-\t}\r\n-}\r\n-\r\n-// Display Inversion Off\r\n-void lcdInversionOff(TFT_t * dev) {\r\n-\tESP_LOGI(TAG, \"Turning Display Inversion Off\");\r\n-\tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n-}\r\n-\r\n-// Display Inversion On\r\n-void lcdInversionOn(TFT_t * dev) {\r\n-\tESP_LOGI(TAG, \"Turning Display Inversion On\");\r\n-\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n-}\r\n"
                },
                {
                    "date": 1731806425610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -802,10 +802,9 @@\n \t\tx1\t= x;\r\n \t\ty1\t= y;\r\n \t}\r\n \r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n-\t}\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n \r\n \tint bits;\r\n \tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n \tofs = 0;\r\n"
                },
                {
                    "date": 1731806435802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -802,9 +802,9 @@\n \t\tx1\t= x;\r\n \t\ty1\t= y;\r\n \t}\r\n \r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color)\r\n \t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n \r\n \r\n \tint bits;\r\n"
                },
                {
                    "date": 1731806443598,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -803,9 +803,10 @@\n \t\ty1\t= y;\r\n \t}\r\n \r\n \tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n-\t\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n+\t\r\n+\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1_val, y1_val, dev->_font_fill_color);\r\n \r\n \r\n \tint bits;\r\n \tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n"
                }
            ],
            "date": 1731789723592,
            "name": "Commit-0",
            "content": "#include <string.h>\r\n#include <inttypes.h>\r\n#include <math.h>\r\n\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n\r\n#include <driver/spi_master.h>\r\n#include <driver/gpio.h>\r\n#include \"esp_log.h\"\r\n\r\n#include \"st7789.h\"\r\n\r\n#define TAG \"ST7789\"\r\n#define\t_DEBUG_ 0\r\n\r\n#if 0\r\n#ifdef CONFIG_IDF_TARGET_ESP32\r\n#define LCD_HOST HSPI_HOST\r\n#elif defined CONFIG_IDF_TARGET_ESP32S2\r\n#define LCD_HOST SPI2_HOST\r\n#elif defined CONFIG_IDF_TARGET_ESP32S3\r\n#define LCD_HOST SPI2_HOST\r\n#elif defined CONFIG_IDF_TARGET_ESP32C3\r\n#define LCD_HOST SPI2_HOST\r\n#endif\r\n#endif\r\n\r\n#if CONFIG_SPI2_HOST\r\n#define HOST_ID SPI2_HOST\r\n#elif CONFIG_SPI3_HOST\r\n#define HOST_ID SPI3_HOST\r\n#endif\r\n\r\nstatic const int SPI_Command_Mode = 0;\r\nstatic const int SPI_Data_Mode = 1;\r\nstatic const int SPI_Frequency = SPI_MASTER_FREQ_20M;\r\n//static const int SPI_Frequency = SPI_MASTER_FREQ_26M;\r\n//static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n//static const int SPI_Frequency = SPI_MASTER_FREQ_80M;\r\n\r\n\r\nvoid spi_master_init(TFT_t * dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS, int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL)\r\n{\r\n    esp_err_t ret;\r\n\r\n    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n    if (GPIO_CS >= 0) {\r\n        gpio_reset_pin(GPIO_CS);\r\n        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_CS, 0);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n    gpio_reset_pin(GPIO_DC);\r\n    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n    gpio_set_level(GPIO_DC, 0);\r\n\r\n    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n    if (GPIO_RESET >= 0) {\r\n        gpio_reset_pin(GPIO_RESET);\r\n        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_RESET, 1); // Ensure the reset pin starts high\r\n        delayMS(100);\r\n        gpio_set_level(GPIO_RESET, 0); // Pulse reset pin\r\n        delayMS(100);\r\n        gpio_set_level(GPIO_RESET, 1); // Set back to high\r\n        delayMS(100);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n    if (GPIO_BL >= 0) {\r\n        gpio_reset_pin(GPIO_BL);\r\n        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_BL, 1); // Set GPIO_BL high to turn on the backlight\r\n        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n    spi_bus_config_t buscfg = {\r\n        .mosi_io_num = GPIO_MOSI,\r\n        .miso_io_num = -1,\r\n        .sclk_io_num = GPIO_SCLK,\r\n        .quadwp_io_num = -1,\r\n        .quadhd_io_num = -1,\r\n        .max_transfer_sz = 0,\r\n        .flags = 0\r\n    };\r\n\r\n    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n    ESP_LOGD(TAG, \"spi_bus_initialize=%d\", ret);\r\n    assert(ret == ESP_OK);\r\n\r\n    spi_device_interface_config_t devcfg;\r\n    memset(&devcfg, 0, sizeof(devcfg));\r\n    devcfg.clock_speed_hz = SPI_Frequency;\r\n    devcfg.queue_size = 7;\r\n    devcfg.mode = 2;\r\n    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n\r\n    if (GPIO_CS >= 0) {\r\n        devcfg.spics_io_num = GPIO_CS;\r\n    } else {\r\n        devcfg.spics_io_num = -1;\r\n    }\r\n\r\n    spi_device_handle_t handle;\r\n    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n    ESP_LOGD(TAG, \"spi_bus_add_device=%d\", ret);\r\n    assert(ret == ESP_OK);\r\n\r\n    dev->_dc = GPIO_DC;\r\n    dev->_bl = GPIO_BL;\r\n    dev->_SPIHandle = handle;\r\n}\r\n\r\n\r\n\r\nbool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t* Data, size_t DataLength)\r\n{\r\n\tspi_transaction_t SPITransaction;\r\n\tesp_err_t ret;\r\n\r\n\tif ( DataLength > 0 ) {\r\n\t\tmemset( &SPITransaction, 0, sizeof( spi_transaction_t ) );\r\n\t\tSPITransaction.length = DataLength * 8;\r\n\t\tSPITransaction.tx_buffer = Data;\r\n#if 1\r\n\t\tret = spi_device_transmit( SPIHandle, &SPITransaction );\r\n#else\r\n\t\tret = spi_device_polling_transmit( SPIHandle, &SPITransaction );\r\n#endif\r\n\t\tassert(ret==ESP_OK); \r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\nbool spi_master_write_command(TFT_t * dev, uint8_t cmd)\r\n{\r\n\tstatic uint8_t Byte = 0;\r\n\tByte = cmd;\r\n\tgpio_set_level( dev->_dc, SPI_Command_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n}\r\n\r\nbool spi_master_write_data_byte(TFT_t * dev, uint8_t data)\r\n{\r\n\tstatic uint8_t Byte = 0;\r\n\tByte = data;\r\n\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, &Byte, 1 );\r\n}\r\n\r\n\r\nbool spi_master_write_data_word(TFT_t * dev, uint16_t data)\r\n{\r\n\tstatic uint8_t Byte[2];\r\n\tByte[0] = (data >> 8) & 0xFF;\r\n\tByte[1] = data & 0xFF;\r\n\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 2);\r\n}\r\n\r\nbool spi_master_write_addr(TFT_t * dev, uint16_t addr1, uint16_t addr2)\r\n{\r\n\tstatic uint8_t Byte[4];\r\n\tByte[0] = (addr1 >> 8) & 0xFF;\r\n\tByte[1] = addr1 & 0xFF;\r\n\tByte[2] = (addr2 >> 8) & 0xFF;\r\n\tByte[3] = addr2 & 0xFF;\r\n\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, Byte, 4);\r\n}\r\n\r\nbool spi_master_write_color(TFT_t * dev, uint16_t color, uint16_t size)\r\n{\r\n\tstatic uint8_t Byte[1024];\r\n\tint index = 0;\r\n\tfor(int i=0;i<size;i++) {\r\n\t\tByte[index++] = (color >> 8) & 0xFF;\r\n\t\tByte[index++] = color & 0xFF;\r\n\t}\r\n\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n}\r\n\r\n// Add 202001\r\nbool spi_master_write_colors(TFT_t * dev, uint16_t * colors, uint16_t size)\r\n{\r\n\tstatic uint8_t Byte[1024];\r\n\tint index = 0;\r\n\tfor(int i=0;i<size;i++) {\r\n\t\tByte[index++] = (colors[i] >> 8) & 0xFF;\r\n\t\tByte[index++] = colors[i] & 0xFF;\r\n\t}\r\n\tgpio_set_level( dev->_dc, SPI_Data_Mode );\r\n\treturn spi_master_write_byte( dev->_SPIHandle, Byte, size*2);\r\n}\r\n\r\nvoid delayMS(int ms) {\r\n\tint _ms = ms + (portTICK_PERIOD_MS - 1);\r\n\tTickType_t xTicksToDelay = _ms / portTICK_PERIOD_MS;\r\n\tESP_LOGD(TAG, \"ms=%d _ms=%d portTICK_PERIOD_MS=%\"PRIu32\" xTicksToDelay=%\"PRIu32,ms,_ms,portTICK_PERIOD_MS,xTicksToDelay);\r\n\tvTaskDelay(xTicksToDelay);\r\n}\r\n\r\n\r\nvoid lcdInit(TFT_t * dev, int width, int height, int offsetx, int offsety)\r\n{\r\n\tdev->_width = width;\r\n\tdev->_height = height;\r\n\tdev->_offsetx = offsetx;\r\n\tdev->_offsety = offsety;\r\n\tdev->_font_direction = DIRECTION0;\r\n\tdev->_font_fill = false;\r\n\tdev->_font_underline = false;\r\n\r\n\tspi_master_write_command(dev, 0x01);\t//Software Reset\r\n\tdelayMS(150);\r\n\r\n\tspi_master_write_command(dev, 0x11);\t//Sleep Out\r\n\tdelayMS(255);\r\n\t\r\n\tspi_master_write_command(dev, 0x3A);\t//Interface Pixel Format\r\n\tspi_master_write_data_byte(dev, 0x55);\r\n\tdelayMS(10);\r\n\t\r\n\tspi_master_write_command(dev, 0x36);\t//Memory Data Access Control\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\r\n\tspi_master_write_command(dev, 0x2A);\t//Column Address Set\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0xF0);\r\n\r\n\tspi_master_write_command(dev, 0x2B);\t//Row Address Set\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0x00);\r\n\tspi_master_write_data_byte(dev, 0xF0);\r\n\r\n\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n\tdelayMS(10);\r\n\r\n\tspi_master_write_command(dev, 0x13);\t//Normal Display Mode On\r\n\tdelayMS(10);\r\n\r\n\tspi_master_write_command(dev, 0x29);\t//Display ON\r\n\tdelayMS(255);\r\n\r\n\tif(dev->_bl >= 0) {\r\n\t\tgpio_set_level( dev->_bl, 1 );\r\n\t}\r\n}\r\n\r\n\r\n// Draw pixel\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// color:color\r\nvoid lcdDrawPixel(TFT_t * dev, uint16_t x, uint16_t y, uint16_t color){\r\n\tif (x >= dev->_width) return;\r\n\tif (y >= dev->_height) return;\r\n\r\n\tuint16_t _x = x + dev->_offsetx;\r\n\tuint16_t _y = y + dev->_offsety;\r\n\r\n\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n\tspi_master_write_addr(dev, _x, _x);\r\n\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n\tspi_master_write_addr(dev, _y, _y);\r\n\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n\tspi_master_write_data_word(dev, color);\r\n}\r\n\r\n\r\n// Draw multi pixel\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// size:Number of colors\r\n// colors:colors\r\nvoid lcdDrawMultiPixels(TFT_t * dev, uint16_t x, uint16_t y, uint16_t size, uint16_t * colors) {\r\n\tif (x+size > dev->_width) return;\r\n\tif (y >= dev->_height) return;\r\n\r\n\tuint16_t _x1 = x + dev->_offsetx;\r\n\tuint16_t _x2 = _x1 + (size-1);\r\n\tuint16_t _y1 = y + dev->_offsety;\r\n\tuint16_t _y2 = _y1;\r\n\r\n\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n\tspi_master_write_addr(dev, _x1, _x2);\r\n\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n\tspi_master_write_addr(dev, _y1, _y2);\r\n\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n\tspi_master_write_colors(dev, colors, size);\r\n}\r\n\r\n// Draw rectangle of filling\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End X coordinate\r\n// y2:End Y coordinate\r\n// color:color\r\nvoid lcdDrawFillRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n\tif (x1 >= dev->_width) return;\r\n\tif (x2 >= dev->_width) x2=dev->_width-1;\r\n\tif (y1 >= dev->_height) return;\r\n\tif (y2 >= dev->_height) y2=dev->_height-1;\r\n\r\n\tESP_LOGD(TAG,\"offset(x)=%d offset(y)=%d\",dev->_offsetx,dev->_offsety);\r\n\tuint16_t _x1 = x1 + dev->_offsetx;\r\n\tuint16_t _x2 = x2 + dev->_offsetx;\r\n\tuint16_t _y1 = y1 + dev->_offsety;\r\n\tuint16_t _y2 = y2 + dev->_offsety;\r\n\r\n\tspi_master_write_command(dev, 0x2A);\t// set column(x) address\r\n\tspi_master_write_addr(dev, _x1, _x2);\r\n\tspi_master_write_command(dev, 0x2B);\t// set Page(y) address\r\n\tspi_master_write_addr(dev, _y1, _y2);\r\n\tspi_master_write_command(dev, 0x2C);\t//\tMemory Write\r\n\tfor(int i=_x1;i<=_x2;i++){\r\n\t\tuint16_t size = _y2-_y1+1;\r\n\t\tspi_master_write_color(dev, color, size);\r\n#if 0\r\n\t\tfor(j=y1;j<=y2;j++){\r\n\t\t\t//ESP_LOGD(TAG,\"i=%d j=%d\",i,j);\r\n\t\t\tspi_master_write_data_word(dev, color);\r\n\t\t}\r\n#endif\r\n\t}\r\n}\r\n\r\n// Display OFF\r\nvoid lcdDisplayOff(TFT_t * dev) {\r\n\tspi_master_write_command(dev, 0x28);\t//Display off\r\n}\r\n \r\n// Display ON\r\nvoid lcdDisplayOn(TFT_t * dev) {\r\n\tspi_master_write_command(dev, 0x29);\t//Display on\r\n}\r\n\r\n// Fill screen\r\n// color:color\r\nvoid lcdFillScreen(TFT_t * dev, uint16_t color) {\r\n\tlcdDrawFillRect(dev, 0, 0, dev->_width-1, dev->_height-1, color);\r\n}\r\n\r\n// Draw line\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// color:color \r\nvoid lcdDrawLine(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n\tint i;\r\n\tint dx,dy;\r\n\tint sx,sy;\r\n\tint E;\r\n\r\n\t/* distance between two points */\r\n\tdx = ( x2 > x1 ) ? x2 - x1 : x1 - x2;\r\n\tdy = ( y2 > y1 ) ? y2 - y1 : y1 - y2;\r\n\r\n\t/* direction of two point */\r\n\tsx = ( x2 > x1 ) ? 1 : -1;\r\n\tsy = ( y2 > y1 ) ? 1 : -1;\r\n\r\n\t/* inclination < 1 */\r\n\tif ( dx > dy ) {\r\n\t\tE = -dx;\r\n\t\tfor ( i = 0 ; i <= dx ; i++ ) {\r\n\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n\t\t\tx1 += sx;\r\n\t\t\tE += 2 * dy;\r\n\t\t\tif ( E >= 0 ) {\r\n\t\t\ty1 += sy;\r\n\t\t\tE -= 2 * dx;\r\n\t\t}\r\n\t}\r\n\r\n\t/* inclination >= 1 */\r\n\t} else {\r\n\t\tE = -dy;\r\n\t\tfor ( i = 0 ; i <= dy ; i++ ) {\r\n\t\t\tlcdDrawPixel(dev, x1, y1, color);\r\n\t\t\ty1 += sy;\r\n\t\t\tE += 2 * dx;\r\n\t\t\tif ( E >= 0 ) {\r\n\t\t\t\tx1 += sx;\r\n\t\t\t\tE -= 2 * dy;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Draw rectangle\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// color:color\r\nvoid lcdDrawRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n\tlcdDrawLine(dev, x1, y1, x2, y1, color);\r\n\tlcdDrawLine(dev, x2, y1, x2, y2, color);\r\n\tlcdDrawLine(dev, x2, y2, x1, y2, color);\r\n\tlcdDrawLine(dev, x1, y2, x1, y1, color);\r\n}\r\n\r\n// Draw rectangle with angle\r\n// xc:Center X coordinate\r\n// yc:Center Y coordinate\r\n// w:Width of rectangle\r\n// h:Height of rectangle\r\n// angle:Angle of rectangle\r\n// color:color\r\n\r\n//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n// x1 = x * cos(angle) - y * sin(angle)\r\n// y1 = x * sin(angle) + y * cos(angle)\r\nvoid lcdDrawRectAngle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n\tdouble xd,yd,rd;\r\n\tint x1,y1;\r\n\tint x2,y2;\r\n\tint x3,y3;\r\n\tint x4,y4;\r\n\trd = -angle * M_PI / 180.0;\r\n\txd = 0.0 - w/2;\r\n\tyd = h/2;\r\n\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\tyd = 0.0 - yd;\r\n\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\txd = w/2;\r\n\tyd = h/2;\r\n\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\tyd = 0.0 - yd;\r\n\tx4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n\tlcdDrawLine(dev, x2, y2, x4, y4, color);\r\n\tlcdDrawLine(dev, x3, y3, x4, y4, color);\r\n}\r\n\r\n// Draw triangle\r\n// xc:Center X coordinate\r\n// yc:Center Y coordinate\r\n// w:Width of triangle\r\n// h:Height of triangle\r\n// angle:Angle of triangle\r\n// color:color\r\n\r\n//When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n// x1 = x * cos(angle) - y * sin(angle)\r\n// y1 = x * sin(angle) + y * cos(angle)\r\nvoid lcdDrawTriangle(TFT_t * dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n\tdouble xd,yd,rd;\r\n\tint x1,y1;\r\n\tint x2,y2;\r\n\tint x3,y3;\r\n\trd = -angle * M_PI / 180.0;\r\n\txd = 0.0;\r\n\tyd = h/2;\r\n\tx1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\txd = w/2;\r\n\tyd = 0.0 - yd;\r\n\tx2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\txd = 0.0 - w/2;\r\n\tx3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n\ty3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n\tlcdDrawLine(dev, x1, y1, x2, y2, color);\r\n\tlcdDrawLine(dev, x1, y1, x3, y3, color);\r\n\tlcdDrawLine(dev, x2, y2, x3, y3, color);\r\n}\r\n\r\n// Draw circle\r\n// x0:Central X coordinate\r\n// y0:Central Y coordinate\r\n// r:radius\r\n// color:color\r\nvoid lcdDrawCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n\tint x;\r\n\tint y;\r\n\tint err;\r\n\tint old_err;\r\n\r\n\tx=0;\r\n\ty=-r;\r\n\terr=2-2*r;\r\n\tdo{\r\n\t\tlcdDrawPixel(dev, x0-x, y0+y, color); \r\n\t\tlcdDrawPixel(dev, x0-y, y0-x, color); \r\n\t\tlcdDrawPixel(dev, x0+x, y0-y, color); \r\n\t\tlcdDrawPixel(dev, x0+y, y0+x, color); \r\n\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n\t} while(y<0);\r\n}\r\n\r\n// Draw circle of filling\r\n// x0:Central X coordinate\r\n// y0:Central Y coordinate\r\n// r:radius\r\n// color:color\r\nvoid lcdDrawFillCircle(TFT_t * dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n\tint x;\r\n\tint y;\r\n\tint err;\r\n\tint old_err;\r\n\tint ChangeX;\r\n\r\n\tx=0;\r\n\ty=-r;\r\n\terr=2-2*r;\r\n\tChangeX=1;\r\n\tdo{\r\n\t\tif(ChangeX) {\r\n\t\t\tlcdDrawLine(dev, x0-x, y0-y, x0-x, y0+y, color);\r\n\t\t\tlcdDrawLine(dev, x0+x, y0-y, x0+x, y0+y, color);\r\n\t\t} // endif\r\n\t\tChangeX=(old_err=err)<=x;\r\n\t\tif (ChangeX)\t\t\terr+=++x*2+1;\r\n\t\tif (old_err>y || err>x) err+=++y*2+1;\r\n\t} while(y<=0);\r\n} \r\n\r\n// Draw rectangle with round corner\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// r:radius\r\n// color:color\r\nvoid lcdDrawRoundRect(TFT_t * dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n\tint x;\r\n\tint y;\r\n\tint err;\r\n\tint old_err;\r\n\tunsigned char temp;\r\n\r\n\tif(x1>x2) {\r\n\t\ttemp=x1; x1=x2; x2=temp;\r\n\t} // endif\r\n\t  \r\n\tif(y1>y2) {\r\n\t\ttemp=y1; y1=y2; y2=temp;\r\n\t} // endif\r\n\r\n\tESP_LOGD(TAG, \"x1=%d x2=%d delta=%d r=%d\",x1, x2, x2-x1, r);\r\n\tESP_LOGD(TAG, \"y1=%d y2=%d delta=%d r=%d\",y1, y2, y2-y1, r);\r\n\tif (x2-x1 < r) return; // Add 20190517\r\n\tif (y2-y1 < r) return; // Add 20190517\r\n\r\n\tx=0;\r\n\ty=-r;\r\n\terr=2-2*r;\r\n\r\n\tdo{\r\n\t\tif(x) {\r\n\t\t\tlcdDrawPixel(dev, x1+r-x, y1+r+y, color); \r\n\t\t\tlcdDrawPixel(dev, x2-r+x, y1+r+y, color); \r\n\t\t\tlcdDrawPixel(dev, x1+r-x, y2-r-y, color); \r\n\t\t\tlcdDrawPixel(dev, x2-r+x, y2-r-y, color);\r\n\t\t} // endif \r\n\t\tif ((old_err=err)<=x)\terr+=++x*2+1;\r\n\t\tif (old_err>y || err>x) err+=++y*2+1;\t \r\n\t} while(y<0);\r\n\r\n\tESP_LOGD(TAG, \"x1+r=%d x2-r=%d\",x1+r, x2-r);\r\n\tlcdDrawLine(dev, x1+r,y1  ,x2-r,y1\t,color);\r\n\tlcdDrawLine(dev, x1+r,y2  ,x2-r,y2\t,color);\r\n\tESP_LOGD(TAG, \"y1+r=%d y2-r=%d\",y1+r, y2-r);\r\n\tlcdDrawLine(dev, x1  ,y1+r,x1  ,y2-r,color);\r\n\tlcdDrawLine(dev, x2  ,y1+r,x2  ,y2-r,color);  \r\n} \r\n\r\n// Draw arrow\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// w:Width of the botom\r\n// color:color\r\n// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\nvoid lcdDrawArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n\tdouble Vx= x1 - x0;\r\n\tdouble Vy= y1 - y0;\r\n\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n\t//\t printf(\"v=%f\\n\",v);\r\n\tdouble Ux= Vx/v;\r\n\tdouble Uy= Vy/v;\r\n\r\n\tuint16_t L[2],R[2];\r\n\tL[0]= x1 - Uy*w - Ux*v;\r\n\tL[1]= y1 + Ux*w - Uy*v;\r\n\tR[0]= x1 + Uy*w - Ux*v;\r\n\tR[1]= y1 - Ux*w - Uy*v;\r\n\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n\r\n\t//lcdDrawLine(x0,y0,x1,y1,color);\r\n\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n}\r\n\r\n\r\n// Draw arrow of filling\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// w:Width of the botom\r\n// color:color\r\nvoid lcdDrawFillArrow(TFT_t * dev, uint16_t x0,uint16_t y0,uint16_t x1,uint16_t y1,uint16_t w,uint16_t color) {\r\n\tdouble Vx= x1 - x0;\r\n\tdouble Vy= y1 - y0;\r\n\tdouble v = sqrt(Vx*Vx+Vy*Vy);\r\n\t//printf(\"v=%f\\n\",v);\r\n\tdouble Ux= Vx/v;\r\n\tdouble Uy= Vy/v;\r\n\r\n\tuint16_t L[2],R[2];\r\n\tL[0]= x1 - Uy*w - Ux*v;\r\n\tL[1]= y1 + Ux*w - Uy*v;\r\n\tR[0]= x1 + Uy*w - Ux*v;\r\n\tR[1]= y1 - Ux*w - Uy*v;\r\n\t//printf(\"L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n\r\n\tlcdDrawLine(dev, x0, y0, x1, y1, color);\r\n\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n\tlcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n\r\n\tint ww;\r\n\tfor(ww=w-1;ww>0;ww--) {\r\n\t\tL[0]= x1 - Uy*ww - Ux*v;\r\n\t\tL[1]= y1 + Ux*ww - Uy*v;\r\n\t\tR[0]= x1 + Uy*ww - Ux*v;\r\n\t\tR[1]= y1 - Ux*ww - Uy*v;\r\n\t\t//printf(\"Fill>L=%d-%d R=%d-%d\\n\",L[0],L[1],R[0],R[1]);\r\n\t\tlcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n\t\tlcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n\t}\r\n}\r\n\r\n\r\n// RGB565 conversion\r\n// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n// Bit image \"RRRRRGGGGGGBBBBB\"\r\nuint16_t rgb565_conv(uint16_t r,uint16_t g,uint16_t b) {\r\n\treturn (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n}\r\n\r\n// Draw ASCII character\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// ascii: ascii code\r\n// color:color\r\nint lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n\tuint16_t xx,yy,bit,ofs;\r\n\tunsigned char fonts[128]; // font pattern\r\n\tunsigned char pw, ph;\r\n\tint h,w;\r\n\tuint16_t mask;\r\n\tbool rc;\r\n\r\n\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n\tif (!rc) return 0;\r\n\r\n\tint16_t xd1 = 0;\r\n\tint16_t yd1 = 0;\r\n\tint16_t xd2 = 0;\r\n\tint16_t yd2 = 0;\r\n\tuint16_t xss = 0;\r\n\tuint16_t yss = 0;\r\n\tint16_t xsd = 0;\r\n\tint16_t ysd = 0;\r\n\tint16_t next = 0;\r\n\tuint16_t x0  = 0;\r\n\tuint16_t x1  = 0;\r\n\tuint16_t y0  = 0;\r\n\tuint16_t y1  = 0;\r\n\tif (dev->_font_direction == 0) {\r\n\t\txd1 = +1;\r\n\t\tyd1 = +1; //-1;\r\n\t\txd2 =  0;\r\n\t\tyd2 =  0;\r\n\t\txss =  x;\r\n\t\tyss =  y - (ph - 1);\r\n\t\txsd =  1;\r\n\t\tysd =  0;\r\n\t\tnext = x + pw;\r\n\r\n\t\tx0\t= x;\r\n\t\ty0\t= y - (ph-1);\r\n\t\tx1\t= x + (pw-1);\r\n\t\ty1\t= y;\r\n\t} else if (dev->_font_direction == 2) {\r\n\t\txd1 = -1;\r\n\t\tyd1 = -1; //+1;\r\n\t\txd2 =  0;\r\n\t\tyd2 =  0;\r\n\t\txss =  x;\r\n\t\tyss =  y + ph + 1;\r\n\t\txsd =  1;\r\n\t\tysd =  0;\r\n\t\tnext = x - pw;\r\n\r\n\t\tx0\t= x - (pw-1);\r\n\t\ty0\t= y;\r\n\t\tx1\t= x;\r\n\t\ty1\t= y + (ph-1);\r\n\t} else if (dev->_font_direction == 1) {\r\n\t\txd1 =  0;\r\n\t\tyd1 =  0;\r\n\t\txd2 = -1;\r\n\t\tyd2 = +1; //-1;\r\n\t\txss =  x + ph;\r\n\t\tyss =  y;\r\n\t\txsd =  0;\r\n\t\tysd =  1;\r\n\t\tnext = y + pw; //y - pw;\r\n\r\n\t\tx0\t= x;\r\n\t\ty0\t= y;\r\n\t\tx1\t= x + (ph-1);\r\n\t\ty1\t= y + (pw-1);\r\n\t} else if (dev->_font_direction == 3) {\r\n\t\txd1 =  0;\r\n\t\tyd1 =  0;\r\n\t\txd2 = +1;\r\n\t\tyd2 = -1; //+1;\r\n\t\txss =  x - (ph - 1);\r\n\t\tyss =  y;\r\n\t\txsd =  0;\r\n\t\tysd =  1;\r\n\t\tnext = y - pw; //y + pw;\r\n\r\n\t\tx0\t= x - (ph-1);\r\n\t\ty0\t= y - (pw-1);\r\n\t\tx1\t= x;\r\n\t\ty1\t= y;\r\n\t}\r\n\r\n\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n\r\n\tint bits;\r\n\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n\tofs = 0;\r\n\tyy = yss;\r\n\txx = xss;\r\n\tfor(h=0;h<ph;h++) {\r\n\t\tif(xsd) xx = xss;\r\n\t\tif(ysd) yy = yss;\r\n\t\t//for(w=0;w<(pw/8);w++) {\r\n\t\tbits = pw;\r\n\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n\t\t\tmask = 0x80;\r\n\t\t\tfor(bit=0;bit<8;bit++) {\r\n\t\t\t\tbits--;\r\n\t\t\t\tif (bits < 0) continue;\r\n\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n\t\t\t\tif (fonts[ofs] & mask) {\r\n\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n\t\t\t\t}\r\n\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n\t\t\t\txx = xx + xd1;\r\n\t\t\t\tyy = yy + yd2;\r\n\t\t\t\tmask = mask >> 1;\r\n\t\t\t}\r\n\t\t\tofs++;\r\n\t\t}\r\n\t\tyy = yy + yd1;\r\n\t\txx = xx + xd2;\r\n\t}\r\n\r\n\tif (next < 0) next = 0;\r\n\treturn next;\r\n}\r\n\r\nint lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n\tint length = strlen((char *)ascii);\r\n\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n\tfor(int i=0;i<length;i++) {\r\n\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n\t\tif (dev->_font_direction == 0)\r\n\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n\t\tif (dev->_font_direction == 1)\r\n\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n\t\tif (dev->_font_direction == 2)\r\n\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n\t\tif (dev->_font_direction == 3)\r\n\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n\t}\r\n\tif (dev->_font_direction == 0) return x;\r\n\tif (dev->_font_direction == 2) return x;\r\n\tif (dev->_font_direction == 1) return y;\r\n\tif (dev->_font_direction == 3) return y;\r\n\treturn 0;\r\n}\r\n\r\n\r\n// Draw Non-Alphanumeric character\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// code:character code\r\n// color:color\r\nint lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n\tif (dev->_font_direction == 0)\r\n\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n\tif (dev->_font_direction == 1)\r\n\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n\tif (dev->_font_direction == 2)\r\n\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n\tif (dev->_font_direction == 3)\r\n\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n\tif (dev->_font_direction == 0) return x;\r\n\tif (dev->_font_direction == 2) return x;\r\n\tif (dev->_font_direction == 1) return y;\r\n\tif (dev->_font_direction == 3) return y;\r\n\treturn 0;\r\n}\r\n\r\n#if 0\r\n// Draw UTF8 character\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// utf8:UTF8 code\r\n// color:color\r\nint lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n\tuint16_t sjis[1];\r\n\r\n\tsjis[0] = UTF2SJIS(utf8);\r\n\tif(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n\treturn lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n}\r\n\r\n// Draw UTF8 string\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// utfs:UTF8 string\r\n// color:color\r\nint lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n\r\n\tint i;\r\n\tint spos;\r\n\tuint16_t sjis[64];\r\n\tspos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n\tif(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n\tfor(i=0;i<spos;i++) {\r\n\t\tif(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n\t\tif (dev->_font_direction == 0)\r\n\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n\t\tif (dev->_font_direction == 1)\r\n\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n\t\tif (dev->_font_direction == 2)\r\n\t\t\tx = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n\t\tif (dev->_font_direction == 3)\r\n\t\t\ty = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n\t}\r\n\tif (dev->_font_direction == 0) return x;\r\n\tif (dev->_font_direction == 2) return x;\r\n\tif (dev->_font_direction == 1) return y;\r\n\tif (dev->_font_direction == 3) return y;\r\n\treturn 0;\r\n}\r\n#endif\r\n\r\n// Set font direction\r\n// dir:Direction\r\nvoid lcdSetFontDirection(TFT_t * dev, uint16_t dir) {\r\n\tdev->_font_direction = dir;\r\n}\r\n\r\n// Set font filling\r\n// color:fill color\r\nvoid lcdSetFontFill(TFT_t * dev, uint16_t color) {\r\n\tdev->_font_fill = true;\r\n\tdev->_font_fill_color = color;\r\n}\r\n\r\n// UnSet font filling\r\nvoid lcdUnsetFontFill(TFT_t * dev) {\r\n\tdev->_font_fill = false;\r\n}\r\n\r\n// Set font underline\r\n// color:frame color\r\nvoid lcdSetFontUnderLine(TFT_t * dev, uint16_t color) {\r\n\tdev->_font_underline = true;\r\n\tdev->_font_underline_color = color;\r\n}\r\n\r\n// UnSet font underline\r\nvoid lcdUnsetFontUnderLine(TFT_t * dev) {\r\n\tdev->_font_underline = false;\r\n}\r\n\r\n// Backlight OFF\r\nvoid lcdBacklightOff(TFT_t * dev) {\r\n\tif(dev->_bl >= 0) {\r\n\t\tgpio_set_level( dev->_bl, 0 );\r\n\t}\r\n}\r\n\r\n// Backlight ON\r\nvoid lcdBacklightOn(TFT_t * dev) {\r\n\tif(dev->_bl >= 0) {\r\n\t\tgpio_set_level( dev->_bl, 1 );\r\n\t}\r\n}\r\n\r\n// Display Inversion Off\r\nvoid lcdInversionOff(TFT_t * dev) {\r\n\tspi_master_write_command(dev, 0x20);\t//Display Inversion Off\r\n}\r\n\r\n// Display Inversion On\r\nvoid lcdInversionOn(TFT_t * dev) {\r\n\tspi_master_write_command(dev, 0x21);\t//Display Inversion On\r\n}\r\n"
        }
    ]
}