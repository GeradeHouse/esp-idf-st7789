{
    "sourceFile": "main/pngle.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1731797779575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1731797779575,
            "name": "Commit-0",
            "content": "/*-\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 kikuchan\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#ifndef __PNGLE_H__\r\n#define __PNGLE_H__\r\n\r\n#include <stdint.h>\r\n#include <stdbool.h>\r\n#include <miniz.h>  // Replace \"rom/miniz.h\" with \"miniz.h\"\r\n#include \"rom/miniz.h\"\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#ifndef MIN\r\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\r\n#endif\r\n\r\n#ifdef PNGLE_DEBUG\r\n#define debug_printf(...) fprintf(stderr, __VA_ARGS__)\r\n#else\r\n#define debug_printf(...) ((void)0)\r\n#endif\r\n\r\n//#define PNGLE_NO_GAMMA_CORRECTION\r\n\r\n#if 0\r\ntypedef struct __attribute__((__packed__)) {\r\n    uint8_t red;\r\n    uint8_t green;\r\n    uint8_t blue;\r\n} pixel_png;\r\n#endif\r\n\r\n//rgb565 format\r\ntypedef uint16_t pixel_png;\r\n\r\ntypedef enum {\r\n    PNGLE_STATE_ERROR = -2,\r\n    PNGLE_STATE_EOF = -1,\r\n    PNGLE_STATE_INITIAL = 0,\r\n\r\n    PNGLE_STATE_FIND_CHUNK_HEADER,\r\n    PNGLE_STATE_HANDLE_CHUNK,\r\n    PNGLE_STATE_CRC,\r\n} pngle_state_t;\r\n\r\n\r\ntypedef enum {\r\n// Supported chunks\r\n//   Filter chunk names by following command to (re)generate hex constants;\r\n//     % perl -ne 'chomp; s/.*\\s*\\/\\/\\s*//; print \"\\tPNGLE_CHUNK_$_ = 0x\" . unpack(\"H*\") . \"UL, // $_\\n\";'\r\n    PNGLE_CHUNK_IHDR = 0x49484452UL, // IHDR\r\n    PNGLE_CHUNK_PLTE = 0x504c5445UL, // PLTE\r\n    PNGLE_CHUNK_IDAT = 0x49444154UL, // IDAT\r\n    PNGLE_CHUNK_IEND = 0x49454e44UL, // IEND\r\n    PNGLE_CHUNK_tRNS = 0x74524e53UL, // tRNS\r\n    PNGLE_CHUNK_gAMA = 0x67414d41UL, // gAMA\r\n} pngle_chunk_t;\r\n\r\ntypedef struct _pngle_ihdr_t {\r\n\tuint32_t width;\r\n\tuint32_t height;\r\n\tuint8_t depth;\r\n\tuint8_t color_type;\r\n\tuint8_t compression;\r\n\tuint8_t filter;\r\n\tuint8_t interlace;\r\n} pngle_ihdr_t;\r\n\r\ntypedef unsigned int\tUINT;\r\n\r\ntypedef struct pngle pngle_t;\r\n\r\ntypedef void (*pngle_init_callback_t)(pngle_t *pngle, uint32_t w, uint32_t h);\r\ntypedef void (*pngle_draw_callback_t)(pngle_t *pngle, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint8_t rgba[4]);\r\ntypedef void (*pngle_done_callback_t)(pngle_t *pngle);\r\n\r\nstruct pngle {\r\n    pngle_ihdr_t hdr;\r\n\r\n    uint_fast8_t channels; // 0 indicates IHDR hasn't been processed yet\r\n\r\n    // PLTE chunk\r\n    size_t n_palettes;\r\n    uint8_t *palette;\r\n\r\n    // tRNS chunk\r\n    size_t n_trans_palettes;\r\n    uint8_t *trans_palette;\r\n\r\n    // parser state (reset on every chunk header)\r\n    pngle_state_t state;\r\n    uint32_t chunk_type;\r\n    uint32_t chunk_remain;\r\n    mz_ulong crc32;\r\n\r\n    // decompression state (reset on IHDR)\r\n    tinfl_decompressor inflator; // 11000 bytes\r\n    uint8_t lz_buf[TINFL_LZ_DICT_SIZE]; // 32768 bytes\r\n    uint8_t *next_out; // NULL indicates IDAT hasn't been processed yet\r\n    size_t  avail_out;\r\n\r\n    // scanline decoder (reset on every set_interlace_pass() call)\r\n    uint8_t *scanline_ringbuf;\r\n    size_t scanline_ringbuf_size;\r\n    size_t scanline_ringbuf_cidx;\r\n    int_fast8_t scanline_remain_bytes_to_render;\r\n    int_fast8_t filter_type;\r\n    uint32_t drawing_x;\r\n    uint32_t drawing_y;\r\n\r\n    // interlace\r\n    uint_fast8_t interlace_pass;\r\n\r\n    const char *error;\r\n\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n    uint8_t *gamma_table;\r\n    double display_gamma;\r\n#endif\r\n\r\n    pngle_init_callback_t init_callback;\r\n    pngle_draw_callback_t draw_callback;\r\n    pngle_done_callback_t done_callback;\r\n\r\n    void *user_data;\r\n\tuint16_t screenWidth;\r\n\tuint16_t screenHeight;\r\n\tuint16_t imageWidth;\r\n\tuint16_t imageHeight;\r\n\tpixel_png **pixels;\r\n\tbool reduction;\r\n\tdouble scale_factor;\r\n};\r\n\r\n\r\n// ----------------\r\n// Basic interfaces\r\n// ----------------\r\npngle_t *pngle_new(uint16_t width, uint16_t height);\r\nvoid pngle_destroy(pngle_t *pngle, uint16_t width, uint16_t height);\r\nvoid pngle_reset(pngle_t *pngle); // clear its internal state (not applied to pngle_set_* functions)\r\nconst char *pngle_error(pngle_t *pngle);\r\nint pngle_feed(pngle_t *pngle, const void *buf, size_t len); // returns -1: On error, 0: Need more data, n: n bytes eaten\r\n\r\nuint32_t pngle_get_width(pngle_t *pngle);\r\nuint32_t pngle_get_height(pngle_t *pngle);\r\n\r\nvoid pngle_set_init_callback(pngle_t *png, pngle_init_callback_t callback);\r\nvoid pngle_set_draw_callback(pngle_t *png, pngle_draw_callback_t callback);\r\nvoid pngle_set_done_callback(pngle_t *png, pngle_done_callback_t callback);\r\n\r\nvoid pngle_set_display_gamma(pngle_t *pngle, double display_gamma); // enables gamma correction by specifying display gamma, typically 2.2. No effect when gAMA chunk is missing\r\n\r\nvoid pngle_set_user_data(pngle_t *pngle, void *user_data);\r\nvoid *pngle_get_user_data(pngle_t *pngle);\r\n\r\n\r\n// Get IHDR information\r\npngle_ihdr_t *pngle_get_ihdr(pngle_t *pngle);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n#endif /* __PNGLE_H__ */\r\n"
        }
    ]
}