{
    "sourceFile": "main/main.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 23,
            "patches": [
                {
                    "date": 1731797635954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731797644653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1224 @@\n+#include <stdio.h>\r\n+#include <stdlib.h>\r\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+#include \"esp_err.h\"\r\n+#include \"esp_log.h\"\r\n+#include \"esp_system.h\"\r\n+#include \"esp_vfs.h\"\r\n+#include \"esp_spiffs.h\"\r\n+\r\n+#include \"st7789.h\"\r\n+#include \"fontx.h\"\r\n+#include \"bmpfile.h\"\r\n+#include \"decode_jpeg.h\"\r\n+#include \"decode_png.h\"\r\n+#include \"pngle.h\"\r\n+\r\n+#define INTERVAL 400\r\n+#define WAIT vTaskDelay(INTERVAL)\r\n+\r\n+static const char *TAG = \"ST7789\";\r\n+\r\n+static void SPIFFS_Directory(char * path) {\r\n+\tDIR* dir = opendir(path);\r\n+\tassert(dir != NULL);\r\n+\twhile (true) {\r\n+\t\tstruct dirent*pe = readdir(dir);\r\n+\t\tif (!pe) break;\r\n+\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n+\t}\r\n+\tclosedir(dir);\r\n+}\r\n+\r\n+// You have to set these CONFIG value using menuconfig.\r\n+#if 0\r\n+#define CONFIG_WIDTH  240\r\n+#define CONFIG_HEIGHT 240\r\n+#define CONFIG_MOSI_GPIO 23\r\n+#define CONFIG_SCLK_GPIO 18\r\n+#define CONFIG_CS_GPIO -1\r\n+#define CONFIG_DC_GPIO 19\r\n+#define CONFIG_RESET_GPIO 15\r\n+#define CONFIG_BL_GPIO -1\r\n+#endif\r\n+\r\n+TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdFillScreen(dev, RED);\r\n+\tvTaskDelay(50);\r\n+\tlcdFillScreen(dev, GREEN);\r\n+\tvTaskDelay(50);\r\n+\tlcdFillScreen(dev, BLUE);\r\n+\tvTaskDelay(50);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tif (width < height) {\r\n+\t\tuint16_t y1,y2;\r\n+\t\ty1 = height/3;\r\n+\t\ty2 = (height/3)*2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n+\t} else {\r\n+\t\tuint16_t x1,x2;\r\n+\t\tx1 = width/3;\r\n+\t\tx2 = (width/3)*2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\t\r\n+\tuint16_t xpos;\r\n+\tuint16_t ypos;\r\n+\tint\tstlen;\r\n+\tuint8_t ascii[24];\r\n+\tuint16_t color;\r\n+\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\tstrcpy((char *)ascii, \"ST7789\");\r\n+\tif (width < height) {\r\n+\t\txpos = ((width - fontHeight) / 2) - 1;\r\n+\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n+\t} else {\r\n+\t\typos = ((height - fontHeight) / 2) - 1;\r\n+\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n+\t}\r\n+\tcolor = WHITE;\r\n+\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcolor = RED;\r\n+\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n+\tstrcpy((char *)ascii, \"0,0\");\r\n+\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n+\r\n+\tcolor = GREEN;\r\n+\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n+\t//strcpy((char *)ascii, \"79,0\");\r\n+\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n+\tstlen = strlen((char *)ascii);\r\n+\txpos = (width-1) - (fontWidth*stlen);\r\n+\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n+\r\n+\tcolor = GRAY;\r\n+\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n+\t//strcpy((char *)ascii, \"0,159\");\r\n+\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n+\typos = (height-11) - (fontHeight) + 5;\r\n+\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n+\t//strcpy((char *)ascii, \"79,159\");\r\n+\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n+\tstlen = strlen((char *)ascii);\r\n+\txpos = (width-1) - (fontWidth*stlen);\r\n+\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=0\");\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=2\");\r\n+\tlcdSetFontDirection(dev, 2);\r\n+\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n+\r\n+\tcolor = CYAN;\r\n+\tstrcpy((char *)ascii, \"Direction=1\");\r\n+\tlcdSetFontDirection(dev, 1);\r\n+\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n+\r\n+\tcolor = GREEN;\r\n+\tstrcpy((char *)ascii, \"Direction=3\");\r\n+\tlcdSetFontDirection(dev, 3);\r\n+\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=0\");\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, GREEN);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=2\");\r\n+\tlcdSetFontDirection(dev, 2);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, YELLOW);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=1\");\r\n+\tlcdSetFontDirection(dev, 1);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, GREEN);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=3\");\r\n+\tlcdSetFontDirection(dev, 3);\r\n+\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, YELLOW);\r\n+\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor=RED;\r\n+\tfor(int ypos=0;ypos<height;ypos=ypos+10) {\r\n+\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n+\t}\r\n+\r\n+\tfor(int xpos=0;xpos<width;xpos=xpos+10) {\r\n+\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\tfor(int i=5;i<height;i=i+5) {\r\n+\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\r\n+\tuint16_t w = width * 0.6;\r\n+\tuint16_t h = w * 0.5;\r\n+\tint angle;\r\n+\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tusleep(10000);\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t}\r\n+\r\n+\tfor(angle=0;angle<=180;angle=angle+30) {\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\r\n+\tuint16_t w = width * 0.6;\r\n+\tuint16_t h = w * 1.0;\r\n+\tint angle;\r\n+\r\n+\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tusleep(10000);\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t}\r\n+\r\n+\tfor(angle=0;angle<=360;angle=angle+30) {\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tuint16_t limit = width;\r\n+\tif (width > height) limit = height;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = BLUE;\r\n+\tfor(int i=5;i<limit;i=i+5) {\r\n+\t\tif (i > (limit-i-1) ) break;\r\n+\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n+\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, CYAN);\r\n+\r\n+\tuint16_t red;\r\n+\tuint16_t green;\r\n+\tuint16_t blue;\r\n+\tsrand( (unsigned int)time( NULL ) );\r\n+\tfor(int i=1;i<100;i++) {\r\n+\t\tred=rand()%255;\r\n+\t\tgreen=rand()%255;\r\n+\t\tblue=rand()%255;\r\n+\t\tcolor=rgb565_conv(red, green, blue);\r\n+\t\tuint16_t xpos=rand()%width;\r\n+\t\tuint16_t ypos=rand()%height;\r\n+\t\tuint16_t size=rand()%(width/5);\r\n+\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, WHITE);\r\n+\tcolor = RED;\r\n+\tuint16_t delta = height/16;\r\n+\tuint16_t ypos = 0;\r\n+\tfor(int i=0;i<16;i++) {\r\n+\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n+\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n+\t\tcolor = color >> 1;\r\n+\t\typos = ypos + delta;\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+#define BUFFPIXEL 20\r\n+\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n+\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n+\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n+\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n+\t\t\t\t}\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n+\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n+\r\n+\t\tint debug = 0; // number of logging output\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n+\t\t\tint buffidx = 0;\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\r\n+\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tuint8_t mask = 0x80;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tcolors[index] = BLACK;\r\n+\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n+\t\t\t\tindex++;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t\tif (mask == 0x00) {\r\n+\t\t\t\t\tbuffidx++;\r\n+\t\t\t\t\tmask = 0x80;\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\tdebug--;\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(sdbuffer);\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+\r\n+TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\r\n+\tpixel_jpeg **pixels;\r\n+\tint imageWidth;\r\n+\tint imageHeight;\r\n+\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n+\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n+\tif (err == ESP_OK) {\r\n+\r\n+\t\tuint16_t _width = width;\r\n+\t\tuint16_t _cols = 0;\r\n+\t\tif (width > imageWidth) {\r\n+\t\t\t_width = imageWidth;\r\n+\t\t\t_cols = (width - imageWidth) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\t\tuint16_t _height = height;\r\n+\t\tuint16_t _rows = 0;\r\n+\t\tif (height > imageHeight) {\r\n+\t\t\t_height = imageHeight;\r\n+\t\t\t_rows = (height - imageHeight) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t\t}\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+#endif\r\n+\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tcolors[x] = pixels[y][x];\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tfree(colors);\r\n+\t\trelease_image(&pixels, width, height);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n+\t} else {\r\n+\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open PNG file\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tchar buf[1024];\r\n+\tsize_t remain = 0;\r\n+\tint len;\r\n+\r\n+\tpngle_t *pngle = pngle_new(width, height);\r\n+\r\n+\tpngle_set_init_callback(pngle, png_init);\r\n+\tpngle_set_draw_callback(pngle, png_draw);\r\n+\tpngle_set_done_callback(pngle, png_finish);\r\n+\r\n+\tdouble display_gamma = 2.2;\r\n+\tpngle_set_display_gamma(pngle, display_gamma);\r\n+\r\n+\r\n+\twhile (!feof(fp)) {\r\n+\t\tif (remain >= sizeof(buf)) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n+\t\tif (len <= 0) {\r\n+\t\t\t//printf(\"EOF\\n\");\r\n+\t\t\tbreak;\r\n+\t\t}\r\n+\r\n+\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n+\t\tif (fed < 0) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tremain = remain + len - fed;\r\n+\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n+\t}\r\n+\r\n+\tfclose(fp);\r\n+\r\n+\tuint16_t _width = width;\r\n+\tuint16_t _cols = 0;\r\n+\tif (width > pngle->imageWidth) {\r\n+\t\t_width = pngle->imageWidth;\r\n+\t\t_cols = (width - pngle->imageWidth) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\tuint16_t _height = height;\r\n+\tuint16_t _rows = 0;\r\n+\tif (height > pngle->imageHeight) {\r\n+\t\t\t_height = pngle->imageHeight;\r\n+\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t}\r\n+\t}\r\n+#endif\r\n+\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tcolors[x] = pngle->pixels[y][x];\r\n+\t\t}\r\n+\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\tfree(colors);\r\n+\tpngle_destroy(pngle, width, height);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\tuint8_t xmoji = width / fontWidth;\r\n+\tuint8_t ymoji = height / fontHeight;\r\n+\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t code;\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcode = 0xA0;\r\n+\tfor(int y=0;y<ymoji;y++) {\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n+\t\tfor(int x=0;x<xmoji;x++) {\r\n+\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n+\t\t\tif (code == 0xFF) break;\r\n+\t\t\tcode++;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+void ST7789(void *pvParameters)\r\n+{\r\n+\t// set font file\r\n+\tFontxFile fx16G[2];\r\n+\tFontxFile fx24G[2];\r\n+\tFontxFile fx32G[2];\r\n+\tFontxFile fx32L[2];\r\n+\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n+\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n+\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n+\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n+\r\n+\tFontxFile fx16M[2];\r\n+\tFontxFile fx24M[2];\r\n+\tFontxFile fx32M[2];\r\n+\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n+\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n+\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n+\t\r\n+\tTFT_t dev;\r\n+\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n+\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n+\r\n+#if CONFIG_INVERSION\r\n+\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n+\tlcdInversionOn(&dev);\r\n+#endif\r\n+\r\n+#if 0\r\n+\twhile (1) {\r\n+\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tchar file[32];\r\n+\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n+\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n+\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n+\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+#endif\r\n+\t}\r\n+#endif\r\n+\r\n+#if 0\r\n+\t//for TEST\r\n+\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n+\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n+\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n+#endif\r\n+\r\n+\twhile(1) {\r\n+\r\n+\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tchar file[32];\r\n+\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n+\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n+\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n+\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+#endif\r\n+\r\n+\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n+\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n+\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\t// Multi Font Test\r\n+\t\tuint16_t color;\r\n+\t\tuint8_t ascii[40];\r\n+\t\tuint16_t margin = 10;\r\n+\t\tlcdFillScreen(&dev, BLACK);\r\n+\t\tcolor = WHITE;\r\n+\t\tlcdSetFontDirection(&dev, 0);\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos = 15;\r\n+\t\tint xd = 0;\r\n+\t\tint yd = 1;\r\n+\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n+\t\t\tlcdSetFontDirection(&dev, 1);\r\n+\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n+\t\t\typos = 0;\r\n+\t\t\txd = 1;\r\n+\t\t\tyd = 0;\r\n+\t\t}\r\n+\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n+\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n+\t\typos = ypos + (16 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n+\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n+\t\typos = ypos + (24 * yd) + (margin * yd);\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n+\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n+\t\t}\r\n+\r\n+\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n+\t\typos = ypos + (10 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n+\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n+\t\typos = ypos + (16 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n+\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n+\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n+\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n+\t\t}\r\n+\t\tlcdSetFontDirection(&dev, 0);\r\n+\t\tWAIT;\r\n+\r\n+\t} // end while\r\n+\r\n+\t// never reach\r\n+\twhile (1) {\r\n+\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n+\t}\r\n+}\r\n+\r\n+\r\n+void app_main(void)\r\n+{\r\n+\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n+\r\n+\tesp_vfs_spiffs_conf_t conf = {\r\n+\t\t.base_path = \"/spiffs\",\r\n+\t\t.partition_label = NULL,\r\n+\t\t.max_files = 12,\r\n+\t\t.format_if_mount_failed =true\r\n+\t};\r\n+\r\n+\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n+\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n+\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n+\r\n+\tif (ret != ESP_OK) {\r\n+\t\tif (ret == ESP_FAIL) {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n+\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n+\t\t} else {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n+\t\t}\r\n+\t\treturn;\r\n+\t}\r\n+\r\n+\tsize_t total = 0, used = 0;\r\n+\tret = esp_spiffs_info(NULL, &total,&used);\r\n+\tif (ret != ESP_OK) {\r\n+\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n+\t} else {\r\n+\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n+\t}\r\n+\r\n+\tSPIFFS_Directory(\"/spiffs/\");\r\n+\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n+}\r\n"
                },
                {
                    "date": 1731802426672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -315,12 +315,12 @@\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor=RED;\r\n-\tfor(int ypos=0;ypos<height;ypos=ypos+10) {\r\n-\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n-\t}\r\n-\r\n+for(int ypos=0; ypos<height; ypos=ypos+10) {\r\n+    lcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n+    vTaskDelay(1); // Yield after each line\r\n+}\r\n \tfor(int xpos=0;xpos<width;xpos=xpos+10) {\r\n \t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n \t}\r\n \r\n"
                },
                {
                    "date": 1731802441101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,1232 +10,8 @@\n #include \"esp_system.h\"\r\n #include \"esp_vfs.h\"\r\n #include \"esp_spiffs.h\"\r\n \r\n-#include \"st7789.h\"\r\n-#include \"fontx.h\"\r\n-#include \"bmpfile.h\"\r\n-#include \"decode_jpeg.h\"\r\n-#include \"decode_png.h\"\r\n-#include \"pngle.h\"\r\n-\r\n-#define INTERVAL 400\r\n-#define WAIT vTaskDelay(INTERVAL)\r\n-\r\n-static const char *TAG = \"ST7789\";\r\n-\r\n-static void SPIFFS_Directory(char * path) {\r\n-\tDIR* dir = opendir(path);\r\n-\tassert(dir != NULL);\r\n-\twhile (true) {\r\n-\t\tstruct dirent*pe = readdir(dir);\r\n-\t\tif (!pe) break;\r\n-\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n-\t}\r\n-\tclosedir(dir);\r\n-}\r\n-\r\n-// You have to set these CONFIG value using menuconfig.\r\n-#if 0\r\n-#define CONFIG_WIDTH  240\r\n-#define CONFIG_HEIGHT 240\r\n-#define CONFIG_MOSI_GPIO 23\r\n-#define CONFIG_SCLK_GPIO 18\r\n-#define CONFIG_CS_GPIO -1\r\n-#define CONFIG_DC_GPIO 19\r\n-#define CONFIG_RESET_GPIO 15\r\n-#define CONFIG_BL_GPIO -1\r\n-#endif\r\n-\r\n-TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdFillScreen(dev, RED);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, GREEN);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, BLUE);\r\n-\tvTaskDelay(50);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tif (width < height) {\r\n-\t\tuint16_t y1,y2;\r\n-\t\ty1 = height/3;\r\n-\t\ty2 = (height/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n-\t} else {\r\n-\t\tuint16_t x1,x2;\r\n-\t\tx1 = width/3;\r\n-\t\tx2 = (width/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\t\r\n-\tuint16_t xpos;\r\n-\tuint16_t ypos;\r\n-\tint\tstlen;\r\n-\tuint8_t ascii[24];\r\n-\tuint16_t color;\r\n-\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\tstrcpy((char *)ascii, \"ST7789\");\r\n-\tif (width < height) {\r\n-\t\txpos = ((width - fontHeight) / 2) - 1;\r\n-\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n-\t} else {\r\n-\t\typos = ((height - fontHeight) / 2) - 1;\r\n-\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n-\t}\r\n-\tcolor = WHITE;\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcolor = RED;\r\n-\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n-\tstrcpy((char *)ascii, \"0,0\");\r\n-\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n-\r\n-\tcolor = GREEN;\r\n-\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,0\");\r\n-\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n-\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n-\r\n-\tcolor = GRAY;\r\n-\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n-\t//strcpy((char *)ascii, \"0,159\");\r\n-\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n-\typos = (height-11) - (fontHeight) + 5;\r\n-\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,159\");\r\n-\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n-\r\n-\tcolor = CYAN;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n-\r\n-\tcolor = GREEN;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor=RED;\r\n-for(int ypos=0; ypos<height; ypos=ypos+10) {\r\n-    lcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n-    vTaskDelay(1); // Yield after each line\r\n-}\r\n-\tfor(int xpos=0;xpos<width;xpos=xpos+10) {\r\n-\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\tfor(int i=5;i<height;i=i+5) {\r\n-\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 0.5;\r\n-\tint angle;\r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t}\r\n-\r\n-\tfor(angle=0;angle<=180;angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 1.0;\r\n-\tint angle;\r\n-\r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t}\r\n-\r\n-\tfor(angle=0;angle<=360;angle=angle+30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tuint16_t limit = width;\r\n-\tif (width > height) limit = height;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = BLUE;\r\n-\tfor(int i=5;i<limit;i=i+5) {\r\n-\t\tif (i > (limit-i-1) ) break;\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n-\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, CYAN);\r\n-\r\n-\tuint16_t red;\r\n-\tuint16_t green;\r\n-\tuint16_t blue;\r\n-\tsrand( (unsigned int)time( NULL ) );\r\n-\tfor(int i=1;i<100;i++) {\r\n-\t\tred=rand()%255;\r\n-\t\tgreen=rand()%255;\r\n-\t\tblue=rand()%255;\r\n-\t\tcolor=rgb565_conv(red, green, blue);\r\n-\t\tuint16_t xpos=rand()%width;\r\n-\t\tuint16_t ypos=rand()%height;\r\n-\t\tuint16_t size=rand()%(width/5);\r\n-\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, WHITE);\r\n-\tcolor = RED;\r\n-\tuint16_t delta = height/16;\r\n-\tuint16_t ypos = 0;\r\n-\tfor(int i=0;i<16;i++) {\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n-\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n-\t\tcolor = color >> 1;\r\n-\t\typos = ypos + delta;\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-#define BUFFPIXEL 20\r\n-\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n-\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n-\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n-\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n-\t\t\t\t}\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n-\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n-\r\n-\t\tint debug = 0; // number of logging output\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n-\t\t\tint buffidx = 0;\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\r\n-\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tuint8_t mask = 0x80;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tcolors[index] = BLACK;\r\n-\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n-\t\t\t\tindex++;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t\tif (mask == 0x00) {\r\n-\t\t\t\t\tbuffidx++;\r\n-\t\t\t\t\tmask = 0x80;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\tdebug--;\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(sdbuffer);\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-\r\n-TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\r\n-\tpixel_jpeg **pixels;\r\n-\tint imageWidth;\r\n-\tint imageHeight;\r\n-\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n-\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n-\tif (err == ESP_OK) {\r\n-\r\n-\t\tuint16_t _width = width;\r\n-\t\tuint16_t _cols = 0;\r\n-\t\tif (width > imageWidth) {\r\n-\t\t\t_width = imageWidth;\r\n-\t\t\t_cols = (width - imageWidth) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\t\tuint16_t _height = height;\r\n-\t\tuint16_t _rows = 0;\r\n-\t\tif (height > imageHeight) {\r\n-\t\t\t_height = imageHeight;\r\n-\t\t\t_rows = (height - imageHeight) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t\t}\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-#endif\r\n-\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tcolors[x] = pixels[y][x];\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tfree(colors);\r\n-\t\trelease_image(&pixels, width, height);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n-\t} else {\r\n-\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open PNG file\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tchar buf[1024];\r\n-\tsize_t remain = 0;\r\n-\tint len;\r\n-\r\n-\tpngle_t *pngle = pngle_new(width, height);\r\n-\r\n-\tpngle_set_init_callback(pngle, png_init);\r\n-\tpngle_set_draw_callback(pngle, png_draw);\r\n-\tpngle_set_done_callback(pngle, png_finish);\r\n-\r\n-\tdouble display_gamma = 2.2;\r\n-\tpngle_set_display_gamma(pngle, display_gamma);\r\n-\r\n-\r\n-\twhile (!feof(fp)) {\r\n-\t\tif (remain >= sizeof(buf)) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n-\t\tif (len <= 0) {\r\n-\t\t\t//printf(\"EOF\\n\");\r\n-\t\t\tbreak;\r\n-\t\t}\r\n-\r\n-\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n-\t\tif (fed < 0) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tremain = remain + len - fed;\r\n-\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n-\t}\r\n-\r\n-\tfclose(fp);\r\n-\r\n-\tuint16_t _width = width;\r\n-\tuint16_t _cols = 0;\r\n-\tif (width > pngle->imageWidth) {\r\n-\t\t_width = pngle->imageWidth;\r\n-\t\t_cols = (width - pngle->imageWidth) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\tuint16_t _height = height;\r\n-\tuint16_t _rows = 0;\r\n-\tif (height > pngle->imageHeight) {\r\n-\t\t\t_height = pngle->imageHeight;\r\n-\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t}\r\n-\t}\r\n-#endif\r\n-\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tcolors[x] = pngle->pixels[y][x];\r\n-\t\t}\r\n-\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\tfree(colors);\r\n-\tpngle_destroy(pngle, width, height);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\tuint8_t xmoji = width / fontWidth;\r\n-\tuint8_t ymoji = height / fontHeight;\r\n-\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t code;\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcode = 0xA0;\r\n-\tfor(int y=0;y<ymoji;y++) {\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n-\t\tfor(int x=0;x<xmoji;x++) {\r\n-\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n-\t\t\tif (code == 0xFF) break;\r\n-\t\t\tcode++;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-void ST7789(void *pvParameters)\r\n-{\r\n-\t// set font file\r\n-\tFontxFile fx16G[2];\r\n-\tFontxFile fx24G[2];\r\n-\tFontxFile fx32G[2];\r\n-\tFontxFile fx32L[2];\r\n-\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n-\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n-\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n-\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n-\r\n-\tFontxFile fx16M[2];\r\n-\tFontxFile fx24M[2];\r\n-\tFontxFile fx32M[2];\r\n-\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n-\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n-\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n-\t\r\n-\tTFT_t dev;\r\n-\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n-\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n-\r\n-#if CONFIG_INVERSION\r\n-\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n-\tlcdInversionOn(&dev);\r\n-#endif\r\n-\r\n-#if 0\r\n-\twhile (1) {\r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-#endif\r\n-\t}\r\n-#endif\r\n-\r\n-#if 0\r\n-\t//for TEST\r\n-\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n-\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n-\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n-#endif\r\n-\r\n-\twhile(1) {\r\n-\r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n-\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-#endif\r\n-\r\n-\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n-\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\t// Multi Font Test\r\n-\t\tuint16_t color;\r\n-\t\tuint8_t ascii[40];\r\n-\t\tuint16_t margin = 10;\r\n-\t\tlcdFillScreen(&dev, BLACK);\r\n-\t\tcolor = WHITE;\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos = 15;\r\n-\t\tint xd = 0;\r\n-\t\tint yd = 1;\r\n-\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n-\t\t\tlcdSetFontDirection(&dev, 1);\r\n-\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n-\t\t\typos = 0;\r\n-\t\t\txd = 1;\r\n-\t\t\tyd = 0;\r\n-\t\t}\r\n-\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n-\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n-\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n-\t\t}\r\n-\r\n-\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n-\t\typos = ypos + (10 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n-\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n-\t\t}\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tWAIT;\r\n-\r\n-\t} // end while\r\n-\r\n-\t// never reach\r\n-\twhile (1) {\r\n-\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n-\t}\r\n-}\r\n-\r\n-\r\n-void app_main(void)\r\n-{\r\n-\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n-\r\n-\tesp_vfs_spiffs_conf_t conf = {\r\n-\t\t.base_path = \"/spiffs\",\r\n-\t\t.partition_label = NULL,\r\n-\t\t.max_files = 12,\r\n-\t\t.format_if_mount_failed =true\r\n-\t};\r\n-\r\n-\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n-\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n-\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n-\r\n-\tif (ret != ESP_OK) {\r\n-\t\tif (ret == ESP_FAIL) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n-\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n-\t\t} else {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n-\t\t}\r\n-\t\treturn;\r\n-\t}\r\n-\r\n-\tsize_t total = 0, used = 0;\r\n-\tret = esp_spiffs_info(NULL, &total,&used);\r\n-\tif (ret != ESP_OK) {\r\n-\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n-\t} else {\r\n-\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n-\t}\r\n-\r\n-\tSPIFFS_Directory(\"/spiffs/\");\r\n-\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n-}\r\n-#include <stdio.h>\r\n-#include <stdlib.h>\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-#include \"esp_err.h\"\r\n-#include \"esp_log.h\"\r\n-#include \"esp_system.h\"\r\n-#include \"esp_vfs.h\"\r\n-#include \"esp_spiffs.h\"\r\n-\r\n // Replace deprecated header\r\n #include <miniz.h>  // Use the updated standalone miniz.h\r\n \r\n #include \"st7789.h\"\r\n@@ -1539,16 +315,17 @@\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor=RED;\r\n-\tfor(int ypos=0;ypos<height;ypos=ypos+10) {\r\n+\tfor(int ypos=0; ypos<height; ypos=ypos+10) {\r\n \t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n+\t\tvTaskDelay(1); // Yield after each line\r\n \t}\r\n+for(int xpos=0; xpos<width; xpos=xpos+10) {\r\n+    lcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n+    vTaskDelay(1); // Yield after each line\r\n+}\r\n \r\n-\tfor(int xpos=0;xpos<width;xpos=xpos+10) {\r\n-\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n-\t}\r\n-\r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n \tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n"
                },
                {
                    "date": 1731802456267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -342,8 +342,9 @@\n \tuint16_t xpos = width/2;\r\n \tuint16_t ypos = height/2;\r\n \tfor(int i=5;i<height;i=i+5) {\r\n \t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n"
                },
                {
                    "date": 1731802472999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1231 @@\n+#include <stdio.h>\r\n+#include <stdlib.h>\r\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+#include \"esp_err.h\"\r\n+#include \"esp_log.h\"\r\n+#include \"esp_system.h\"\r\n+#include \"esp_vfs.h\"\r\n+#include \"esp_spiffs.h\"\r\n+\r\n+// Replace deprecated header\r\n+#include <miniz.h>  // Use the updated standalone miniz.h\r\n+\r\n+#include \"st7789.h\"\r\n+#include \"fontx.h\"\r\n+#include \"bmpfile.h\"\r\n+#include \"decode_jpeg.h\"\r\n+#include \"decode_png.h\"\r\n+#include \"pngle.h\"\r\n+\r\n+\r\n+#define INTERVAL 400\r\n+#define WAIT vTaskDelay(INTERVAL)\r\n+\r\n+static const char *TAG = \"ST7789\";\r\n+\r\n+static void SPIFFS_Directory(char * path) {\r\n+\tDIR* dir = opendir(path);\r\n+\tassert(dir != NULL);\r\n+\twhile (true) {\r\n+\t\tstruct dirent*pe = readdir(dir);\r\n+\t\tif (!pe) break;\r\n+\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n+\t}\r\n+\tclosedir(dir);\r\n+}\r\n+\r\n+// You have to set these CONFIG value using menuconfig.\r\n+#if 0\r\n+#define CONFIG_WIDTH  240\r\n+#define CONFIG_HEIGHT 240\r\n+#define CONFIG_MOSI_GPIO 23\r\n+#define CONFIG_SCLK_GPIO 18\r\n+#define CONFIG_CS_GPIO -1\r\n+#define CONFIG_DC_GPIO 19\r\n+#define CONFIG_RESET_GPIO 15\r\n+#define CONFIG_BL_GPIO -1\r\n+#endif\r\n+\r\n+TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdFillScreen(dev, RED);\r\n+\tvTaskDelay(50);\r\n+\tlcdFillScreen(dev, GREEN);\r\n+\tvTaskDelay(50);\r\n+\tlcdFillScreen(dev, BLUE);\r\n+\tvTaskDelay(50);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tif (width < height) {\r\n+\t\tuint16_t y1,y2;\r\n+\t\ty1 = height/3;\r\n+\t\ty2 = (height/3)*2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n+\t} else {\r\n+\t\tuint16_t x1,x2;\r\n+\t\tx1 = width/3;\r\n+\t\tx2 = (width/3)*2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n+\t\tvTaskDelay(1);\r\n+\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\t\r\n+\tuint16_t xpos;\r\n+\tuint16_t ypos;\r\n+\tint\tstlen;\r\n+\tuint8_t ascii[24];\r\n+\tuint16_t color;\r\n+\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\tstrcpy((char *)ascii, \"ST7789\");\r\n+\tif (width < height) {\r\n+\t\txpos = ((width - fontHeight) / 2) - 1;\r\n+\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n+\t} else {\r\n+\t\typos = ((height - fontHeight) / 2) - 1;\r\n+\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n+\t}\r\n+\tcolor = WHITE;\r\n+\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcolor = RED;\r\n+\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n+\tstrcpy((char *)ascii, \"0,0\");\r\n+\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n+\r\n+\tcolor = GREEN;\r\n+\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n+\t//strcpy((char *)ascii, \"79,0\");\r\n+\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n+\tstlen = strlen((char *)ascii);\r\n+\txpos = (width-1) - (fontWidth*stlen);\r\n+\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n+\r\n+\tcolor = GRAY;\r\n+\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n+\t//strcpy((char *)ascii, \"0,159\");\r\n+\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n+\typos = (height-11) - (fontHeight) + 5;\r\n+\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n+\t//strcpy((char *)ascii, \"79,159\");\r\n+\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n+\tstlen = strlen((char *)ascii);\r\n+\txpos = (width-1) - (fontWidth*stlen);\r\n+\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=0\");\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=2\");\r\n+\tlcdSetFontDirection(dev, 2);\r\n+\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n+\r\n+\tcolor = CYAN;\r\n+\tstrcpy((char *)ascii, \"Direction=1\");\r\n+\tlcdSetFontDirection(dev, 1);\r\n+\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n+\r\n+\tcolor = GREEN;\r\n+\tstrcpy((char *)ascii, \"Direction=3\");\r\n+\tlcdSetFontDirection(dev, 3);\r\n+\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=0\");\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, GREEN);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=2\");\r\n+\tlcdSetFontDirection(dev, 2);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, YELLOW);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t ascii[20];\r\n+\r\n+\tcolor = RED;\r\n+\tstrcpy((char *)ascii, \"Direction=1\");\r\n+\tlcdSetFontDirection(dev, 1);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, GREEN);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, RED);\r\n+\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tcolor = BLUE;\r\n+\tstrcpy((char *)ascii, \"Direction=3\");\r\n+\tlcdSetFontDirection(dev, 3);\r\n+\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tlcdSetFontFill(dev, YELLOW);\r\n+\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n+\tlcdSetFontUnderLine(dev, BLUE);\r\n+\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n+\tlcdUnsetFontFill(dev);\r\n+\tlcdUnsetFontUnderLine(dev);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor=RED;\r\n+\tfor(int ypos=0; ypos<height; ypos=ypos+10) {\r\n+\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n+\t\tvTaskDelay(1); // Yield after each line\r\n+\t}\r\n+\tfor(int xpos=0; xpos<width; xpos=xpos+10) {\r\n+\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n+\t\tvTaskDelay(1); // Yield after each line\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\tfor(int i=5;i<height;i=i+5) {\r\n+\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\r\n+\tuint16_t w = width * 0.6;\r\n+\tuint16_t h = w * 0.5;\r\n+\tint angle;\r\n+\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tusleep(10000);\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\r\n+\tfor(angle=0;angle<=180;angle=angle+30) {\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\r\n+\tuint16_t w = width * 0.6;\r\n+\tuint16_t h = w * 1.0;\r\n+\tint angle;\r\n+\r\n+\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tusleep(10000);\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t}\r\n+\r\n+\tfor(angle=0;angle<=360;angle=angle+30) {\r\n+\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tuint16_t limit = width;\r\n+\tif (width > height) limit = height;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = BLUE;\r\n+\tfor(int i=5;i<limit;i=i+5) {\r\n+\t\tif (i > (limit-i-1) ) break;\r\n+\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n+\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, CYAN);\r\n+\r\n+\tuint16_t red;\r\n+\tuint16_t green;\r\n+\tuint16_t blue;\r\n+\tsrand( (unsigned int)time( NULL ) );\r\n+\tfor(int i=1;i<100;i++) {\r\n+\t\tred=rand()%255;\r\n+\t\tgreen=rand()%255;\r\n+\t\tblue=rand()%255;\r\n+\t\tcolor=rgb565_conv(red, green, blue);\r\n+\t\tuint16_t xpos=rand()%width;\r\n+\t\tuint16_t ypos=rand()%height;\r\n+\t\tuint16_t size=rand()%(width/5);\r\n+\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, WHITE);\r\n+\tcolor = RED;\r\n+\tuint16_t delta = height/16;\r\n+\tuint16_t ypos = 0;\r\n+\tfor(int i=0;i<16;i++) {\r\n+\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n+\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n+\t\tcolor = color >> 1;\r\n+\t\typos = ypos + delta;\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+#define BUFFPIXEL 20\r\n+\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n+\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n+\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n+\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n+\t\t\t\t}\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n+\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n+\r\n+\t\tint debug = 0; // number of logging output\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n+\t\t\tint buffidx = 0;\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\r\n+\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tuint8_t mask = 0x80;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tcolors[index] = BLACK;\r\n+\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n+\t\t\t\tindex++;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t\tif (mask == 0x00) {\r\n+\t\t\t\t\tbuffidx++;\r\n+\t\t\t\t\tmask = 0x80;\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\tdebug--;\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(sdbuffer);\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+\r\n+TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\r\n+\tpixel_jpeg **pixels;\r\n+\tint imageWidth;\r\n+\tint imageHeight;\r\n+\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n+\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n+\tif (err == ESP_OK) {\r\n+\r\n+\t\tuint16_t _width = width;\r\n+\t\tuint16_t _cols = 0;\r\n+\t\tif (width > imageWidth) {\r\n+\t\t\t_width = imageWidth;\r\n+\t\t\t_cols = (width - imageWidth) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\t\tuint16_t _height = height;\r\n+\t\tuint16_t _rows = 0;\r\n+\t\tif (height > imageHeight) {\r\n+\t\t\t_height = imageHeight;\r\n+\t\t\t_rows = (height - imageHeight) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t\t}\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+#endif\r\n+\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tcolors[x] = pixels[y][x];\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tfree(colors);\r\n+\t\trelease_image(&pixels, width, height);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n+\t} else {\r\n+\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open PNG file\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tchar buf[1024];\r\n+\tsize_t remain = 0;\r\n+\tint len;\r\n+\r\n+\tpngle_t *pngle = pngle_new(width, height);\r\n+\r\n+\tpngle_set_init_callback(pngle, png_init);\r\n+\tpngle_set_draw_callback(pngle, png_draw);\r\n+\tpngle_set_done_callback(pngle, png_finish);\r\n+\r\n+\tdouble display_gamma = 2.2;\r\n+\tpngle_set_display_gamma(pngle, display_gamma);\r\n+\r\n+\r\n+\twhile (!feof(fp)) {\r\n+\t\tif (remain >= sizeof(buf)) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n+\t\tif (len <= 0) {\r\n+\t\t\t//printf(\"EOF\\n\");\r\n+\t\t\tbreak;\r\n+\t\t}\r\n+\r\n+\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n+\t\tif (fed < 0) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tremain = remain + len - fed;\r\n+\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n+\t}\r\n+\r\n+\tfclose(fp);\r\n+\r\n+\tuint16_t _width = width;\r\n+\tuint16_t _cols = 0;\r\n+\tif (width > pngle->imageWidth) {\r\n+\t\t_width = pngle->imageWidth;\r\n+\t\t_cols = (width - pngle->imageWidth) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\tuint16_t _height = height;\r\n+\tuint16_t _rows = 0;\r\n+\tif (height > pngle->imageHeight) {\r\n+\t\t\t_height = pngle->imageHeight;\r\n+\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t}\r\n+\t}\r\n+#endif\r\n+\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tcolors[x] = pngle->pixels[y][x];\r\n+\t\t}\r\n+\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\tfree(colors);\r\n+\tpngle_destroy(pngle, width, height);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\tuint8_t xmoji = width / fontWidth;\r\n+\tuint8_t ymoji = height / fontHeight;\r\n+\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t code;\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcode = 0xA0;\r\n+\tfor(int y=0;y<ymoji;y++) {\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n+\t\tfor(int x=0;x<xmoji;x++) {\r\n+\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n+\t\t\tif (code == 0xFF) break;\r\n+\t\t\tcode++;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+void ST7789(void *pvParameters)\r\n+{\r\n+\t// set font file\r\n+\tFontxFile fx16G[2];\r\n+\tFontxFile fx24G[2];\r\n+\tFontxFile fx32G[2];\r\n+\tFontxFile fx32L[2];\r\n+\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n+\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n+\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n+\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n+\r\n+\tFontxFile fx16M[2];\r\n+\tFontxFile fx24M[2];\r\n+\tFontxFile fx32M[2];\r\n+\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n+\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n+\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n+\t\r\n+\tTFT_t dev;\r\n+\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n+\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n+\r\n+#if CONFIG_INVERSION\r\n+\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n+\tlcdInversionOn(&dev);\r\n+#endif\r\n+\r\n+#if 0\r\n+\twhile (1) {\r\n+\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tchar file[32];\r\n+\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n+\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n+\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n+\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+#endif\r\n+\t}\r\n+#endif\r\n+\r\n+#if 0\r\n+\t//for TEST\r\n+\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n+\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n+\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n+#endif\r\n+\r\n+\twhile(1) {\r\n+\r\n+\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t} else {\r\n+\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\t}\r\n+\t\tWAIT;\r\n+\r\n+\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tchar file[32];\r\n+\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n+\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n+\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n+\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+#endif\r\n+\r\n+\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n+\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n+\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+\t\tWAIT;\r\n+\r\n+\t\t// Multi Font Test\r\n+\t\tuint16_t color;\r\n+\t\tuint8_t ascii[40];\r\n+\t\tuint16_t margin = 10;\r\n+\t\tlcdFillScreen(&dev, BLACK);\r\n+\t\tcolor = WHITE;\r\n+\t\tlcdSetFontDirection(&dev, 0);\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos = 15;\r\n+\t\tint xd = 0;\r\n+\t\tint yd = 1;\r\n+\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n+\t\t\tlcdSetFontDirection(&dev, 1);\r\n+\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n+\t\t\typos = 0;\r\n+\t\t\txd = 1;\r\n+\t\t\tyd = 0;\r\n+\t\t}\r\n+\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n+\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n+\t\typos = ypos + (16 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n+\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n+\t\typos = ypos + (24 * yd) + (margin * yd);\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n+\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n+\t\t}\r\n+\r\n+\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n+\t\typos = ypos + (10 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n+\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n+\r\n+\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n+\t\typos = ypos + (16 * yd) + (margin * yd);\r\n+\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n+\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n+\r\n+\t\tif (CONFIG_WIDTH >= 240) {\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n+\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n+\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n+\t\t}\r\n+\t\tlcdSetFontDirection(&dev, 0);\r\n+\t\tWAIT;\r\n+\r\n+\t} // end while\r\n+\r\n+\t// never reach\r\n+\twhile (1) {\r\n+\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n+\t}\r\n+}\r\n+\r\n+\r\n+void app_main(void)\r\n+{\r\n+\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n+\r\n+\tesp_vfs_spiffs_conf_t conf = {\r\n+\t\t.base_path = \"/spiffs\",\r\n+\t\t.partition_label = NULL,\r\n+\t\t.max_files = 12,\r\n+\t\t.format_if_mount_failed =true\r\n+\t};\r\n+\r\n+\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n+\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n+\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n+\r\n+\tif (ret != ESP_OK) {\r\n+\t\tif (ret == ESP_FAIL) {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n+\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n+\t\t} else {\r\n+\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n+\t\t}\r\n+\t\treturn;\r\n+\t}\r\n+\r\n+\tsize_t total = 0, used = 0;\r\n+\tret = esp_spiffs_info(NULL, &total,&used);\r\n+\tif (ret != ESP_OK) {\r\n+\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n+\t} else {\r\n+\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n+\t}\r\n+\r\n+\tSPIFFS_Directory(\"/spiffs/\");\r\n+\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n+}\r\n"
                },
                {
                    "date": 1731802482120,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -402,8 +402,9 @@\n \tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tusleep(10000);\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tfor(angle=0;angle<=360;angle=angle+30) {\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n"
                },
                {
                    "date": 1731802490847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -431,8 +431,9 @@\n \tfor(int i=5;i<limit;i=i+5) {\r\n \t\tif (i > (limit-i-1) ) break;\r\n \t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n \t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n"
                },
                {
                    "date": 1731802497055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -460,8 +460,9 @@\n \t\tuint16_t xpos=rand()%width;\r\n \t\tuint16_t ypos=rand()%height;\r\n \t\tuint16_t size=rand()%(width/5);\r\n \t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n"
                },
                {
                    "date": 1731802503710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -483,8 +483,9 @@\n \t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n \t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n \t\tcolor = color >> 1;\r\n \t\typos = ypos + delta;\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n"
                },
                {
                    "date": 1731805445878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,19 +37,8 @@\n \t}\r\n \tclosedir(dir);\r\n }\r\n \r\n-// You have to set these CONFIG value using menuconfig.\r\n-#if 0\r\n-#define CONFIG_WIDTH  240\r\n-#define CONFIG_HEIGHT 240\r\n-#define CONFIG_MOSI_GPIO 23\r\n-#define CONFIG_SCLK_GPIO 18\r\n-#define CONFIG_CS_GPIO -1\r\n-#define CONFIG_DC_GPIO 19\r\n-#define CONFIG_RESET_GPIO 15\r\n-#define CONFIG_BL_GPIO -1\r\n-#endif\r\n \r\n TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n"
                },
                {
                    "date": 1731805937890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -345,26 +345,21 @@\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n \tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\r\n \tuint16_t w = width * 0.6;\r\n \tuint16_t h = w * 0.5;\r\n \tint angle;\r\n \tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, color);\r\n \t\tusleep(10000);\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, BLACK);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tfor(angle=0;angle<=180;angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, color);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n@@ -395,8 +390,9 @@\n \t}\r\n \r\n \tfor(angle=0;angle<=360;angle=angle+30) {\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+\t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n@@ -540,8 +536,9 @@\n \tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n \tassert(ret == 1);\r\n \r\n \tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n \t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n \t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n \t\tint w = result->dib.width;\r\n \t\tint h = result->dib.height;\r\n@@ -582,14 +579,8 @@\n \t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n \r\n \t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n \t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n \t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n \t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n \t\t\tfseek(fp, pos, SEEK_SET);\r\n \t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n@@ -607,9 +598,8 @@\n \t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n \t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n \t\t\t} // end for col\r\n \t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n \t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n \t\t\t_y++;\r\n \t\t} // end for row\r\n \t\tfree(colors);\r\n@@ -684,11 +674,10 @@\n \r\n \tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n \t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n \tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n \t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n \t\tint w = result->dib.width;\r\n \t\tint h = result->dib.height;\r\n \t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n \t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n@@ -728,14 +717,8 @@\n \r\n \t\tint debug = 0; // number of logging output\r\n \t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n \t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n \t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n \t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n \t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n \t\t\tfseek(fp, pos, SEEK_SET);\r\n@@ -1011,9 +994,11 @@\n \tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n \t\r\n \tTFT_t dev;\r\n \tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n+\tESP_LOGI(TAG, \"SPI Master initialized\");\r\n \tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n+\tESP_LOGI(TAG, \"LCD Initialized\");\r\n \r\n #if CONFIG_INVERSION\r\n \tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n \tlcdInversionOn(&dev);\r\n@@ -1221,1234 +1206,4 @@\n \r\n \tSPIFFS_Directory(\"/spiffs/\");\r\n \txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n }\r\n-#include <stdio.h>\r\n-#include <stdlib.h>\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-#include \"esp_err.h\"\r\n-#include \"esp_log.h\"\r\n-#include \"esp_system.h\"\r\n-#include \"esp_vfs.h\"\r\n-#include \"esp_spiffs.h\"\r\n-\r\n-// Replace deprecated header\r\n-#include <miniz.h>  // Use the updated standalone miniz.h\r\n-\r\n-#include \"st7789.h\"\r\n-#include \"fontx.h\"\r\n-#include \"bmpfile.h\"\r\n-#include \"decode_jpeg.h\"\r\n-#include \"decode_png.h\"\r\n-#include \"pngle.h\"\r\n-\r\n-\r\n-#define INTERVAL 400\r\n-#define WAIT vTaskDelay(INTERVAL)\r\n-\r\n-static const char *TAG = \"ST7789\";\r\n-\r\n-static void SPIFFS_Directory(char * path) {\r\n-\tDIR* dir = opendir(path);\r\n-\tassert(dir != NULL);\r\n-\twhile (true) {\r\n-\t\tstruct dirent*pe = readdir(dir);\r\n-\t\tif (!pe) break;\r\n-\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n-\t}\r\n-\tclosedir(dir);\r\n-}\r\n-\r\n-// You have to set these CONFIG value using menuconfig.\r\n-#if 0\r\n-#define CONFIG_WIDTH  240\r\n-#define CONFIG_HEIGHT 240\r\n-#define CONFIG_MOSI_GPIO 23\r\n-#define CONFIG_SCLK_GPIO 18\r\n-#define CONFIG_CS_GPIO -1\r\n-#define CONFIG_DC_GPIO 19\r\n-#define CONFIG_RESET_GPIO 15\r\n-#define CONFIG_BL_GPIO -1\r\n-#endif\r\n-\r\n-TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdFillScreen(dev, RED);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, GREEN);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, BLUE);\r\n-\tvTaskDelay(50);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tif (width < height) {\r\n-\t\tuint16_t y1,y2;\r\n-\t\ty1 = height/3;\r\n-\t\ty2 = (height/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n-\t} else {\r\n-\t\tuint16_t x1,x2;\r\n-\t\tx1 = width/3;\r\n-\t\tx2 = (width/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\t\r\n-\tuint16_t xpos;\r\n-\tuint16_t ypos;\r\n-\tint\tstlen;\r\n-\tuint8_t ascii[24];\r\n-\tuint16_t color;\r\n-\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\tstrcpy((char *)ascii, \"ST7789\");\r\n-\tif (width < height) {\r\n-\t\txpos = ((width - fontHeight) / 2) - 1;\r\n-\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n-\t} else {\r\n-\t\typos = ((height - fontHeight) / 2) - 1;\r\n-\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n-\t}\r\n-\tcolor = WHITE;\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcolor = RED;\r\n-\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n-\tstrcpy((char *)ascii, \"0,0\");\r\n-\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n-\r\n-\tcolor = GREEN;\r\n-\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,0\");\r\n-\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n-\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n-\r\n-\tcolor = GRAY;\r\n-\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n-\t//strcpy((char *)ascii, \"0,159\");\r\n-\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n-\typos = (height-11) - (fontHeight) + 5;\r\n-\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,159\");\r\n-\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n-\r\n-\tcolor = CYAN;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n-\r\n-\tcolor = GREEN;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n-\r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor=RED;\r\n-\tfor(int ypos=0; ypos<height; ypos=ypos+10) {\r\n-\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n-\t\tvTaskDelay(1); // Yield after each line\r\n-\t}\r\n-for(int xpos=0; xpos<width; xpos=xpos+10) {\r\n-    lcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n-    vTaskDelay(1); // Yield after each line\r\n-}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\tfor(int i=5;i<height;i=i+5) {\r\n-\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 0.5;\r\n-\tint angle;\r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t}\r\n-\r\n-\tfor(angle=0;angle<=180;angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 1.0;\r\n-\tint angle;\r\n-\r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t}\r\n-\r\n-\tfor(angle=0;angle<=360;angle=angle+30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tuint16_t limit = width;\r\n-\tif (width > height) limit = height;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = BLUE;\r\n-\tfor(int i=5;i<limit;i=i+5) {\r\n-\t\tif (i > (limit-i-1) ) break;\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n-\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, CYAN);\r\n-\r\n-\tuint16_t red;\r\n-\tuint16_t green;\r\n-\tuint16_t blue;\r\n-\tsrand( (unsigned int)time( NULL ) );\r\n-\tfor(int i=1;i<100;i++) {\r\n-\t\tred=rand()%255;\r\n-\t\tgreen=rand()%255;\r\n-\t\tblue=rand()%255;\r\n-\t\tcolor=rgb565_conv(red, green, blue);\r\n-\t\tuint16_t xpos=rand()%width;\r\n-\t\tuint16_t ypos=rand()%height;\r\n-\t\tuint16_t size=rand()%(width/5);\r\n-\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, WHITE);\r\n-\tcolor = RED;\r\n-\tuint16_t delta = height/16;\r\n-\tuint16_t ypos = 0;\r\n-\tfor(int i=0;i<16;i++) {\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n-\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n-\t\tcolor = color >> 1;\r\n-\t\typos = ypos + delta;\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-#define BUFFPIXEL 20\r\n-\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n-\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n-\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n-\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n-\t\t\t\t}\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n-\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n-\r\n-\t\tint debug = 0; // number of logging output\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n-\t\t\tint buffidx = 0;\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\r\n-\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tuint8_t mask = 0x80;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tcolors[index] = BLACK;\r\n-\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n-\t\t\t\tindex++;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t\tif (mask == 0x00) {\r\n-\t\t\t\t\tbuffidx++;\r\n-\t\t\t\t\tmask = 0x80;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\tdebug--;\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(sdbuffer);\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-\r\n-TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\r\n-\tpixel_jpeg **pixels;\r\n-\tint imageWidth;\r\n-\tint imageHeight;\r\n-\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n-\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n-\tif (err == ESP_OK) {\r\n-\r\n-\t\tuint16_t _width = width;\r\n-\t\tuint16_t _cols = 0;\r\n-\t\tif (width > imageWidth) {\r\n-\t\t\t_width = imageWidth;\r\n-\t\t\t_cols = (width - imageWidth) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\t\tuint16_t _height = height;\r\n-\t\tuint16_t _rows = 0;\r\n-\t\tif (height > imageHeight) {\r\n-\t\t\t_height = imageHeight;\r\n-\t\t\t_rows = (height - imageHeight) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t\t}\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-#endif\r\n-\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tcolors[x] = pixels[y][x];\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tfree(colors);\r\n-\t\trelease_image(&pixels, width, height);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n-\t} else {\r\n-\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open PNG file\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tchar buf[1024];\r\n-\tsize_t remain = 0;\r\n-\tint len;\r\n-\r\n-\tpngle_t *pngle = pngle_new(width, height);\r\n-\r\n-\tpngle_set_init_callback(pngle, png_init);\r\n-\tpngle_set_draw_callback(pngle, png_draw);\r\n-\tpngle_set_done_callback(pngle, png_finish);\r\n-\r\n-\tdouble display_gamma = 2.2;\r\n-\tpngle_set_display_gamma(pngle, display_gamma);\r\n-\r\n-\r\n-\twhile (!feof(fp)) {\r\n-\t\tif (remain >= sizeof(buf)) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n-\t\tif (len <= 0) {\r\n-\t\t\t//printf(\"EOF\\n\");\r\n-\t\t\tbreak;\r\n-\t\t}\r\n-\r\n-\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n-\t\tif (fed < 0) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tremain = remain + len - fed;\r\n-\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n-\t}\r\n-\r\n-\tfclose(fp);\r\n-\r\n-\tuint16_t _width = width;\r\n-\tuint16_t _cols = 0;\r\n-\tif (width > pngle->imageWidth) {\r\n-\t\t_width = pngle->imageWidth;\r\n-\t\t_cols = (width - pngle->imageWidth) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\tuint16_t _height = height;\r\n-\tuint16_t _rows = 0;\r\n-\tif (height > pngle->imageHeight) {\r\n-\t\t\t_height = pngle->imageHeight;\r\n-\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t}\r\n-\t}\r\n-#endif\r\n-\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tcolors[x] = pngle->pixels[y][x];\r\n-\t\t}\r\n-\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\tfree(colors);\r\n-\tpngle_destroy(pngle, width, height);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\tuint8_t xmoji = width / fontWidth;\r\n-\tuint8_t ymoji = height / fontHeight;\r\n-\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t code;\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcode = 0xA0;\r\n-\tfor(int y=0;y<ymoji;y++) {\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n-\t\tfor(int x=0;x<xmoji;x++) {\r\n-\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n-\t\t\tif (code == 0xFF) break;\r\n-\t\t\tcode++;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-void ST7789(void *pvParameters)\r\n-{\r\n-\t// set font file\r\n-\tFontxFile fx16G[2];\r\n-\tFontxFile fx24G[2];\r\n-\tFontxFile fx32G[2];\r\n-\tFontxFile fx32L[2];\r\n-\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n-\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n-\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n-\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n-\r\n-\tFontxFile fx16M[2];\r\n-\tFontxFile fx24M[2];\r\n-\tFontxFile fx32M[2];\r\n-\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n-\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n-\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n-\t\r\n-\tTFT_t dev;\r\n-\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n-\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n-\r\n-#if CONFIG_INVERSION\r\n-\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n-\tlcdInversionOn(&dev);\r\n-#endif\r\n-\r\n-#if 0\r\n-\twhile (1) {\r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-#endif\r\n-\t}\r\n-#endif\r\n-\r\n-#if 0\r\n-\t//for TEST\r\n-\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n-\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n-\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n-#endif\r\n-\r\n-\twhile(1) {\r\n-\r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n-\r\n-\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n-\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-#endif\r\n-\r\n-\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n-\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\t// Multi Font Test\r\n-\t\tuint16_t color;\r\n-\t\tuint8_t ascii[40];\r\n-\t\tuint16_t margin = 10;\r\n-\t\tlcdFillScreen(&dev, BLACK);\r\n-\t\tcolor = WHITE;\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos = 15;\r\n-\t\tint xd = 0;\r\n-\t\tint yd = 1;\r\n-\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n-\t\t\tlcdSetFontDirection(&dev, 1);\r\n-\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n-\t\t\typos = 0;\r\n-\t\t\txd = 1;\r\n-\t\t\tyd = 0;\r\n-\t\t}\r\n-\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n-\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n-\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n-\t\t}\r\n-\r\n-\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n-\t\typos = ypos + (10 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n-\r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n-\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n-\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n-\t\t}\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tWAIT;\r\n-\r\n-\t} // end while\r\n-\r\n-\t// never reach\r\n-\twhile (1) {\r\n-\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n-\t}\r\n-}\r\n-\r\n-\r\n-void app_main(void)\r\n-{\r\n-\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n-\r\n-\tesp_vfs_spiffs_conf_t conf = {\r\n-\t\t.base_path = \"/spiffs\",\r\n-\t\t.partition_label = NULL,\r\n-\t\t.max_files = 12,\r\n-\t\t.format_if_mount_failed =true\r\n-\t};\r\n-\r\n-\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n-\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n-\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n-\r\n-\tif (ret != ESP_OK) {\r\n-\t\tif (ret == ESP_FAIL) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n-\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n-\t\t} else {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n-\t\t}\r\n-\t\treturn;\r\n-\t}\r\n-\r\n-\tsize_t total = 0, used = 0;\r\n-\tret = esp_spiffs_info(NULL, &total,&used);\r\n-\tif (ret != ESP_OK) {\r\n-\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n-\t} else {\r\n-\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n-\t}\r\n-\r\n-\tSPIFFS_Directory(\"/spiffs/\");\r\n-\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n-}\r\n"
                },
                {
                    "date": 1731806316132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -345,8 +345,14 @@\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n \tuint16_t color;\r\n+\t//lcdFillScreen(dev, WHITE);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tcolor = CYAN;\r\n+\tuint16_t xpos = width/2;\r\n+\tuint16_t ypos = height/2;\r\n+\r\n \tuint16_t w = width * 0.6;\r\n \tuint16_t h = w * 0.5;\r\n \tint angle;\r\n \tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n"
                },
                {
                    "date": 1731806325970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -355,16 +355,16 @@\n \tuint16_t w = width * 0.6;\r\n \tuint16_t h = w * 0.5;\r\n \tint angle;\r\n \tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, color);\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tusleep(10000);\r\n-\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, BLACK);\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tfor(angle=0;angle<=180;angle=angle+30) {\r\n-\t\tlcdDrawRectAngle(dev, width/2, height/2, w, h, angle, color);\r\n+\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n@@ -585,8 +585,14 @@\n \t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n \r\n \t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n \t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n \t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n \t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n \t\t\tfseek(fp, pos, SEEK_SET);\r\n \t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n"
                },
                {
                    "date": 1731806348292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -687,8 +687,9 @@\n \tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n \t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n \tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n \t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n \t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n \t\tint w = result->dib.width;\r\n \t\tint h = result->dib.height;\r\n \t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n"
                },
                {
                    "date": 1731806355693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -686,10 +686,10 @@\n \r\n \tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n \t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n \tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n \t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n \t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n \t\tint w = result->dib.width;\r\n \t\tint h = result->dib.height;\r\n \t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n"
                },
                {
                    "date": 1731806365788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,8 +610,9 @@\n \t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n \t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n \t\t\t} // end for col\r\n \t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n \t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n \t\t\t_y++;\r\n \t\t} // end for row\r\n \t\tfree(colors);\r\n"
                },
                {
                    "date": 1731815831653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,33 +13,31 @@\n \r\n // Replace deprecated header\r\n #include <miniz.h>  // Use the updated standalone miniz.h\r\n \r\n-#include \"st7789.h\"\r\n+#include \"st7796s.h\"  // Updated to include the correct header file\r\n #include \"fontx.h\"\r\n #include \"bmpfile.h\"\r\n #include \"decode_jpeg.h\"\r\n #include \"decode_png.h\"\r\n #include \"pngle.h\"\r\n \r\n-\r\n #define INTERVAL 400\r\n #define WAIT vTaskDelay(INTERVAL)\r\n \r\n-static const char *TAG = \"ST7789\";\r\n+static const char *TAG = \"ST7796S\";  // Updated the logging tag\r\n \r\n static void SPIFFS_Directory(char * path) {\r\n \tDIR* dir = opendir(path);\r\n \tassert(dir != NULL);\r\n \twhile (true) {\r\n-\t\tstruct dirent*pe = readdir(dir);\r\n+\t\tstruct dirent* pe = readdir(dir);\r\n \t\tif (!pe) break;\r\n-\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n+\t\tESP_LOGI(__FUNCTION__, \"d_name=%s d_ino=%d d_type=%x\", pe->d_name, pe->d_ino, pe->d_type);\r\n \t}\r\n \tclosedir(dir);\r\n }\r\n \r\n-\r\n TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n@@ -51,39 +49,39 @@\n \tvTaskDelay(50);\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n \tif (width < height) {\r\n-\t\tuint16_t y1,y2;\r\n-\t\ty1 = height/3;\r\n-\t\ty2 = (height/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n+\t\tuint16_t y1, y2;\r\n+\t\ty1 = height / 3;\r\n+\t\ty2 = (height / 3) * 2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, width - 1, y1 - 1, RED);\r\n \t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n+\t\tlcdDrawFillRect(dev, 0, y1, width - 1, y2 - 1, GREEN);\r\n \t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n+\t\tlcdDrawFillRect(dev, 0, y2, width - 1, height - 1, BLUE);\r\n \t} else {\r\n-\t\tuint16_t x1,x2;\r\n-\t\tx1 = width/3;\r\n-\t\tx2 = (width/3)*2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n+\t\tuint16_t x1, x2;\r\n+\t\tx1 = width / 3;\r\n+\t\tx2 = (width / 3) * 2;\r\n+\t\tlcdDrawFillRect(dev, 0, 0, x1 - 1, height - 1, RED);\r\n \t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n+\t\tlcdDrawFillRect(dev, x1, 0, x2 - 1, height - 1, GREEN);\r\n \t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n+\t\tlcdDrawFillRect(dev, x2, 0, width - 1, height - 1, BLUE);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n@@ -95,18 +93,18 @@\n \tuint8_t fontWidth;\r\n \tuint8_t fontHeight;\r\n \tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n \t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\t\r\n+\r\n \tuint16_t xpos;\r\n \tuint16_t ypos;\r\n \tint\tstlen;\r\n \tuint8_t ascii[24];\r\n \tuint16_t color;\r\n \r\n \tlcdFillScreen(dev, BLACK);\r\n \r\n-\tstrcpy((char *)ascii, \"ST7789\");\r\n+\tstrcpy((char *)ascii, \"ST7796S\");  // Updated the display text\r\n \tif (width < height) {\r\n \t\txpos = ((width - fontHeight) / 2) - 1;\r\n \t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n \t\tlcdSetFontDirection(dev, DIRECTION90);\r\n@@ -124,33 +122,33 @@\n \tstrcpy((char *)ascii, \"0,0\");\r\n \tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n \r\n \tcolor = GREEN;\r\n-\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n+\tlcdDrawFillArrow(dev, width - 11, 10, width - 1, 0, 5, color);\r\n \t//strcpy((char *)ascii, \"79,0\");\r\n-\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n+\tsprintf((char *)ascii, \"%d,0\", width - 1);\r\n \tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n+\txpos = (width - 1) - (fontWidth * stlen);\r\n \tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n \r\n \tcolor = GRAY;\r\n-\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n+\tlcdDrawFillArrow(dev, 10, height - 11, 0, height - 1, 5, color);\r\n \t//strcpy((char *)ascii, \"0,159\");\r\n-\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n-\typos = (height-11) - (fontHeight) + 5;\r\n+\tsprintf((char *)ascii, \"0,%d\", height - 1);\r\n+\typos = (height - 11) - (fontHeight) + 5;\r\n \tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n \r\n \tcolor = CYAN;\r\n-\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n+\tlcdDrawFillArrow(dev, width - 11, height - 11, width - 1, height - 1, 5, color);\r\n \t//strcpy((char *)ascii, \"79,159\");\r\n-\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n+\tsprintf((char *)ascii, \"%d,%d\", width - 1, height - 1);\r\n \tstlen = strlen((char *)ascii);\r\n-\txpos = (width-1) - (fontWidth*stlen);\r\n+\txpos = (width - 1) - (fontWidth * stlen);\r\n \tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n@@ -170,28 +168,28 @@\n \r\n \tcolor = RED;\r\n \tstrcpy((char *)ascii, \"Direction=0\");\r\n \tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight - 1, ascii, color);\r\n \r\n \tcolor = BLUE;\r\n \tstrcpy((char *)ascii, \"Direction=2\");\r\n \tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n+\tlcdDrawString(dev, fx, (width - 1), (height - 1) - (fontHeight * 1), ascii, color);\r\n \r\n \tcolor = CYAN;\r\n \tstrcpy((char *)ascii, \"Direction=1\");\r\n \tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n+\tlcdDrawString(dev, fx, (width - 1) - fontHeight, 0, ascii, color);\r\n \r\n \tcolor = GREEN;\r\n \tstrcpy((char *)ascii, \"Direction=3\");\r\n \tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, (fontHeight - 1), height - 1, ascii, color);\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n@@ -211,38 +209,38 @@\n \r\n \tcolor = RED;\r\n \tstrcpy((char *)ascii, \"Direction=0\");\r\n \tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight * 1 - 1, ascii, color);\r\n \tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight * 2 - 1, ascii, color);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight * 3 - 1, ascii, color);\r\n \tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, 0, fontHeight * 4 - 1, ascii, color);\r\n \tlcdUnsetFontFill(dev);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tcolor = BLUE;\r\n \tstrcpy((char *)ascii, \"Direction=2\");\r\n \tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, width, height - (fontHeight * 1) - 1, ascii, color);\r\n \tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, width, height - (fontHeight * 2) - 1, ascii, color);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, width, height - (fontHeight * 3) - 1, ascii, color);\r\n \tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n+\tlcdDrawString(dev, fx, width, height - (fontHeight * 4) - 1, ascii, color);\r\n \tlcdUnsetFontFill(dev);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n@@ -262,62 +260,61 @@\n \r\n \tcolor = RED;\r\n \tstrcpy((char *)ascii, \"Direction=1\");\r\n \tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n+\tlcdDrawString(dev, fx, width - (fontHeight * 1), 0, ascii, color);\r\n \tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n+\tlcdDrawString(dev, fx, width - (fontHeight * 2), 0, ascii, color);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n+\tlcdDrawString(dev, fx, width - (fontHeight * 3), 0, ascii, color);\r\n \tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n+\tlcdDrawString(dev, fx, width - (fontHeight * 4), 0, ascii, color);\r\n \tlcdUnsetFontFill(dev);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tcolor = BLUE;\r\n \tstrcpy((char *)ascii, \"Direction=3\");\r\n \tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n+\tlcdDrawString(dev, fx, (fontHeight * 1) - 1, height, ascii, color);\r\n \tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n+\tlcdDrawString(dev, fx, (fontHeight * 2) - 1, height, ascii, color);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n+\tlcdDrawString(dev, fx, (fontHeight * 3) - 1, height, ascii, color);\r\n \tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n+\tlcdDrawString(dev, fx, (fontHeight * 4) - 1, height, ascii, color);\r\n \tlcdUnsetFontFill(dev);\r\n \tlcdUnsetFontUnderLine(dev);\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n-\r\n TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n-\tcolor=RED;\r\n-\tfor(int ypos=0; ypos<height; ypos=ypos+10) {\r\n+\tcolor = RED;\r\n+\tfor (int ypos = 0; ypos < height; ypos = ypos + 10) {\r\n \t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n \t\tvTaskDelay(1); // Yield after each line\r\n \t}\r\n-\tfor(int xpos=0; xpos<width; xpos=xpos+10) {\r\n+\tfor (int xpos = 0; xpos < width; xpos = xpos + 10) {\r\n \t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n \t\tvTaskDelay(1); // Yield after each line\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n@@ -327,18 +324,18 @@\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n-\tfor(int i=5;i<height;i=i+5) {\r\n+\tuint16_t xpos = width / 2;\r\n+\tuint16_t ypos = height / 2;\r\n+\tfor (int i = 5; i < height; i = i + 5) {\r\n \t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n@@ -348,29 +345,29 @@\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n+\tuint16_t xpos = width / 2;\r\n+\tuint16_t ypos = height / 2;\r\n \r\n \tuint16_t w = width * 0.6;\r\n \tuint16_t h = w * 0.5;\r\n \tint angle;\r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\tfor (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n \t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tusleep(10000);\r\n \t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n-\tfor(angle=0;angle<=180;angle=angle+30) {\r\n+\tfor (angle = 0; angle <= 180; angle = angle + 30) {\r\n \t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n@@ -380,634 +377,77 @@\n \tuint16_t color;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor = CYAN;\r\n-\tuint16_t xpos = width/2;\r\n-\tuint16_t ypos = height/2;\r\n+\tuint16_t xpos = width / 2;\r\n+\tuint16_t ypos = height / 2;\r\n \r\n \tuint16_t w = width * 0.6;\r\n \tuint16_t h = w * 1.0;\r\n \tint angle;\r\n \r\n-\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n+\tfor (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tusleep(10000);\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n-\tfor(angle=0;angle<=360;angle=angle+30) {\r\n+\tfor (angle = 0; angle <= 360; angle = angle + 30) {\r\n \t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n \tTickType_t startTick, endTick, diffTick;\r\n \tstartTick = xTaskGetTickCount();\r\n \r\n-\r\n \tuint16_t color;\r\n \tuint16_t limit = width;\r\n \tif (width > height) limit = height;\r\n \t//lcdFillScreen(dev, WHITE);\r\n \tlcdFillScreen(dev, BLACK);\r\n \tcolor = BLUE;\r\n-\tfor(int i=5;i<limit;i=i+5) {\r\n-\t\tif (i > (limit-i-1) ) break;\r\n+\tfor (int i = 5; i < limit; i = i + 5) {\r\n+\t\tif (i > (limit - i - 1)) break;\r\n \t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n-\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n+\t\tlcdDrawRoundRect(dev, i, i, (width - i - 1), (height - i - 1), 10, color);\r\n \t\tvTaskDelay(1);\r\n \t}\r\n \r\n \tendTick = xTaskGetTickCount();\r\n \tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n-TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+// ... (Remaining functions remain unchanged)\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, CYAN);\r\n-\r\n-\tuint16_t red;\r\n-\tuint16_t green;\r\n-\tuint16_t blue;\r\n-\tsrand( (unsigned int)time( NULL ) );\r\n-\tfor(int i=1;i<100;i++) {\r\n-\t\tred=rand()%255;\r\n-\t\tgreen=rand()%255;\r\n-\t\tblue=rand()%255;\r\n-\t\tcolor=rgb565_conv(red, green, blue);\r\n-\t\tuint16_t xpos=rand()%width;\r\n-\t\tuint16_t ypos=rand()%height;\r\n-\t\tuint16_t size=rand()%(width/5);\r\n-\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, WHITE);\r\n-\tcolor = RED;\r\n-\tuint16_t delta = height/16;\r\n-\tuint16_t ypos = 0;\r\n-\tfor(int i=0;i<16;i++) {\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n-\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n-\t\tcolor = color >> 1;\r\n-\t\typos = ypos + delta;\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-#define BUFFPIXEL 20\r\n-\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n-\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n-\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n-\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n-\t\t\t\t}\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n-\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n-\r\n-\t\tint debug = 0; // number of logging output\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n-\t\t\tint buffidx = 0;\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\r\n-\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tuint8_t mask = 0x80;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tcolors[index] = BLACK;\r\n-\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n-\t\t\t\tindex++;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t\tif (mask == 0x00) {\r\n-\t\t\t\t\tbuffidx++;\r\n-\t\t\t\t\tmask = 0x80;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\tdebug--;\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(sdbuffer);\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-\r\n-TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\r\n-\tpixel_jpeg **pixels;\r\n-\tint imageWidth;\r\n-\tint imageHeight;\r\n-\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n-\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n-\tif (err == ESP_OK) {\r\n-\r\n-\t\tuint16_t _width = width;\r\n-\t\tuint16_t _cols = 0;\r\n-\t\tif (width > imageWidth) {\r\n-\t\t\t_width = imageWidth;\r\n-\t\t\t_cols = (width - imageWidth) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\t\tuint16_t _height = height;\r\n-\t\tuint16_t _rows = 0;\r\n-\t\tif (height > imageHeight) {\r\n-\t\t\t_height = imageHeight;\r\n-\t\t\t_rows = (height - imageHeight) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t\t}\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-#endif\r\n-\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tcolors[x] = pixels[y][x];\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tfree(colors);\r\n-\t\trelease_image(&pixels, width, height);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n-\t} else {\r\n-\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open PNG file\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tchar buf[1024];\r\n-\tsize_t remain = 0;\r\n-\tint len;\r\n-\r\n-\tpngle_t *pngle = pngle_new(width, height);\r\n-\r\n-\tpngle_set_init_callback(pngle, png_init);\r\n-\tpngle_set_draw_callback(pngle, png_draw);\r\n-\tpngle_set_done_callback(pngle, png_finish);\r\n-\r\n-\tdouble display_gamma = 2.2;\r\n-\tpngle_set_display_gamma(pngle, display_gamma);\r\n-\r\n-\r\n-\twhile (!feof(fp)) {\r\n-\t\tif (remain >= sizeof(buf)) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n-\t\tif (len <= 0) {\r\n-\t\t\t//printf(\"EOF\\n\");\r\n-\t\t\tbreak;\r\n-\t\t}\r\n-\r\n-\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n-\t\tif (fed < 0) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tremain = remain + len - fed;\r\n-\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n-\t}\r\n-\r\n-\tfclose(fp);\r\n-\r\n-\tuint16_t _width = width;\r\n-\tuint16_t _cols = 0;\r\n-\tif (width > pngle->imageWidth) {\r\n-\t\t_width = pngle->imageWidth;\r\n-\t\t_cols = (width - pngle->imageWidth) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\tuint16_t _height = height;\r\n-\tuint16_t _rows = 0;\r\n-\tif (height > pngle->imageHeight) {\r\n-\t\t\t_height = pngle->imageHeight;\r\n-\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t}\r\n-\t}\r\n-#endif\r\n-\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tcolors[x] = pngle->pixels[y][x];\r\n-\t\t}\r\n-\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\tfree(colors);\r\n-\tpngle_destroy(pngle, width, height);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\tuint8_t xmoji = width / fontWidth;\r\n-\tuint8_t ymoji = height / fontHeight;\r\n-\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t code;\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcode = 0xA0;\r\n-\tfor(int y=0;y<ymoji;y++) {\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n-\t\tfor(int x=0;x<xmoji;x++) {\r\n-\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n-\t\t\tif (code == 0xFF) break;\r\n-\t\t\tcode++;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-void ST7789(void *pvParameters)\r\n+void ST7796S(void *pvParameters)  // Updated the function name\r\n {\r\n \t// set font file\r\n \tFontxFile fx16G[2];\r\n \tFontxFile fx24G[2];\r\n \tFontxFile fx32G[2];\r\n \tFontxFile fx32L[2];\r\n-\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n-\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n-\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n-\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n+\tInitFontx(fx16G, \"/spiffs/ILGH16XB.FNT\", \"\"); // 8x16Dot Gothic\r\n+\tInitFontx(fx24G, \"/spiffs/ILGH24XB.FNT\", \"\"); // 12x24Dot Gothic\r\n+\tInitFontx(fx32G, \"/spiffs/ILGH32XB.FNT\", \"\"); // 16x32Dot Gothic\r\n+\tInitFontx(fx32L, \"/spiffs/LATIN32B.FNT\", \"\"); // 16x32Dot Latin\r\n \r\n \tFontxFile fx16M[2];\r\n \tFontxFile fx24M[2];\r\n \tFontxFile fx32M[2];\r\n-\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n-\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n-\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n-\t\r\n+\tInitFontx(fx16M, \"/spiffs/ILMH16XB.FNT\", \"\"); // 8x16Dot Mincyo\r\n+\tInitFontx(fx24M, \"/spiffs/ILMH24XB.FNT\", \"\"); // 12x24Dot Mincyo\r\n+\tInitFontx(fx32M, \"/spiffs/ILMH32XB.FNT\", \"\"); // 16x32Dot Mincyo\r\n+\r\n \tTFT_t dev;\r\n \tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n \tESP_LOGI(TAG, \"SPI Master initialized\");\r\n \tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n@@ -1042,9 +482,9 @@\n \tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n \tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n #endif\r\n \r\n-\twhile(1) {\r\n+\twhile (1) {\r\n \r\n \t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n \t\tWAIT;\r\n \r\n@@ -1131,11 +571,11 @@\n \t\tuint16_t xpos = 0;\r\n \t\tuint16_t ypos = 15;\r\n \t\tint xd = 0;\r\n \t\tint yd = 1;\r\n-\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n+\t\tif (CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n \t\t\tlcdSetFontDirection(&dev, 1);\r\n-\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n+\t\t\txpos = (CONFIG_WIDTH - 1) - 16;\r\n \t\t\typos = 0;\r\n \t\t\txd = 1;\r\n \t\t\tyd = 0;\r\n \t\t}\r\n@@ -1151,24 +591,24 @@\n \t\typos = ypos + (24 * yd) + (margin * yd);\r\n \t\tif (CONFIG_WIDTH >= 240) {\r\n \t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n \t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n \t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n \t\t}\r\n \r\n \t\txpos = xpos - (10 * xd) - (margin * xd);\r\n \t\typos = ypos + (10 * yd) + (margin * yd);\r\n \t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n \t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n \r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n+\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n \t\typos = ypos + (16 * yd) + (margin * yd);\r\n \t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n \t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n \r\n \t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n+\t\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n \t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n \t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n \t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n \t\t}\r\n@@ -1182,42 +622,41 @@\n \t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n \t}\r\n }\r\n \r\n-\r\n void app_main(void)\r\n {\r\n \tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n \r\n \tesp_vfs_spiffs_conf_t conf = {\r\n \t\t.base_path = \"/spiffs\",\r\n \t\t.partition_label = NULL,\r\n \t\t.max_files = 12,\r\n-\t\t.format_if_mount_failed =true\r\n+\t\t.format_if_mount_failed = true\r\n \t};\r\n \r\n-\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n-\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n+\t// Use settings defined above to initialize and mount SPIFFS filesystem.\r\n+\t// Note: esp_vfs_spiffs_register is an all-in-one convenience function.\r\n \tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n \r\n \tif (ret != ESP_OK) {\r\n \t\tif (ret == ESP_FAIL) {\r\n \t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n \t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n \t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n \t\t} else {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n+\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\", esp_err_to_name(ret));\r\n \t\t}\r\n \t\treturn;\r\n \t}\r\n \r\n \tsize_t total = 0, used = 0;\r\n-\tret = esp_spiffs_info(NULL, &total,&used);\r\n+\tret = esp_spiffs_info(NULL, &total, &used);\r\n \tif (ret != ESP_OK) {\r\n-\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n+\t\tESP_LOGE(TAG, \"Failed to get SPIFFS partition information (%s)\", esp_err_to_name(ret));\r\n \t} else {\r\n-\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n+\t\tESP_LOGI(TAG, \"Partition size: total: %d, used: %d\", total, used);\r\n \t}\r\n \r\n \tSPIFFS_Directory(\"/spiffs/\");\r\n-\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n+\txTaskCreate(ST7796S, \"ST7796S\", 1024 * 6, NULL, 2, NULL);  // Updated the task creation\r\n }\r\n"
                },
                {
                    "date": 1731815850377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,11 +425,574 @@\n \tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n-// ... (Remaining functions remain unchanged)\r\n+TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n \r\n-void ST7796S(void *pvParameters)  // Updated the function name\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, CYAN);\r\n+\r\n+\tuint16_t red;\r\n+\tuint16_t green;\r\n+\tuint16_t blue;\r\n+\tsrand( (unsigned int)time( NULL ) );\r\n+\tfor(int i=1;i<100;i++) {\r\n+\t\tred=rand()%255;\r\n+\t\tgreen=rand()%255;\r\n+\t\tblue=rand()%255;\r\n+\t\tcolor=rgb565_conv(red, green, blue);\r\n+\t\tuint16_t xpos=rand()%width;\r\n+\t\tuint16_t ypos=rand()%height;\r\n+\t\tuint16_t size=rand()%(width/5);\r\n+\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, WHITE);\r\n+\tcolor = RED;\r\n+\tuint16_t delta = height/16;\r\n+\tuint16_t ypos = 0;\r\n+\tfor(int i=0;i<16;i++) {\r\n+\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n+\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n+\t\tcolor = color >> 1;\r\n+\t\typos = ypos + delta;\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+#define BUFFPIXEL 20\r\n+\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n+\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n+\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n+\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n+\t\t\t\t}\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n+\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n+\r\n+\t\tint debug = 0; // number of logging output\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n+\t\t\tint buffidx = 0;\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\r\n+\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tuint8_t mask = 0x80;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tcolors[index] = BLACK;\r\n+\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n+\t\t\t\tindex++;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t\tif (mask == 0x00) {\r\n+\t\t\t\t\tbuffidx++;\r\n+\t\t\t\t\tmask = 0x80;\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\tdebug--;\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(sdbuffer);\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+\r\n+TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\r\n+\tpixel_jpeg **pixels;\r\n+\tint imageWidth;\r\n+\tint imageHeight;\r\n+\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n+\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n+\tif (err == ESP_OK) {\r\n+\r\n+\t\tuint16_t _width = width;\r\n+\t\tuint16_t _cols = 0;\r\n+\t\tif (width > imageWidth) {\r\n+\t\t\t_width = imageWidth;\r\n+\t\t\t_cols = (width - imageWidth) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\t\tuint16_t _height = height;\r\n+\t\tuint16_t _rows = 0;\r\n+\t\tif (height > imageHeight) {\r\n+\t\t\t_height = imageHeight;\r\n+\t\t\t_rows = (height - imageHeight) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t\t}\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+#endif\r\n+\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tcolors[x] = pixels[y][x];\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tfree(colors);\r\n+\t\trelease_image(&pixels, width, height);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n+\t} else {\r\n+\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open PNG file\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tchar buf[1024];\r\n+\tsize_t remain = 0;\r\n+\tint len;\r\n+\r\n+\tpngle_t *pngle = pngle_new(width, height);\r\n+\r\n+\tpngle_set_init_callback(pngle, png_init);\r\n+\tpngle_set_draw_callback(pngle, png_draw);\r\n+\tpngle_set_done_callback(pngle, png_finish);\r\n+\r\n+\tdouble display_gamma = 2.2;\r\n+\tpngle_set_display_gamma(pngle, display_gamma);\r\n+\r\n+\r\n+\twhile (!feof(fp)) {\r\n+\t\tif (remain >= sizeof(buf)) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n+\t\tif (len <= 0) {\r\n+\t\t\t//printf(\"EOF\\n\");\r\n+\t\t\tbreak;\r\n+\t\t}\r\n+\r\n+\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n+\t\tif (fed < 0) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tremain = remain + len - fed;\r\n+\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n+\t}\r\n+\r\n+\tfclose(fp);\r\n+\r\n+\tuint16_t _width = width;\r\n+\tuint16_t _cols = 0;\r\n+\tif (width > pngle->imageWidth) {\r\n+\t\t_width = pngle->imageWidth;\r\n+\t\t_cols = (width - pngle->imageWidth) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\tuint16_t _height = height;\r\n+\tuint16_t _rows = 0;\r\n+\tif (height > pngle->imageHeight) {\r\n+\t\t\t_height = pngle->imageHeight;\r\n+\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t}\r\n+\t}\r\n+#endif\r\n+\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tcolors[x] = pngle->pixels[y][x];\r\n+\t\t}\r\n+\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\tfree(colors);\r\n+\tpngle_destroy(pngle, width, height);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\tuint8_t xmoji = width / fontWidth;\r\n+\tuint8_t ymoji = height / fontHeight;\r\n+\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t code;\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcode = 0xA0;\r\n+\tfor(int y=0;y<ymoji;y++) {\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n+\t\tfor(int x=0;x<xmoji;x++) {\r\n+\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n+\t\t\tif (code == 0xFF) break;\r\n+\t\t\tcode++;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+void ST7789(void *pvParameters)\r\n {\r\n \t// set font file\r\n \tFontxFile fx16G[2];\r\n \tFontxFile fx24G[2];\r\n"
                },
                {
                    "date": 1731816598524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -990,9 +990,9 @@\n \tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n \treturn diffTick;\r\n }\r\n \r\n-void ST7789(void *pvParameters)\r\n+void st7796s_task(void *pvParameters) \r\n {\r\n \t// set font file\r\n \tFontxFile fx16G[2];\r\n \tFontxFile fx24G[2];\r\n"
                },
                {
                    "date": 1731816637216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1220,6 +1220,6 @@\n \t\tESP_LOGI(TAG, \"Partition size: total: %d, used: %d\", total, used);\r\n \t}\r\n \r\n \tSPIFFS_Directory(\"/spiffs/\");\r\n-\txTaskCreate(ST7796S, \"ST7796S\", 1024 * 6, NULL, 2, NULL);  // Updated the task creation\r\n+\txTaskCreate(st7796s_task, \"ST7796S\", 1024 * 6, NULL, 2, NULL);  // Updated the task creation\r\n }\r\n"
                },
                {
                    "date": 1731817032504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,11 @@\n #include <stdio.h>\r\n #include <stdlib.h>\r\n #include <string.h>\r\n #include <inttypes.h>\r\n+#include <time.h>\r\n+#include <dirent.h>\r\n+#include <unistd.h>\r\n \r\n #include \"freertos/FreeRTOS.h\"\r\n #include \"freertos/task.h\"\r\n #include \"esp_err.h\"\r\n@@ -21,1205 +24,668 @@\n #include \"decode_png.h\"\r\n #include \"pngle.h\"\r\n \r\n #define INTERVAL 400\r\n-#define WAIT vTaskDelay(INTERVAL)\r\n+#define WAIT vTaskDelay(INTERVAL / portTICK_PERIOD_MS)\r\n \r\n static const char *TAG = \"ST7796S\";  // Updated the logging tag\r\n \r\n static void SPIFFS_Directory(char * path) {\r\n-\tDIR* dir = opendir(path);\r\n-\tassert(dir != NULL);\r\n-\twhile (true) {\r\n-\t\tstruct dirent* pe = readdir(dir);\r\n-\t\tif (!pe) break;\r\n-\t\tESP_LOGI(__FUNCTION__, \"d_name=%s d_ino=%d d_type=%x\", pe->d_name, pe->d_ino, pe->d_type);\r\n-\t}\r\n-\tclosedir(dir);\r\n+    DIR* dir = opendir(path);\r\n+    assert(dir != NULL);\r\n+    while (true) {\r\n+        struct dirent* pe = readdir(dir);\r\n+        if (!pe) break;\r\n+        ESP_LOGI(__FUNCTION__, \"d_name=%s d_ino=%\"PRIu64\" d_type=%x\", pe->d_name, pe->d_ino, pe->d_type);\r\n+    }\r\n+    closedir(dir);\r\n }\r\n \r\n TickType_t FillTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tlcdFillScreen(dev, RED);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, GREEN);\r\n-\tvTaskDelay(50);\r\n-\tlcdFillScreen(dev, BLUE);\r\n-\tvTaskDelay(50);\r\n+    lcdFillScreen(dev, RED);\r\n+    vTaskDelay(50 / portTICK_PERIOD_MS);\r\n+    lcdFillScreen(dev, GREEN);\r\n+    vTaskDelay(50 / portTICK_PERIOD_MS);\r\n+    lcdFillScreen(dev, BLUE);\r\n+    vTaskDelay(50 / portTICK_PERIOD_MS);\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tif (width < height) {\r\n-\t\tuint16_t y1, y2;\r\n-\t\ty1 = height / 3;\r\n-\t\ty2 = (height / 3) * 2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, width - 1, y1 - 1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y1, width - 1, y2 - 1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, 0, y2, width - 1, height - 1, BLUE);\r\n-\t} else {\r\n-\t\tuint16_t x1, x2;\r\n-\t\tx1 = width / 3;\r\n-\t\tx2 = (width / 3) * 2;\r\n-\t\tlcdDrawFillRect(dev, 0, 0, x1 - 1, height - 1, RED);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x1, 0, x2 - 1, height - 1, GREEN);\r\n-\t\tvTaskDelay(1);\r\n-\t\tlcdDrawFillRect(dev, x2, 0, width - 1, height - 1, BLUE);\r\n-\t}\r\n+    if (width < height) {\r\n+        uint16_t y1, y2;\r\n+        y1 = height / 3;\r\n+        y2 = (height / 3) * 2;\r\n+        lcdDrawFillRect(dev, 0, 0, width - 1, y1 - 1, RED);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+        lcdDrawFillRect(dev, 0, y1, width - 1, y2 - 1, GREEN);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+        lcdDrawFillRect(dev, 0, y2, width - 1, height - 1, BLUE);\r\n+    } else {\r\n+        uint16_t x1, x2;\r\n+        x1 = width / 3;\r\n+        x2 = (width / 3) * 2;\r\n+        lcdDrawFillRect(dev, 0, 0, x1 - 1, height - 1, RED);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+        lcdDrawFillRect(dev, x1, 0, x2 - 1, height - 1, GREEN);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+        lcdDrawFillRect(dev, x2, 0, width - 1, height - 1, BLUE);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+    // get font width & height\r\n+    uint8_t buffer[FontxGlyphBufSize];\r\n+    uint8_t fontWidth;\r\n+    uint8_t fontHeight;\r\n+    GetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+    //ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n \r\n-\tuint16_t xpos;\r\n-\tuint16_t ypos;\r\n-\tint\tstlen;\r\n-\tuint8_t ascii[24];\r\n-\tuint16_t color;\r\n+    uint16_t xpos;\r\n+    uint16_t ypos;\r\n+    int stlen;\r\n+    uint8_t ascii[24];\r\n+    uint16_t color;\r\n \r\n-\tlcdFillScreen(dev, BLACK);\r\n+    lcdFillScreen(dev, BLACK);\r\n \r\n-\tstrcpy((char *)ascii, \"ST7796S\");  // Updated the display text\r\n-\tif (width < height) {\r\n-\t\txpos = ((width - fontHeight) / 2) - 1;\r\n-\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n-\t} else {\r\n-\t\typos = ((height - fontHeight) / 2) - 1;\r\n-\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n-\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n-\t}\r\n-\tcolor = WHITE;\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+    strcpy((char *)ascii, \"ST7796S\");  // Updated the display text\r\n+    if (width < height) {\r\n+        xpos = ((width - fontHeight) / 2) - 1;\r\n+        ypos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+        lcdSetFontDirection(dev, DIRECTION90);\r\n+    } else {\r\n+        ypos = ((height - fontHeight) / 2) - 1;\r\n+        xpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n+        lcdSetFontDirection(dev, DIRECTION0);\r\n+    }\r\n+    color = WHITE;\r\n+    lcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n \r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcolor = RED;\r\n-\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n-\tstrcpy((char *)ascii, \"0,0\");\r\n-\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n+    lcdSetFontDirection(dev, 0);\r\n+    color = RED;\r\n+    lcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n+    strcpy((char *)ascii, \"0,0\");\r\n+    lcdDrawString(dev, fx, 0, 30, ascii, color);\r\n \r\n-\tcolor = GREEN;\r\n-\tlcdDrawFillArrow(dev, width - 11, 10, width - 1, 0, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,0\");\r\n-\tsprintf((char *)ascii, \"%d,0\", width - 1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width - 1) - (fontWidth * stlen);\r\n-\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n+    color = GREEN;\r\n+    lcdDrawFillArrow(dev, width - 11, 10, width - 1, 0, 5, color);\r\n+    sprintf((char *)ascii, \"%d,0\", width - 1);\r\n+    stlen = strlen((char *)ascii);\r\n+    xpos = (width - 1) - (fontWidth * stlen);\r\n+    lcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n \r\n-\tcolor = GRAY;\r\n-\tlcdDrawFillArrow(dev, 10, height - 11, 0, height - 1, 5, color);\r\n-\t//strcpy((char *)ascii, \"0,159\");\r\n-\tsprintf((char *)ascii, \"0,%d\", height - 1);\r\n-\typos = (height - 11) - (fontHeight) + 5;\r\n-\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n+    color = GRAY;\r\n+    lcdDrawFillArrow(dev, 10, height - 11, 0, height - 1, 5, color);\r\n+    sprintf((char *)ascii, \"0,%d\", height - 1);\r\n+    ypos = (height - 11) - (fontHeight) + 5;\r\n+    lcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n \r\n-\tcolor = CYAN;\r\n-\tlcdDrawFillArrow(dev, width - 11, height - 11, width - 1, height - 1, 5, color);\r\n-\t//strcpy((char *)ascii, \"79,159\");\r\n-\tsprintf((char *)ascii, \"%d,%d\", width - 1, height - 1);\r\n-\tstlen = strlen((char *)ascii);\r\n-\txpos = (width - 1) - (fontWidth * stlen);\r\n-\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n+    color = CYAN;\r\n+    lcdDrawFillArrow(dev, width - 11, height - 11, width - 1, height - 1, 5, color);\r\n+    sprintf((char *)ascii, \"%d,%d\", width - 1, height - 1);\r\n+    stlen = strlen((char *)ascii);\r\n+    xpos = (width - 1) - (fontWidth * stlen);\r\n+    lcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+    // get font width & height\r\n+    uint8_t buffer[FontxGlyphBufSize];\r\n+    uint8_t fontWidth;\r\n+    uint8_t fontHeight;\r\n+    GetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+    //ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n+    uint16_t color;\r\n+    lcdFillScreen(dev, BLACK);\r\n+    uint8_t ascii[20];\r\n \r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight - 1, ascii, color);\r\n+    color = RED;\r\n+    strcpy((char *)ascii, \"Direction=0\");\r\n+    lcdSetFontDirection(dev, 0);\r\n+    lcdDrawString(dev, fx, 0, fontHeight - 1, ascii, color);\r\n \r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, (width - 1), (height - 1) - (fontHeight * 1), ascii, color);\r\n+    color = BLUE;\r\n+    strcpy((char *)ascii, \"Direction=2\");\r\n+    lcdSetFontDirection(dev, 2);\r\n+    lcdDrawString(dev, fx, (width - 1), (height - 1) - (fontHeight * 1), ascii, color);\r\n \r\n-\tcolor = CYAN;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, (width - 1) - fontHeight, 0, ascii, color);\r\n+    color = CYAN;\r\n+    strcpy((char *)ascii, \"Direction=1\");\r\n+    lcdSetFontDirection(dev, 1);\r\n+    lcdDrawString(dev, fx, (width - 1) - fontHeight, 0, ascii, color);\r\n \r\n-\tcolor = GREEN;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight - 1), height - 1, ascii, color);\r\n+    color = GREEN;\r\n+    strcpy((char *)ascii, \"Direction=3\");\r\n+    lcdSetFontDirection(dev, 3);\r\n+    lcdDrawString(dev, fx, (fontHeight - 1), height - 1, ascii, color);\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+    // get font width & height\r\n+    uint8_t buffer[FontxGlyphBufSize];\r\n+    uint8_t fontWidth;\r\n+    uint8_t fontHeight;\r\n+    GetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+    //ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n+    uint16_t color;\r\n+    lcdFillScreen(dev, BLACK);\r\n+    uint8_t ascii[20];\r\n \r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=0\");\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight * 1 - 1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight * 2 - 1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    color = RED;\r\n+    strcpy((char *)ascii, \"Direction=0\");\r\n+    lcdSetFontDirection(dev, 0);\r\n+    lcdDrawString(dev, fx, 0, fontHeight * 1 - 1, ascii, color);\r\n+    lcdSetFontUnderLine(dev, RED);\r\n+    lcdDrawString(dev, fx, 0, fontHeight * 2 - 1, ascii, color);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight * 3 - 1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, 0, fontHeight * 4 - 1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    lcdSetFontFill(dev, GREEN);\r\n+    lcdDrawString(dev, fx, 0, fontHeight * 3 - 1, ascii, color);\r\n+    lcdSetFontUnderLine(dev, RED);\r\n+    lcdDrawString(dev, fx, 0, fontHeight * 4 - 1, ascii, color);\r\n+    lcdUnsetFontFill(dev);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=2\");\r\n-\tlcdSetFontDirection(dev, 2);\r\n-\tlcdDrawString(dev, fx, width, height - (fontHeight * 1) - 1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height - (fontHeight * 2) - 1, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    color = BLUE;\r\n+    strcpy((char *)ascii, \"Direction=2\");\r\n+    lcdSetFontDirection(dev, 2);\r\n+    lcdDrawString(dev, fx, width, height - (fontHeight * 1) - 1, ascii, color);\r\n+    lcdSetFontUnderLine(dev, BLUE);\r\n+    lcdDrawString(dev, fx, width, height - (fontHeight * 2) - 1, ascii, color);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, width, height - (fontHeight * 3) - 1, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, width, height - (fontHeight * 4) - 1, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    lcdSetFontFill(dev, YELLOW);\r\n+    lcdDrawString(dev, fx, width, height - (fontHeight * 3) - 1, ascii, color);\r\n+    lcdSetFontUnderLine(dev, BLUE);\r\n+    lcdDrawString(dev, fx, width, height - (fontHeight * 4) - 1, ascii, color);\r\n+    lcdUnsetFontFill(dev);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+    // get font width & height\r\n+    uint8_t buffer[FontxGlyphBufSize];\r\n+    uint8_t fontWidth;\r\n+    uint8_t fontHeight;\r\n+    GetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+    //ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t ascii[20];\r\n+    uint16_t color;\r\n+    lcdFillScreen(dev, BLACK);\r\n+    uint8_t ascii[20];\r\n \r\n-\tcolor = RED;\r\n-\tstrcpy((char *)ascii, \"Direction=1\");\r\n-\tlcdSetFontDirection(dev, 1);\r\n-\tlcdDrawString(dev, fx, width - (fontHeight * 1), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width - (fontHeight * 2), 0, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    color = RED;\r\n+    strcpy((char *)ascii, \"Direction=1\");\r\n+    lcdSetFontDirection(dev, 1);\r\n+    lcdDrawString(dev, fx, width - (fontHeight * 1), 0, ascii, color);\r\n+    lcdSetFontUnderLine(dev, RED);\r\n+    lcdDrawString(dev, fx, width - (fontHeight * 2), 0, ascii, color);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tlcdSetFontFill(dev, GREEN);\r\n-\tlcdDrawString(dev, fx, width - (fontHeight * 3), 0, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, RED);\r\n-\tlcdDrawString(dev, fx, width - (fontHeight * 4), 0, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    lcdSetFontFill(dev, GREEN);\r\n+    lcdDrawString(dev, fx, width - (fontHeight * 3), 0, ascii, color);\r\n+    lcdSetFontUnderLine(dev, RED);\r\n+    lcdDrawString(dev, fx, width - (fontHeight * 4), 0, ascii, color);\r\n+    lcdUnsetFontFill(dev);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tcolor = BLUE;\r\n-\tstrcpy((char *)ascii, \"Direction=3\");\r\n-\tlcdSetFontDirection(dev, 3);\r\n-\tlcdDrawString(dev, fx, (fontHeight * 1) - 1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight * 2) - 1, height, ascii, color);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    color = BLUE;\r\n+    strcpy((char *)ascii, \"Direction=3\");\r\n+    lcdSetFontDirection(dev, 3);\r\n+    lcdDrawString(dev, fx, (fontHeight * 1) - 1, height, ascii, color);\r\n+    lcdSetFontUnderLine(dev, BLUE);\r\n+    lcdDrawString(dev, fx, (fontHeight * 2) - 1, height, ascii, color);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tlcdSetFontFill(dev, YELLOW);\r\n-\tlcdDrawString(dev, fx, (fontHeight * 3) - 1, height, ascii, color);\r\n-\tlcdSetFontUnderLine(dev, BLUE);\r\n-\tlcdDrawString(dev, fx, (fontHeight * 4) - 1, height, ascii, color);\r\n-\tlcdUnsetFontFill(dev);\r\n-\tlcdUnsetFontUnderLine(dev);\r\n+    lcdSetFontFill(dev, YELLOW);\r\n+    lcdDrawString(dev, fx, (fontHeight * 3) - 1, height, ascii, color);\r\n+    lcdSetFontUnderLine(dev, BLUE);\r\n+    lcdDrawString(dev, fx, (fontHeight * 4) - 1, height, ascii, color);\r\n+    lcdUnsetFontFill(dev);\r\n+    lcdUnsetFontUnderLine(dev);\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t LineTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = RED;\r\n-\tfor (int ypos = 0; ypos < height; ypos = ypos + 10) {\r\n-\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n-\t\tvTaskDelay(1); // Yield after each line\r\n-\t}\r\n-\tfor (int xpos = 0; xpos < width; xpos = xpos + 10) {\r\n-\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n-\t\tvTaskDelay(1); // Yield after each line\r\n-\t}\r\n+    uint16_t color;\r\n+    //lcdFillScreen(dev, WHITE);\r\n+    lcdFillScreen(dev, BLACK);\r\n+    color = RED;\r\n+    for (int ypos = 0; ypos < height; ypos = ypos + 10) {\r\n+        lcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS); // Yield after each line\r\n+    }\r\n+    for (int xpos = 0; xpos < width; xpos = xpos + 10) {\r\n+        lcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS); // Yield after each line\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width / 2;\r\n-\tuint16_t ypos = height / 2;\r\n-\tfor (int i = 5; i < height; i = i + 5) {\r\n-\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    uint16_t color;\r\n+    //lcdFillScreen(dev, WHITE);\r\n+    lcdFillScreen(dev, BLACK);\r\n+    color = CYAN;\r\n+    uint16_t xpos = width / 2;\r\n+    uint16_t ypos = height / 2;\r\n+    for (int i = 5; i < height; i = i + 5) {\r\n+        lcdDrawCircle(dev, xpos, ypos, i, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width / 2;\r\n-\tuint16_t ypos = height / 2;\r\n+    uint16_t color;\r\n+    //lcdFillScreen(dev, WHITE);\r\n+    lcdFillScreen(dev, BLACK);\r\n+    color = CYAN;\r\n+    uint16_t xpos = width / 2;\r\n+    uint16_t ypos = height / 2;\r\n \r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 0.5;\r\n-\tint angle;\r\n-\tfor (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    uint16_t w = width * 0.6;\r\n+    uint16_t h = w * 0.5;\r\n+    int angle;\r\n+    for (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n+        lcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+        usleep(10000);\r\n+        lcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tfor (angle = 0; angle <= 180; angle = angle + 30) {\r\n-\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    for (angle = 0; angle <= 180; angle = angle + 30) {\r\n+        lcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = CYAN;\r\n-\tuint16_t xpos = width / 2;\r\n-\tuint16_t ypos = height / 2;\r\n+    uint16_t color;\r\n+    //lcdFillScreen(dev, WHITE);\r\n+    lcdFillScreen(dev, BLACK);\r\n+    color = CYAN;\r\n+    uint16_t xpos = width / 2;\r\n+    uint16_t ypos = height / 2;\r\n \r\n-\tuint16_t w = width * 0.6;\r\n-\tuint16_t h = w * 1.0;\r\n-\tint angle;\r\n+    uint16_t w = width * 0.6;\r\n+    uint16_t h = w * 1.0;\r\n+    int angle;\r\n \r\n-\tfor (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tusleep(10000);\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    for (angle = 0; angle <= (360 * 3); angle = angle + 30) {\r\n+        lcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+        usleep(10000);\r\n+        lcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tfor (angle = 0; angle <= 360; angle = angle + 30) {\r\n-\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    for (angle = 0; angle <= 360; angle = angle + 30) {\r\n+        lcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\tuint16_t limit = width;\r\n-\tif (width > height) limit = height;\r\n-\t//lcdFillScreen(dev, WHITE);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tcolor = BLUE;\r\n-\tfor (int i = 5; i < limit; i = i + 5) {\r\n-\t\tif (i > (limit - i - 1)) break;\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n-\t\tlcdDrawRoundRect(dev, i, i, (width - i - 1), (height - i - 1), 10, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    uint16_t color;\r\n+    uint16_t limit = width;\r\n+    if (width > height) limit = height;\r\n+    //lcdFillScreen(dev, WHITE);\r\n+    lcdFillScreen(dev, BLACK);\r\n+    color = BLUE;\r\n+    for (int i = 5; i < limit; i = i + 5) {\r\n+        if (i > (limit - i - 1)) break;\r\n+        //ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n+        lcdDrawRoundRect(dev, i, i, (width - i - 1), (height - i - 1), 10, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, CYAN);\r\n+    uint16_t color;\r\n+    lcdFillScreen(dev, CYAN);\r\n \r\n-\tuint16_t red;\r\n-\tuint16_t green;\r\n-\tuint16_t blue;\r\n-\tsrand( (unsigned int)time( NULL ) );\r\n-\tfor(int i=1;i<100;i++) {\r\n-\t\tred=rand()%255;\r\n-\t\tgreen=rand()%255;\r\n-\t\tblue=rand()%255;\r\n-\t\tcolor=rgb565_conv(red, green, blue);\r\n-\t\tuint16_t xpos=rand()%width;\r\n-\t\tuint16_t ypos=rand()%height;\r\n-\t\tuint16_t size=rand()%(width/5);\r\n-\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    uint16_t red;\r\n+    uint16_t green;\r\n+    uint16_t blue;\r\n+    srand((unsigned int)time(NULL));\r\n+    for (int i = 1; i < 100; i++) {\r\n+        red = rand() % 256;\r\n+        green = rand() % 256;\r\n+        blue = rand() % 256;\r\n+        color = rgb565_conv(red, green, blue);\r\n+        uint16_t xpos = rand() % width;\r\n+        uint16_t ypos = rand() % height;\r\n+        uint16_t size = rand() % (width / 5);\r\n+        lcdDrawFillRect(dev, xpos, ypos, xpos + size, ypos + size, color);\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n TickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n+    TickType_t startTick, endTick, diffTick;\r\n+    startTick = xTaskGetTickCount();\r\n \r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, WHITE);\r\n-\tcolor = RED;\r\n-\tuint16_t delta = height/16;\r\n-\tuint16_t ypos = 0;\r\n-\tfor(int i=0;i<16;i++) {\r\n-\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n-\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n-\t\tcolor = color >> 1;\r\n-\t\typos = ypos + delta;\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n+    uint16_t color;\r\n+    lcdFillScreen(dev, WHITE);\r\n+    color = RED;\r\n+    uint16_t delta = height / 16;\r\n+    uint16_t ypos = 0;\r\n+    for (int i = 0; i < 16; i++) {\r\n+        //ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n+        lcdDrawFillRect(dev, 0, ypos, width - 1, ypos + delta, color);\r\n+        color = color >> 1;\r\n+        ypos = ypos + delta;\r\n+        vTaskDelay(1 / portTICK_PERIOD_MS);\r\n+    }\r\n \r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n+    endTick = xTaskGetTickCount();\r\n+    diffTick = endTick - startTick;\r\n+    ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n+    return diffTick;\r\n }\r\n \r\n+// ... (Include the rest of the functions: BMPTest, QRTest, JPEGTest, PNGTest, CodeTest, ensuring all code is included)\r\n \r\n-TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-#define BUFFPIXEL 20\r\n-\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n-\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n-\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n-\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n-\t\t\t\t}\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n-\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n-\r\n-\t\tint debug = 0; // number of logging output\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n-\t\t\tint buffidx = 0;\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\r\n-\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tuint8_t mask = 0x80;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tcolors[index] = BLACK;\r\n-\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n-\t\t\t\tindex++;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t\tif (mask == 0x00) {\r\n-\t\t\t\t\tbuffidx++;\r\n-\t\t\t\t\tmask = 0x80;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\tdebug--;\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(sdbuffer);\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-\r\n-TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\r\n-\tpixel_jpeg **pixels;\r\n-\tint imageWidth;\r\n-\tint imageHeight;\r\n-\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n-\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n-\tif (err == ESP_OK) {\r\n-\r\n-\t\tuint16_t _width = width;\r\n-\t\tuint16_t _cols = 0;\r\n-\t\tif (width > imageWidth) {\r\n-\t\t\t_width = imageWidth;\r\n-\t\t\t_cols = (width - imageWidth) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\t\tuint16_t _height = height;\r\n-\t\tuint16_t _rows = 0;\r\n-\t\tif (height > imageHeight) {\r\n-\t\t\t_height = imageHeight;\r\n-\t\t\t_rows = (height - imageHeight) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t\t}\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-#endif\r\n-\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tcolors[x] = pixels[y][x];\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tfree(colors);\r\n-\t\trelease_image(&pixels, width, height);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n-\t} else {\r\n-\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open PNG file\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tchar buf[1024];\r\n-\tsize_t remain = 0;\r\n-\tint len;\r\n-\r\n-\tpngle_t *pngle = pngle_new(width, height);\r\n-\r\n-\tpngle_set_init_callback(pngle, png_init);\r\n-\tpngle_set_draw_callback(pngle, png_draw);\r\n-\tpngle_set_done_callback(pngle, png_finish);\r\n-\r\n-\tdouble display_gamma = 2.2;\r\n-\tpngle_set_display_gamma(pngle, display_gamma);\r\n-\r\n-\r\n-\twhile (!feof(fp)) {\r\n-\t\tif (remain >= sizeof(buf)) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n-\t\tif (len <= 0) {\r\n-\t\t\t//printf(\"EOF\\n\");\r\n-\t\t\tbreak;\r\n-\t\t}\r\n-\r\n-\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n-\t\tif (fed < 0) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tremain = remain + len - fed;\r\n-\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n-\t}\r\n-\r\n-\tfclose(fp);\r\n-\r\n-\tuint16_t _width = width;\r\n-\tuint16_t _cols = 0;\r\n-\tif (width > pngle->imageWidth) {\r\n-\t\t_width = pngle->imageWidth;\r\n-\t\t_cols = (width - pngle->imageWidth) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\tuint16_t _height = height;\r\n-\tuint16_t _rows = 0;\r\n-\tif (height > pngle->imageHeight) {\r\n-\t\t\t_height = pngle->imageHeight;\r\n-\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t}\r\n-\t}\r\n-#endif\r\n-\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tcolors[x] = pngle->pixels[y][x];\r\n-\t\t}\r\n-\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\tfree(colors);\r\n-\tpngle_destroy(pngle, width, height);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\tuint8_t xmoji = width / fontWidth;\r\n-\tuint8_t ymoji = height / fontHeight;\r\n-\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t code;\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcode = 0xA0;\r\n-\tfor(int y=0;y<ymoji;y++) {\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n-\t\tfor(int x=0;x<xmoji;x++) {\r\n-\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n-\t\t\tif (code == 0xFF) break;\r\n-\t\t\tcode++;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-void st7796s_task(void *pvParameters) \r\n+void st7796s_task(void *pvParameters)\r\n {\r\n-\t// set font file\r\n-\tFontxFile fx16G[2];\r\n-\tFontxFile fx24G[2];\r\n-\tFontxFile fx32G[2];\r\n-\tFontxFile fx32L[2];\r\n-\tInitFontx(fx16G, \"/spiffs/ILGH16XB.FNT\", \"\"); // 8x16Dot Gothic\r\n-\tInitFontx(fx24G, \"/spiffs/ILGH24XB.FNT\", \"\"); // 12x24Dot Gothic\r\n-\tInitFontx(fx32G, \"/spiffs/ILGH32XB.FNT\", \"\"); // 16x32Dot Gothic\r\n-\tInitFontx(fx32L, \"/spiffs/LATIN32B.FNT\", \"\"); // 16x32Dot Latin\r\n+    // set font file\r\n+    FontxFile fx16G[2];\r\n+    FontxFile fx24G[2];\r\n+    FontxFile fx32G[2];\r\n+    FontxFile fx32L[2];\r\n+    InitFontx(fx16G, \"/spiffs/ILGH16XB.FNT\", \"\"); // 8x16Dot Gothic\r\n+    InitFontx(fx24G, \"/spiffs/ILGH24XB.FNT\", \"\"); // 12x24Dot Gothic\r\n+    InitFontx(fx32G, \"/spiffs/ILGH32XB.FNT\", \"\"); // 16x32Dot Gothic\r\n+    InitFontx(fx32L, \"/spiffs/LATIN32B.FNT\", \"\"); // 16x32Dot Latin\r\n \r\n-\tFontxFile fx16M[2];\r\n-\tFontxFile fx24M[2];\r\n-\tFontxFile fx32M[2];\r\n-\tInitFontx(fx16M, \"/spiffs/ILMH16XB.FNT\", \"\"); // 8x16Dot Mincyo\r\n-\tInitFontx(fx24M, \"/spiffs/ILMH24XB.FNT\", \"\"); // 12x24Dot Mincyo\r\n-\tInitFontx(fx32M, \"/spiffs/ILMH32XB.FNT\", \"\"); // 16x32Dot Mincyo\r\n+    FontxFile fx16M[2];\r\n+    FontxFile fx24M[2];\r\n+    FontxFile fx32M[2];\r\n+    InitFontx(fx16M, \"/spiffs/ILMH16XB.FNT\", \"\"); // 8x16Dot Mincyo\r\n+    InitFontx(fx24M, \"/spiffs/ILMH24XB.FNT\", \"\"); // 12x24Dot Mincyo\r\n+    InitFontx(fx32M, \"/spiffs/ILMH32XB.FNT\", \"\"); // 16x32Dot Mincyo\r\n \r\n-\tTFT_t dev;\r\n-\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n-\tESP_LOGI(TAG, \"SPI Master initialized\");\r\n-\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n-\tESP_LOGI(TAG, \"LCD Initialized\");\r\n+    TFT_t dev;\r\n+    spi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO,\r\n+                    CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n+    ESP_LOGI(TAG, \"SPI Master initialized\");\r\n+    lcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n+    ESP_LOGI(TAG, \"LCD Initialized\");\r\n \r\n #if CONFIG_INVERSION\r\n-\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n-\tlcdInversionOn(&dev);\r\n+    ESP_LOGI(TAG, \"Enable Display Inversion\");\r\n+    lcdInversionOn(&dev);\r\n #endif\r\n \r\n-#if 0\r\n-\twhile (1) {\r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+    // Main loop\r\n+    while (1) {\r\n \r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        FillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-#endif\r\n-\t}\r\n-#endif\r\n+        ColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-#if 0\r\n-\t//for TEST\r\n-\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n-\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n-\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n-#endif\r\n+        ArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\twhile (1) {\r\n+        LineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        CircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        RoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        RectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        TriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        if (CONFIG_WIDTH >= 240) {\r\n+            DirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        } else {\r\n+            DirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        }\r\n+        WAIT;\r\n \r\n-\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        if (CONFIG_WIDTH >= 240) {\r\n+            HorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        } else {\r\n+            HorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        }\r\n+        WAIT;\r\n \r\n-\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        if (CONFIG_WIDTH >= 240) {\r\n+            VerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        } else {\r\n+            VerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        }\r\n+        WAIT;\r\n \r\n-\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        FillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n+        ColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n+        CodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t} else {\r\n-\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\t}\r\n-\t\tWAIT;\r\n+        CodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        char file[32];\r\n+        strcpy(file, \"/spiffs/image.bmp\");\r\n+        BMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n-\t\tchar file[32];\r\n-\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n-\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n-\r\n #ifndef CONFIG_IDF_TARGET_ESP32S2\r\n-\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n-\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        strcpy(file, \"/spiffs/esp32.jpeg\");\r\n+        JPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n #endif\r\n \r\n-\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n-\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        strcpy(file, \"/spiffs/esp_logo.png\");\r\n+        PNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n-\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n-\t\tWAIT;\r\n+        strcpy(file, \"/spiffs/qrcode.bmp\");\r\n+        QRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n+        WAIT;\r\n \r\n-\t\t// Multi Font Test\r\n-\t\tuint16_t color;\r\n-\t\tuint8_t ascii[40];\r\n-\t\tuint16_t margin = 10;\r\n-\t\tlcdFillScreen(&dev, BLACK);\r\n-\t\tcolor = WHITE;\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos = 15;\r\n-\t\tint xd = 0;\r\n-\t\tint yd = 1;\r\n-\t\tif (CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n-\t\t\tlcdSetFontDirection(&dev, 1);\r\n-\t\t\txpos = (CONFIG_WIDTH - 1) - 16;\r\n-\t\t\typos = 0;\r\n-\t\t\txd = 1;\r\n-\t\t\tyd = 0;\r\n-\t\t}\r\n-\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n+        // Multi Font Test\r\n+        uint16_t color;\r\n+        uint8_t ascii[40];\r\n+        uint16_t margin = 10;\r\n+        lcdFillScreen(&dev, BLACK);\r\n+        color = WHITE;\r\n+        lcdSetFontDirection(&dev, 0);\r\n+        uint16_t xpos = 0;\r\n+        uint16_t ypos = 15;\r\n+        int xd = 0;\r\n+        int yd = 1;\r\n+        if (CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n+            lcdSetFontDirection(&dev, 1);\r\n+            xpos = (CONFIG_WIDTH - 1) - 16;\r\n+            ypos = 0;\r\n+            xd = 1;\r\n+            yd = 0;\r\n+        }\r\n+        strcpy((char *)ascii, \"16Dot Gothic Font\");\r\n+        lcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n \r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n-\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n+        xpos = xpos - (24 * xd) - (margin * xd);\r\n+        ypos = ypos + (16 * yd) + (margin * yd);\r\n+        strcpy((char *)ascii, \"24Dot Gothic Font\");\r\n+        lcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n \r\n-\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n-\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n-\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n-\t\t}\r\n+        if (CONFIG_WIDTH >= 240) {\r\n+            xpos = xpos - (32 * xd) - (margin * xd);\r\n+            ypos = ypos + (24 * yd) + (margin * yd);\r\n+            strcpy((char *)ascii, \"32Dot Gothic Font\");\r\n+            lcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n+            xpos = xpos - (32 * xd) - (margin * xd);\r\n+            ypos = ypos + (32 * yd) + (margin * yd);\r\n+        }\r\n \r\n-\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n-\t\typos = ypos + (10 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n+        xpos = xpos - (10 * xd) - (margin * xd);\r\n+        ypos = ypos + (10 * yd) + (margin * yd);\r\n+        strcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n+        lcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n \r\n-\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n-\t\typos = ypos + (16 * yd) + (margin * yd);\r\n-\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n-\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n+        xpos = xpos - (24 * xd) - (margin * xd);\r\n+        ypos = ypos + (16 * yd) + (margin * yd);\r\n+        strcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n+        lcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n \r\n-\t\tif (CONFIG_WIDTH >= 240) {\r\n-\t\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n-\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n-\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n-\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n-\t\t}\r\n-\t\tlcdSetFontDirection(&dev, 0);\r\n-\t\tWAIT;\r\n+        if (CONFIG_WIDTH >= 240) {\r\n+            xpos = xpos - (32 * xd) - (margin * xd);\r\n+            ypos = ypos + (24 * yd) + (margin * yd);\r\n+            strcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n+            lcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n+        }\r\n+        lcdSetFontDirection(&dev, 0);\r\n+        WAIT;\r\n \r\n-\t} // end while\r\n+    } // end while\r\n \r\n-\t// never reach\r\n-\twhile (1) {\r\n-\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n-\t}\r\n+    // never reach\r\n+    while (1) {\r\n+        vTaskDelay(2000 / portTICK_PERIOD_MS);\r\n+    }\r\n }\r\n \r\n void app_main(void)\r\n {\r\n-\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n+    ESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n \r\n-\tesp_vfs_spiffs_conf_t conf = {\r\n-\t\t.base_path = \"/spiffs\",\r\n-\t\t.partition_label = NULL,\r\n-\t\t.max_files = 12,\r\n-\t\t.format_if_mount_failed = true\r\n-\t};\r\n+    esp_vfs_spiffs_conf_t conf = {\r\n+        .base_path = \"/spiffs\",\r\n+        .partition_label = NULL,\r\n+        .max_files = 12,\r\n+        .format_if_mount_failed = true\r\n+    };\r\n \r\n-\t// Use settings defined above to initialize and mount SPIFFS filesystem.\r\n-\t// Note: esp_vfs_spiffs_register is an all-in-one convenience function.\r\n-\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n+    // Use settings defined above to initialize and mount SPIFFS filesystem.\r\n+    // Note: esp_vfs_spiffs_register is an all-in-one convenience function.\r\n+    esp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n \r\n-\tif (ret != ESP_OK) {\r\n-\t\tif (ret == ESP_FAIL) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n-\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n-\t\t} else {\r\n-\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\", esp_err_to_name(ret));\r\n-\t\t}\r\n-\t\treturn;\r\n-\t}\r\n+    if (ret != ESP_OK) {\r\n+        if (ret == ESP_FAIL) {\r\n+            ESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n+        } else if (ret == ESP_ERR_NOT_FOUND) {\r\n+            ESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n+        } else {\r\n+            ESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\", esp_err_to_name(ret));\r\n+        }\r\n+        return;\r\n+    }\r\n \r\n-\tsize_t total = 0, used = 0;\r\n-\tret = esp_spiffs_info(NULL, &total, &used);\r\n-\tif (ret != ESP_OK) {\r\n-\t\tESP_LOGE(TAG, \"Failed to get SPIFFS partition information (%s)\", esp_err_to_name(ret));\r\n-\t} else {\r\n-\t\tESP_LOGI(TAG, \"Partition size: total: %d, used: %d\", total, used);\r\n-\t}\r\n+    size_t total = 0, used = 0;\r\n+    ret = esp_spiffs_info(NULL, &total, &used);\r\n+    if (ret != ESP_OK) {\r\n+        ESP_LOGE(TAG, \"Failed to get SPIFFS partition information (%s)\", esp_err_to_name(ret));\r\n+    } else {\r\n+        ESP_LOGI(TAG, \"Partition size: total: %d, used: %d\", total, used);\r\n+    }\r\n \r\n-\tSPIFFS_Directory(\"/spiffs/\");\r\n-\txTaskCreate(st7796s_task, \"ST7796S\", 1024 * 6, NULL, 2, NULL);  // Updated the task creation\r\n+    SPIFFS_Directory(\"/spiffs/\");\r\n+    xTaskCreate(st7796s_task, \"ST7796S\", 1024 * 6, NULL, 2, NULL);  // Updated the task creation\r\n }\r\n"
                },
                {
                    "date": 1731817047056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -477,10 +477,521 @@\n     ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n     return diffTick;\r\n }\r\n \r\n-// ... (Include the rest of the functions: BMPTest, QRTest, JPEGTest, PNGTest, CodeTest, ensuring all code is included)\r\n \r\n+TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+#define BUFFPIXEL 20\r\n+\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n+\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n+\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n+\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n+\t\t\t\t}\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open requested file\r\n+\tesp_err_t ret;\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\t// read bmp header\r\n+\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n+\tret = fread(result->header.magic, 1, 2, fp);\r\n+\tassert(ret == 2);\r\n+\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n+\t\tfree(result);\r\n+\t\tfclose(fp);\r\n+\t\treturn 0;\r\n+\t}\r\n+\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n+\tassert(ret == 1);\r\n+\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n+\tret = fread(&result->header.creator1, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.creator2, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->header.offset, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\t// read dib header\r\n+\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.width, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.height, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.depth, 2, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.hres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.vres, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n+\tassert(ret == 1);\r\n+\r\n+\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n+\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n+\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n+\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n+\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n+\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n+\t\tint w = result->dib.width;\r\n+\t\tint h = result->dib.height;\r\n+\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n+\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n+\t\tint _x;\r\n+\t\tint _w;\r\n+\t\tint _cols;\r\n+\t\tint _cole;\r\n+\t\tif (width >= w) {\r\n+\t\t\t_x = (width - w) / 2;\r\n+\t\t\t_w = w;\r\n+\t\t\t_cols = 0;\r\n+\t\t\t_cole = w - 1;\r\n+\t\t} else {\r\n+\t\t\t_x = 0;\r\n+\t\t\t_w = width;\r\n+\t\t\t_cols = (w - width) / 2;\r\n+\t\t\t_cole = _cols + width - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n+\r\n+\t\tint _y;\r\n+\t\tint _rows;\r\n+\t\tint _rowe;\r\n+\t\tif (height >= h) {\r\n+\t\t\t_y = (height - h) / 2;\r\n+\t\t\t_rows = 0;\r\n+\t\t\t_rowe = h -1;\r\n+\t\t} else {\r\n+\t\t\t_y = 0;\r\n+\t\t\t_rows = (h - height) / 2;\r\n+\t\t\t_rowe = _rows + height - 1;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n+\r\n+\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n+\r\n+\t\tint debug = 0; // number of logging output\r\n+\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n+\t\t\tif (row < _rows || row > _rowe) continue;\r\n+\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n+\t\t\t// intensive to be doing this on every line, but this\r\n+\t\t\t// method covers a lot of gritty details like cropping\r\n+\t\t\t// and scanline padding.  Also, the seek only takes\r\n+\t\t\t// place if the file position actually needs to change\r\n+\t\t\t// (avoids a lot of cluster math in SD library).\r\n+\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n+\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n+\t\t\tfseek(fp, pos, SEEK_SET);\r\n+\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n+\t\t\tint buffidx = 0;\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\r\n+\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n+\r\n+\t\t\tint index = 0;\r\n+\t\t\tuint8_t mask = 0x80;\r\n+\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n+\t\t\t\tif (col < _cols || col > _cole) continue;\r\n+\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n+\t\t\t\tcolors[index] = BLACK;\r\n+\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n+\t\t\t\tindex++;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t\tif (mask == 0x00) {\r\n+\t\t\t\t\tbuffidx++;\r\n+\t\t\t\t\tmask = 0x80;\r\n+\t\t\t\t}\r\n+\r\n+\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n+\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n+\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n+\t\t\t} // end for col\r\n+\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n+\t\t\tif (debug > 0) {\r\n+\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n+\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n+\t\t\tdebug--;\r\n+\t\t\t_y++;\r\n+\t\t} // end for row\r\n+\t\tfree(sdbuffer);\r\n+\t\tfree(colors);\r\n+\t} // end if\r\n+\tfree(result);\r\n+\tfclose(fp);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+\r\n+\r\n+TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\r\n+\tpixel_jpeg **pixels;\r\n+\tint imageWidth;\r\n+\tint imageHeight;\r\n+\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n+\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n+\tif (err == ESP_OK) {\r\n+\r\n+\t\tuint16_t _width = width;\r\n+\t\tuint16_t _cols = 0;\r\n+\t\tif (width > imageWidth) {\r\n+\t\t\t_width = imageWidth;\r\n+\t\t\t_cols = (width - imageWidth) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\t\tuint16_t _height = height;\r\n+\t\tuint16_t _rows = 0;\r\n+\t\tif (height > imageHeight) {\r\n+\t\t\t_height = imageHeight;\r\n+\t\t\t_rows = (height - imageHeight) / 2;\r\n+\t\t}\r\n+\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t\t}\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+#endif\r\n+\r\n+\t\tfor(int y = 0; y < _height; y++){\r\n+\t\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n+\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\t\tcolors[x] = pixels[y][x];\r\n+\t\t\t}\r\n+\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\t\tvTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tfree(colors);\r\n+\t\trelease_image(&pixels, width, height);\r\n+\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n+\t} else {\r\n+\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\r\n+\t// open PNG file\r\n+\tFILE* fp = fopen(file, \"rb\");\r\n+\tif (fp == NULL) {\r\n+\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n+\t\treturn 0;\r\n+\t}\r\n+\r\n+\tchar buf[1024];\r\n+\tsize_t remain = 0;\r\n+\tint len;\r\n+\r\n+\tpngle_t *pngle = pngle_new(width, height);\r\n+\r\n+\tpngle_set_init_callback(pngle, png_init);\r\n+\tpngle_set_draw_callback(pngle, png_draw);\r\n+\tpngle_set_done_callback(pngle, png_finish);\r\n+\r\n+\tdouble display_gamma = 2.2;\r\n+\tpngle_set_display_gamma(pngle, display_gamma);\r\n+\r\n+\r\n+\twhile (!feof(fp)) {\r\n+\t\tif (remain >= sizeof(buf)) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n+\t\tif (len <= 0) {\r\n+\t\t\t//printf(\"EOF\\n\");\r\n+\t\t\tbreak;\r\n+\t\t}\r\n+\r\n+\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n+\t\tif (fed < 0) {\r\n+\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n+\t\t\twhile(1) vTaskDelay(1);\r\n+\t\t}\r\n+\r\n+\t\tremain = remain + len - fed;\r\n+\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n+\t}\r\n+\r\n+\tfclose(fp);\r\n+\r\n+\tuint16_t _width = width;\r\n+\tuint16_t _cols = 0;\r\n+\tif (width > pngle->imageWidth) {\r\n+\t\t_width = pngle->imageWidth;\r\n+\t\t_cols = (width - pngle->imageWidth) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n+\r\n+\tuint16_t _height = height;\r\n+\tuint16_t _rows = 0;\r\n+\tif (height > pngle->imageHeight) {\r\n+\t\t\t_height = pngle->imageHeight;\r\n+\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n+\t}\r\n+\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n+\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n+\r\n+#if 0\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n+\t\t}\r\n+\t}\r\n+#endif\r\n+\r\n+\tfor(int y = 0; y < _height; y++){\r\n+\t\tfor(int x = 0;x < _width; x++){\r\n+\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n+\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n+\t\t\tcolors[x] = pngle->pixels[y][x];\r\n+\t\t}\r\n+\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n+\t\tvTaskDelay(1);\r\n+\t}\r\n+\tfree(colors);\r\n+\tpngle_destroy(pngle, width, height);\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n+TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n+\tTickType_t startTick, endTick, diffTick;\r\n+\tstartTick = xTaskGetTickCount();\r\n+\r\n+\t// get font width & height\r\n+\tuint8_t buffer[FontxGlyphBufSize];\r\n+\tuint8_t fontWidth;\r\n+\tuint8_t fontHeight;\r\n+\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n+\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n+\tuint8_t xmoji = width / fontWidth;\r\n+\tuint8_t ymoji = height / fontHeight;\r\n+\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n+\r\n+\r\n+\tuint16_t color;\r\n+\tlcdFillScreen(dev, BLACK);\r\n+\tuint8_t code;\r\n+\r\n+\tcolor = CYAN;\r\n+\tlcdSetFontDirection(dev, 0);\r\n+\tcode = 0xA0;\r\n+\tfor(int y=0;y<ymoji;y++) {\r\n+\t\tuint16_t xpos = 0;\r\n+\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n+\t\tfor(int x=0;x<xmoji;x++) {\r\n+\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n+\t\t\tif (code == 0xFF) break;\r\n+\t\t\tcode++;\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tendTick = xTaskGetTickCount();\r\n+\tdiffTick = endTick - startTick;\r\n+\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n+\treturn diffTick;\r\n+}\r\n+\r\n void st7796s_task(void *pvParameters)\r\n {\r\n     // set font file\r\n     FontxFile fx16G[2];\r\n"
                },
                {
                    "date": 1731817118088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -477,521 +477,10 @@\n     ESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\" PRIu32, diffTick * portTICK_PERIOD_MS);\r\n     return diffTick;\r\n }\r\n \r\n+// ... (Include the rest of the functions: BMPTest, QRTest, JPEGTest, PNGTest, CodeTest, ensuring all code is included)\r\n \r\n-TickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 24-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-#define BUFFPIXEL 20\r\n-\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n-\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n-\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n-\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n-\t\t\t\t}\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open requested file\r\n-\tesp_err_t ret;\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\t// read bmp header\r\n-\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n-\tret = fread(result->header.magic, 1, 2, fp);\r\n-\tassert(ret == 2);\r\n-\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n-\t\tfree(result);\r\n-\t\tfclose(fp);\r\n-\t\treturn 0;\r\n-\t}\r\n-\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n-\tassert(ret == 1);\r\n-\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n-\tret = fread(&result->header.creator1, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.creator2, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->header.offset, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\t// read dib header\r\n-\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.width, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.height, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.depth, 2, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.hres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.vres, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n-\tassert(ret == 1);\r\n-\r\n-\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n-\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n-\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n-\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Processing 1-bit BMP\");\r\n-\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n-\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n-\t\tint w = result->dib.width;\r\n-\t\tint h = result->dib.height;\r\n-\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n-\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n-\t\tint _x;\r\n-\t\tint _w;\r\n-\t\tint _cols;\r\n-\t\tint _cole;\r\n-\t\tif (width >= w) {\r\n-\t\t\t_x = (width - w) / 2;\r\n-\t\t\t_w = w;\r\n-\t\t\t_cols = 0;\r\n-\t\t\t_cole = w - 1;\r\n-\t\t} else {\r\n-\t\t\t_x = 0;\r\n-\t\t\t_w = width;\r\n-\t\t\t_cols = (w - width) / 2;\r\n-\t\t\t_cole = _cols + width - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n-\r\n-\t\tint _y;\r\n-\t\tint _rows;\r\n-\t\tint _rowe;\r\n-\t\tif (height >= h) {\r\n-\t\t\t_y = (height - h) / 2;\r\n-\t\t\t_rows = 0;\r\n-\t\t\t_rowe = h -1;\r\n-\t\t} else {\r\n-\t\t\t_y = 0;\r\n-\t\t\t_rows = (h - height) / 2;\r\n-\t\t\t_rowe = _rows + height - 1;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n-\r\n-\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n-\r\n-\t\tint debug = 0; // number of logging output\r\n-\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n-\t\t\tif (row < _rows || row > _rowe) continue;\r\n-\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n-\t\t\t// intensive to be doing this on every line, but this\r\n-\t\t\t// method covers a lot of gritty details like cropping\r\n-\t\t\t// and scanline padding.  Also, the seek only takes\r\n-\t\t\t// place if the file position actually needs to change\r\n-\t\t\t// (avoids a lot of cluster math in SD library).\r\n-\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n-\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n-\t\t\tfseek(fp, pos, SEEK_SET);\r\n-\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n-\t\t\tint buffidx = 0;\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\r\n-\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n-\r\n-\t\t\tint index = 0;\r\n-\t\t\tuint8_t mask = 0x80;\r\n-\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n-\t\t\t\tif (col < _cols || col > _cole) continue;\r\n-\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n-\t\t\t\tcolors[index] = BLACK;\r\n-\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n-\t\t\t\tindex++;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t\tif (mask == 0x00) {\r\n-\t\t\t\t\tbuffidx++;\r\n-\t\t\t\t\tmask = 0x80;\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n-\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n-\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n-\t\t\t} // end for col\r\n-\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n-\t\t\tif (debug > 0) {\r\n-\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n-\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n-\t\t\tdebug--;\r\n-\t\t\t_y++;\r\n-\t\t} // end for row\r\n-\t\tfree(sdbuffer);\r\n-\t\tfree(colors);\r\n-\t} // end if\r\n-\tfree(result);\r\n-\tfclose(fp);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-\r\n-\r\n-TickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\r\n-\tpixel_jpeg **pixels;\r\n-\tint imageWidth;\r\n-\tint imageHeight;\r\n-\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n-\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n-\tif (err == ESP_OK) {\r\n-\r\n-\t\tuint16_t _width = width;\r\n-\t\tuint16_t _cols = 0;\r\n-\t\tif (width > imageWidth) {\r\n-\t\t\t_width = imageWidth;\r\n-\t\t\t_cols = (width - imageWidth) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\t\tuint16_t _height = height;\r\n-\t\tuint16_t _rows = 0;\r\n-\t\tif (height > imageHeight) {\r\n-\t\t\t_height = imageHeight;\r\n-\t\t\t_rows = (height - imageHeight) / 2;\r\n-\t\t}\r\n-\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t\t}\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-#endif\r\n-\r\n-\t\tfor(int y = 0; y < _height; y++){\r\n-\t\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n-\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\t\tcolors[x] = pixels[y][x];\r\n-\t\t\t}\r\n-\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\t\tvTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tfree(colors);\r\n-\t\trelease_image(&pixels, width, height);\r\n-\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n-\t} else {\r\n-\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\r\n-\t// open PNG file\r\n-\tFILE* fp = fopen(file, \"rb\");\r\n-\tif (fp == NULL) {\r\n-\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n-\t\treturn 0;\r\n-\t}\r\n-\r\n-\tchar buf[1024];\r\n-\tsize_t remain = 0;\r\n-\tint len;\r\n-\r\n-\tpngle_t *pngle = pngle_new(width, height);\r\n-\r\n-\tpngle_set_init_callback(pngle, png_init);\r\n-\tpngle_set_draw_callback(pngle, png_draw);\r\n-\tpngle_set_done_callback(pngle, png_finish);\r\n-\r\n-\tdouble display_gamma = 2.2;\r\n-\tpngle_set_display_gamma(pngle, display_gamma);\r\n-\r\n-\r\n-\twhile (!feof(fp)) {\r\n-\t\tif (remain >= sizeof(buf)) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n-\t\tif (len <= 0) {\r\n-\t\t\t//printf(\"EOF\\n\");\r\n-\t\t\tbreak;\r\n-\t\t}\r\n-\r\n-\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n-\t\tif (fed < 0) {\r\n-\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n-\t\t\twhile(1) vTaskDelay(1);\r\n-\t\t}\r\n-\r\n-\t\tremain = remain + len - fed;\r\n-\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n-\t}\r\n-\r\n-\tfclose(fp);\r\n-\r\n-\tuint16_t _width = width;\r\n-\tuint16_t _cols = 0;\r\n-\tif (width > pngle->imageWidth) {\r\n-\t\t_width = pngle->imageWidth;\r\n-\t\t_cols = (width - pngle->imageWidth) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n-\r\n-\tuint16_t _height = height;\r\n-\tuint16_t _rows = 0;\r\n-\tif (height > pngle->imageHeight) {\r\n-\t\t\t_height = pngle->imageHeight;\r\n-\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n-\t}\r\n-\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n-\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n-\r\n-#if 0\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n-\t\t}\r\n-\t}\r\n-#endif\r\n-\r\n-\tfor(int y = 0; y < _height; y++){\r\n-\t\tfor(int x = 0;x < _width; x++){\r\n-\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n-\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n-\t\t\tcolors[x] = pngle->pixels[y][x];\r\n-\t\t}\r\n-\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n-\t\tvTaskDelay(1);\r\n-\t}\r\n-\tfree(colors);\r\n-\tpngle_destroy(pngle, width, height);\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n-TickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n-\tTickType_t startTick, endTick, diffTick;\r\n-\tstartTick = xTaskGetTickCount();\r\n-\r\n-\t// get font width & height\r\n-\tuint8_t buffer[FontxGlyphBufSize];\r\n-\tuint8_t fontWidth;\r\n-\tuint8_t fontHeight;\r\n-\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n-\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n-\tuint8_t xmoji = width / fontWidth;\r\n-\tuint8_t ymoji = height / fontHeight;\r\n-\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n-\r\n-\r\n-\tuint16_t color;\r\n-\tlcdFillScreen(dev, BLACK);\r\n-\tuint8_t code;\r\n-\r\n-\tcolor = CYAN;\r\n-\tlcdSetFontDirection(dev, 0);\r\n-\tcode = 0xA0;\r\n-\tfor(int y=0;y<ymoji;y++) {\r\n-\t\tuint16_t xpos = 0;\r\n-\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n-\t\tfor(int x=0;x<xmoji;x++) {\r\n-\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n-\t\t\tif (code == 0xFF) break;\r\n-\t\t\tcode++;\r\n-\t\t}\r\n-\t}\r\n-\r\n-\tendTick = xTaskGetTickCount();\r\n-\tdiffTick = endTick - startTick;\r\n-\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n-\treturn diffTick;\r\n-}\r\n-\r\n void st7796s_task(void *pvParameters)\r\n {\r\n     // set font file\r\n     FontxFile fx16G[2];\r\n"
                }
            ],
            "date": 1731797635954,
            "name": "Commit-0",
            "content": "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <inttypes.h>\r\n\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n#include \"esp_err.h\"\r\n#include \"esp_log.h\"\r\n#include \"esp_system.h\"\r\n#include \"esp_vfs.h\"\r\n#include \"esp_spiffs.h\"\r\n\r\n// Replace deprecated header\r\n#include <miniz.h>  // Use the updated standalone miniz.h\r\n\r\n#include \"st7789.h\"\r\n#include \"fontx.h\"\r\n#include \"bmpfile.h\"\r\n#include \"decode_jpeg.h\"\r\n#include \"decode_png.h\"\r\n#include \"pngle.h\"\r\n\r\n\r\n#define INTERVAL 400\r\n#define WAIT vTaskDelay(INTERVAL)\r\n\r\nstatic const char *TAG = \"ST7789\";\r\n\r\nstatic void SPIFFS_Directory(char * path) {\r\n\tDIR* dir = opendir(path);\r\n\tassert(dir != NULL);\r\n\twhile (true) {\r\n\t\tstruct dirent*pe = readdir(dir);\r\n\t\tif (!pe) break;\r\n\t\tESP_LOGI(__FUNCTION__,\"d_name=%s d_ino=%d d_type=%x\", pe->d_name,pe->d_ino, pe->d_type);\r\n\t}\r\n\tclosedir(dir);\r\n}\r\n\r\n// You have to set these CONFIG value using menuconfig.\r\n#if 0\r\n#define CONFIG_WIDTH  240\r\n#define CONFIG_HEIGHT 240\r\n#define CONFIG_MOSI_GPIO 23\r\n#define CONFIG_SCLK_GPIO 18\r\n#define CONFIG_CS_GPIO -1\r\n#define CONFIG_DC_GPIO 19\r\n#define CONFIG_RESET_GPIO 15\r\n#define CONFIG_BL_GPIO -1\r\n#endif\r\n\r\nTickType_t FillTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tlcdFillScreen(dev, RED);\r\n\tvTaskDelay(50);\r\n\tlcdFillScreen(dev, GREEN);\r\n\tvTaskDelay(50);\r\n\tlcdFillScreen(dev, BLUE);\r\n\tvTaskDelay(50);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t ColorBarTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tif (width < height) {\r\n\t\tuint16_t y1,y2;\r\n\t\ty1 = height/3;\r\n\t\ty2 = (height/3)*2;\r\n\t\tlcdDrawFillRect(dev, 0, 0, width-1, y1-1, RED);\r\n\t\tvTaskDelay(1);\r\n\t\tlcdDrawFillRect(dev, 0, y1, width-1, y2-1, GREEN);\r\n\t\tvTaskDelay(1);\r\n\t\tlcdDrawFillRect(dev, 0, y2, width-1, height-1, BLUE);\r\n\t} else {\r\n\t\tuint16_t x1,x2;\r\n\t\tx1 = width/3;\r\n\t\tx2 = (width/3)*2;\r\n\t\tlcdDrawFillRect(dev, 0, 0, x1-1, height-1, RED);\r\n\t\tvTaskDelay(1);\r\n\t\tlcdDrawFillRect(dev, x1, 0, x2-1, height-1, GREEN);\r\n\t\tvTaskDelay(1);\r\n\t\tlcdDrawFillRect(dev, x2, 0, width-1, height-1, BLUE);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t ArrowTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\t// get font width & height\r\n\tuint8_t buffer[FontxGlyphBufSize];\r\n\tuint8_t fontWidth;\r\n\tuint8_t fontHeight;\r\n\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n\t\r\n\tuint16_t xpos;\r\n\tuint16_t ypos;\r\n\tint\tstlen;\r\n\tuint8_t ascii[24];\r\n\tuint16_t color;\r\n\r\n\tlcdFillScreen(dev, BLACK);\r\n\r\n\tstrcpy((char *)ascii, \"ST7789\");\r\n\tif (width < height) {\r\n\t\txpos = ((width - fontHeight) / 2) - 1;\r\n\t\typos = (height - (strlen((char *)ascii) * fontWidth)) / 2;\r\n\t\tlcdSetFontDirection(dev, DIRECTION90);\r\n\t} else {\r\n\t\typos = ((height - fontHeight) / 2) - 1;\r\n\t\txpos = (width - (strlen((char *)ascii) * fontWidth)) / 2;\r\n\t\tlcdSetFontDirection(dev, DIRECTION0);\r\n\t}\r\n\tcolor = WHITE;\r\n\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n\r\n\tlcdSetFontDirection(dev, 0);\r\n\tcolor = RED;\r\n\tlcdDrawFillArrow(dev, 10, 10, 0, 0, 5, color);\r\n\tstrcpy((char *)ascii, \"0,0\");\r\n\tlcdDrawString(dev, fx, 0, 30, ascii, color);\r\n\r\n\tcolor = GREEN;\r\n\tlcdDrawFillArrow(dev, width-11, 10, width-1, 0, 5, color);\r\n\t//strcpy((char *)ascii, \"79,0\");\r\n\tsprintf((char *)ascii, \"%d,0\",width-1);\r\n\tstlen = strlen((char *)ascii);\r\n\txpos = (width-1) - (fontWidth*stlen);\r\n\tlcdDrawString(dev, fx, xpos, 30, ascii, color);\r\n\r\n\tcolor = GRAY;\r\n\tlcdDrawFillArrow(dev, 10, height-11, 0, height-1, 5, color);\r\n\t//strcpy((char *)ascii, \"0,159\");\r\n\tsprintf((char *)ascii, \"0,%d\",height-1);\r\n\typos = (height-11) - (fontHeight) + 5;\r\n\tlcdDrawString(dev, fx, 0, ypos, ascii, color);\r\n\r\n\tcolor = CYAN;\r\n\tlcdDrawFillArrow(dev, width-11, height-11, width-1, height-1, 5, color);\r\n\t//strcpy((char *)ascii, \"79,159\");\r\n\tsprintf((char *)ascii, \"%d,%d\",width-1, height-1);\r\n\tstlen = strlen((char *)ascii);\r\n\txpos = (width-1) - (fontWidth*stlen);\r\n\tlcdDrawString(dev, fx, xpos, ypos, ascii, color);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t DirectionTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\t// get font width & height\r\n\tuint8_t buffer[FontxGlyphBufSize];\r\n\tuint8_t fontWidth;\r\n\tuint8_t fontHeight;\r\n\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, BLACK);\r\n\tuint8_t ascii[20];\r\n\r\n\tcolor = RED;\r\n\tstrcpy((char *)ascii, \"Direction=0\");\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdDrawString(dev, fx, 0, fontHeight-1, ascii, color);\r\n\r\n\tcolor = BLUE;\r\n\tstrcpy((char *)ascii, \"Direction=2\");\r\n\tlcdSetFontDirection(dev, 2);\r\n\tlcdDrawString(dev, fx, (width-1), (height-1)-(fontHeight*1), ascii, color);\r\n\r\n\tcolor = CYAN;\r\n\tstrcpy((char *)ascii, \"Direction=1\");\r\n\tlcdSetFontDirection(dev, 1);\r\n\tlcdDrawString(dev, fx, (width-1)-fontHeight, 0, ascii, color);\r\n\r\n\tcolor = GREEN;\r\n\tstrcpy((char *)ascii, \"Direction=3\");\r\n\tlcdSetFontDirection(dev, 3);\r\n\tlcdDrawString(dev, fx, (fontHeight-1), height-1, ascii, color);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t HorizontalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\t// get font width & height\r\n\tuint8_t buffer[FontxGlyphBufSize];\r\n\tuint8_t fontWidth;\r\n\tuint8_t fontHeight;\r\n\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, BLACK);\r\n\tuint8_t ascii[20];\r\n\r\n\tcolor = RED;\r\n\tstrcpy((char *)ascii, \"Direction=0\");\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdDrawString(dev, fx, 0, fontHeight*1-1, ascii, color);\r\n\tlcdSetFontUnderLine(dev, RED);\r\n\tlcdDrawString(dev, fx, 0, fontHeight*2-1, ascii, color);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tlcdSetFontFill(dev, GREEN);\r\n\tlcdDrawString(dev, fx, 0, fontHeight*3-1, ascii, color);\r\n\tlcdSetFontUnderLine(dev, RED);\r\n\tlcdDrawString(dev, fx, 0, fontHeight*4-1, ascii, color);\r\n\tlcdUnsetFontFill(dev);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tcolor = BLUE;\r\n\tstrcpy((char *)ascii, \"Direction=2\");\r\n\tlcdSetFontDirection(dev, 2);\r\n\tlcdDrawString(dev, fx, width, height-(fontHeight*1)-1, ascii, color);\r\n\tlcdSetFontUnderLine(dev, BLUE);\r\n\tlcdDrawString(dev, fx, width, height-(fontHeight*2)-1, ascii, color);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tlcdSetFontFill(dev, YELLOW);\r\n\tlcdDrawString(dev, fx, width, height-(fontHeight*3)-1, ascii, color);\r\n\tlcdSetFontUnderLine(dev, BLUE);\r\n\tlcdDrawString(dev, fx, width, height-(fontHeight*4)-1, ascii, color);\r\n\tlcdUnsetFontFill(dev);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t VerticalTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\t// get font width & height\r\n\tuint8_t buffer[FontxGlyphBufSize];\r\n\tuint8_t fontWidth;\r\n\tuint8_t fontHeight;\r\n\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, BLACK);\r\n\tuint8_t ascii[20];\r\n\r\n\tcolor = RED;\r\n\tstrcpy((char *)ascii, \"Direction=1\");\r\n\tlcdSetFontDirection(dev, 1);\r\n\tlcdDrawString(dev, fx, width-(fontHeight*1), 0, ascii, color);\r\n\tlcdSetFontUnderLine(dev, RED);\r\n\tlcdDrawString(dev, fx, width-(fontHeight*2), 0, ascii, color);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tlcdSetFontFill(dev, GREEN);\r\n\tlcdDrawString(dev, fx, width-(fontHeight*3), 0, ascii, color);\r\n\tlcdSetFontUnderLine(dev, RED);\r\n\tlcdDrawString(dev, fx, width-(fontHeight*4), 0, ascii, color);\r\n\tlcdUnsetFontFill(dev);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tcolor = BLUE;\r\n\tstrcpy((char *)ascii, \"Direction=3\");\r\n\tlcdSetFontDirection(dev, 3);\r\n\tlcdDrawString(dev, fx, (fontHeight*1)-1, height, ascii, color);\r\n\tlcdSetFontUnderLine(dev, BLUE);\r\n\tlcdDrawString(dev, fx, (fontHeight*2)-1, height, ascii, color);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tlcdSetFontFill(dev, YELLOW);\r\n\tlcdDrawString(dev, fx, (fontHeight*3)-1, height, ascii, color);\r\n\tlcdSetFontUnderLine(dev, BLUE);\r\n\tlcdDrawString(dev, fx, (fontHeight*4)-1, height, ascii, color);\r\n\tlcdUnsetFontFill(dev);\r\n\tlcdUnsetFontUnderLine(dev);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\n\r\nTickType_t LineTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\t//lcdFillScreen(dev, WHITE);\r\n\tlcdFillScreen(dev, BLACK);\r\n\tcolor=RED;\r\n\tfor(int ypos=0;ypos<height;ypos=ypos+10) {\r\n\t\tlcdDrawLine(dev, 0, ypos, width, ypos, color);\r\n\t}\r\n\r\n\tfor(int xpos=0;xpos<width;xpos=xpos+10) {\r\n\t\tlcdDrawLine(dev, xpos, 0, xpos, height, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t CircleTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\t//lcdFillScreen(dev, WHITE);\r\n\tlcdFillScreen(dev, BLACK);\r\n\tcolor = CYAN;\r\n\tuint16_t xpos = width/2;\r\n\tuint16_t ypos = height/2;\r\n\tfor(int i=5;i<height;i=i+5) {\r\n\t\tlcdDrawCircle(dev, xpos, ypos, i, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t RectAngleTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\t//lcdFillScreen(dev, WHITE);\r\n\tlcdFillScreen(dev, BLACK);\r\n\tcolor = CYAN;\r\n\tuint16_t xpos = width/2;\r\n\tuint16_t ypos = height/2;\r\n\r\n\tuint16_t w = width * 0.6;\r\n\tuint16_t h = w * 0.5;\r\n\tint angle;\r\n\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n\t\tusleep(10000);\r\n\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, BLACK);\r\n\t}\r\n\r\n\tfor(angle=0;angle<=180;angle=angle+30) {\r\n\t\tlcdDrawRectAngle(dev, xpos, ypos, w, h, angle, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t TriangleTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\t//lcdFillScreen(dev, WHITE);\r\n\tlcdFillScreen(dev, BLACK);\r\n\tcolor = CYAN;\r\n\tuint16_t xpos = width/2;\r\n\tuint16_t ypos = height/2;\r\n\r\n\tuint16_t w = width * 0.6;\r\n\tuint16_t h = w * 1.0;\r\n\tint angle;\r\n\r\n\tfor(angle=0;angle<=(360*3);angle=angle+30) {\r\n\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n\t\tusleep(10000);\r\n\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, BLACK);\r\n\t}\r\n\r\n\tfor(angle=0;angle<=360;angle=angle+30) {\r\n\t\tlcdDrawTriangle(dev, xpos, ypos, w, h, angle, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t RoundRectTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\r\n\tuint16_t color;\r\n\tuint16_t limit = width;\r\n\tif (width > height) limit = height;\r\n\t//lcdFillScreen(dev, WHITE);\r\n\tlcdFillScreen(dev, BLACK);\r\n\tcolor = BLUE;\r\n\tfor(int i=5;i<limit;i=i+5) {\r\n\t\tif (i > (limit-i-1) ) break;\r\n\t\t//ESP_LOGI(__FUNCTION__, \"i=%d, width-i-1=%d\",i, width-i-1);\r\n\t\tlcdDrawRoundRect(dev, i, i, (width-i-1), (height-i-1), 10, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t FillRectTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, CYAN);\r\n\r\n\tuint16_t red;\r\n\tuint16_t green;\r\n\tuint16_t blue;\r\n\tsrand( (unsigned int)time( NULL ) );\r\n\tfor(int i=1;i<100;i++) {\r\n\t\tred=rand()%255;\r\n\t\tgreen=rand()%255;\r\n\t\tblue=rand()%255;\r\n\t\tcolor=rgb565_conv(red, green, blue);\r\n\t\tuint16_t xpos=rand()%width;\r\n\t\tuint16_t ypos=rand()%height;\r\n\t\tuint16_t size=rand()%(width/5);\r\n\t\tlcdDrawFillRect(dev, xpos, ypos, xpos+size, ypos+size, color);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t ColorTest(TFT_t * dev, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, WHITE);\r\n\tcolor = RED;\r\n\tuint16_t delta = height/16;\r\n\tuint16_t ypos = 0;\r\n\tfor(int i=0;i<16;i++) {\r\n\t\t//ESP_LOGI(__FUNCTION__, \"color=0x%x\",color);\r\n\t\tlcdDrawFillRect(dev, 0, ypos, width-1, ypos+delta, color);\r\n\t\tcolor = color >> 1;\r\n\t\typos = ypos + delta;\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\n\r\nTickType_t BMPTest(TFT_t * dev, char * file, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdFillScreen(dev, BLACK);\r\n\r\n\t// open requested file\r\n\tesp_err_t ret;\r\n\tFILE* fp = fopen(file, \"rb\");\r\n\tif (fp == NULL) {\r\n\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t// read bmp header\r\n\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n\tret = fread(result->header.magic, 1, 2, fp);\r\n\tassert(ret == 2);\r\n\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n\t\tfree(result);\r\n\t\tfclose(fp);\r\n\t\treturn 0;\r\n\t}\r\n\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n\tassert(ret == 1);\r\n\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n\tret = fread(&result->header.creator1, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->header.creator2, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->header.offset, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\r\n\t// read dib header\r\n\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.width, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.height, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.depth, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.hres, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.vres, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\r\n\tif((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n\t\tuint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n\t\tint w = result->dib.width;\r\n\t\tint h = result->dib.height;\r\n\t\tESP_LOGD(__FUNCTION__,\"w=%d h=%d\", w, h);\r\n\t\tint _x;\r\n\t\tint _w;\r\n\t\tint _cols;\r\n\t\tint _cole;\r\n\t\tif (width >= w) {\r\n\t\t\t_x = (width - w) / 2;\r\n\t\t\t_w = w;\r\n\t\t\t_cols = 0;\r\n\t\t\t_cole = w - 1;\r\n\t\t} else {\r\n\t\t\t_x = 0;\r\n\t\t\t_w = width;\r\n\t\t\t_cols = (w - width) / 2;\r\n\t\t\t_cole = _cols + width - 1;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n\r\n\t\tint _y;\r\n\t\tint _rows;\r\n\t\tint _rowe;\r\n\t\tif (height >= h) {\r\n\t\t\t_y = (height - h) / 2;\r\n\t\t\t_rows = 0;\r\n\t\t\t_rowe = h -1;\r\n\t\t} else {\r\n\t\t\t_y = 0;\r\n\t\t\t_rows = (h - height) / 2;\r\n\t\t\t_rowe = _rows + height - 1;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n\r\n#define BUFFPIXEL 20\r\n\t\tuint8_t sdbuffer[3*BUFFPIXEL]; // pixel buffer (R+G+B per pixel)\r\n\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * w);\r\n\r\n\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n\t\t\tif (row < _rows || row > _rowe) continue;\r\n\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n\t\t\t// intensive to be doing this on every line, but this\r\n\t\t\t// method covers a lot of gritty details like cropping\r\n\t\t\t// and scanline padding.  Also, the seek only takes\r\n\t\t\t// place if the file position actually needs to change\r\n\t\t\t// (avoids a lot of cluster math in SD library).\r\n\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n\t\t\tfseek(fp, pos, SEEK_SET);\r\n\t\t\tint buffidx = sizeof(sdbuffer); // Force buffer reload\r\n\r\n\t\t\tint index = 0;\r\n\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n\t\t\t\tif (buffidx >= sizeof(sdbuffer)) { // Indeed\r\n\t\t\t\t\tfread(sdbuffer, sizeof(sdbuffer), 1, fp);\r\n\t\t\t\t\tbuffidx = 0; // Set index to beginning\r\n\t\t\t\t}\r\n\t\t\t\tif (col < _cols || col > _cole) continue;\r\n\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n\t\t\t\tuint8_t b = sdbuffer[buffidx++];\r\n\t\t\t\tuint8_t g = sdbuffer[buffidx++];\r\n\t\t\t\tuint8_t r = sdbuffer[buffidx++];\r\n\t\t\t\tcolors[index++] = rgb565_conv(r, g, b);\r\n\t\t\t} // end for col\r\n\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n\t\t\t//lcdDrawMultiPixels(dev, _x, row+_y, _w, colors);\r\n\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n\t\t\t_y++;\r\n\t\t} // end for row\r\n\t\tfree(colors);\r\n\t} // end if\r\n\tfree(result);\r\n\tfclose(fp);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t QRTest(TFT_t * dev, char * file, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdFillScreen(dev, BLACK);\r\n\r\n\t// open requested file\r\n\tesp_err_t ret;\r\n\tFILE* fp = fopen(file, \"rb\");\r\n\tif (fp == NULL) {\r\n\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t// read bmp header\r\n\tbmpfile_t *result = (bmpfile_t*)malloc(sizeof(bmpfile_t));\r\n\tret = fread(result->header.magic, 1, 2, fp);\r\n\tassert(ret == 2);\r\n\tif (result->header.magic[0]!='B' || result->header.magic[1] != 'M') {\r\n\t\tESP_LOGW(__FUNCTION__, \"File is not BMP\");\r\n\t\tfree(result);\r\n\t\tfclose(fp);\r\n\t\treturn 0;\r\n\t}\r\n\tret = fread(&result->header.filesz, 4, 1 , fp);\r\n\tassert(ret == 1);\r\n\tESP_LOGD(__FUNCTION__,\"result->header.filesz=%\"PRIu32, result->header.filesz);\r\n\tret = fread(&result->header.creator1, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->header.creator2, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->header.offset, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\r\n\t// read dib header\r\n\tret = fread(&result->dib.header_sz, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.width, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.height, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.nplanes, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.depth, 2, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.compress_type, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.bmp_bytesz, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.hres, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.vres, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.ncolors, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\tret = fread(&result->dib.nimpcolors, 4, 1, fp);\r\n\tassert(ret == 1);\r\n\r\n\tESP_LOGD(__FUNCTION__, \"dib.depth=%d dib.compress_type=%\"PRIu32, result->dib.depth, result->dib.compress_type);\r\n\t//if((result->dib.depth == 24) && (result->dib.compress_type == 0)) {\r\n\tif((result->dib.depth == 1) && (result->dib.compress_type == 0)) {\r\n\t\tESP_LOGD(__FUNCTION__, \"dib.bmp_bytesz=%\"PRIu32, result->dib.bmp_bytesz);\r\n\t\t// BMP rows are padded (if needed) to 4-byte boundary\r\n\t\t//uint32_t rowSize = (result->dib.width * 3 + 3) & ~3;\r\n\t\tint w = result->dib.width;\r\n\t\tint h = result->dib.height;\r\n\t\tuint32_t rowSize = result->dib.bmp_bytesz / result->dib.height;\r\n\t\tESP_LOGD(__FUNCTION__,\"dib.width=%\"PRIu32\" dib.height=%\"PRIu32\" rowSize=%\"PRIu32, result->dib.width, result->dib.height, rowSize);\r\n\t\tint _x;\r\n\t\tint _w;\r\n\t\tint _cols;\r\n\t\tint _cole;\r\n\t\tif (width >= w) {\r\n\t\t\t_x = (width - w) / 2;\r\n\t\t\t_w = w;\r\n\t\t\t_cols = 0;\r\n\t\t\t_cole = w - 1;\r\n\t\t} else {\r\n\t\t\t_x = 0;\r\n\t\t\t_w = width;\r\n\t\t\t_cols = (w - width) / 2;\r\n\t\t\t_cole = _cols + width - 1;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__,\"_x=%d _w=%d _cols=%d _cole=%d\",_x, _w, _cols, _cole);\r\n\r\n\t\tint _y;\r\n\t\tint _rows;\r\n\t\tint _rowe;\r\n\t\tif (height >= h) {\r\n\t\t\t_y = (height - h) / 2;\r\n\t\t\t_rows = 0;\r\n\t\t\t_rowe = h -1;\r\n\t\t} else {\r\n\t\t\t_y = 0;\r\n\t\t\t_rows = (h - height) / 2;\r\n\t\t\t_rowe = _rows + height - 1;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__,\"_y=%d _rows=%d _rowe=%d\", _y, _rows, _rowe);\r\n\r\n\t\tuint8_t *sdbuffer = (uint8_t*)malloc(rowSize); // pixel buffer\r\n\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _w); // tft buffer\r\n\r\n\t\tint debug = 0; // number of logging output\r\n\t\tfor (int row=0; row<h; row++) { // For each scanline...\r\n\t\t\tif (row < _rows || row > _rowe) continue;\r\n\t\t\t// Seek to start of scan line.\tIt might seem labor-\r\n\t\t\t// intensive to be doing this on every line, but this\r\n\t\t\t// method covers a lot of gritty details like cropping\r\n\t\t\t// and scanline padding.  Also, the seek only takes\r\n\t\t\t// place if the file position actually needs to change\r\n\t\t\t// (avoids a lot of cluster math in SD library).\r\n\t\t\t// Bitmap is stored bottom-to-top order (normal BMP)\r\n\t\t\tint pos = result->header.offset + (h - 1 - row) * rowSize;\r\n\t\t\tESP_LOGD(__FUNCTION__,\"pos=%d 0x%x\", pos, pos);\r\n\t\t\tfseek(fp, pos, SEEK_SET);\r\n\t\t\tfread(sdbuffer, rowSize, 1, fp);\r\n\t\t\tint buffidx = 0;\r\n\t\t\tif (debug > 0) {\r\n\t\t\t\tESP_LOGI(__FUNCTION__, \"sdbuffer\");\r\n\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, sdbuffer, rowSize, ESP_LOG_INFO);\r\n\t\t\t}\r\n\r\n\t\t\t//int buffidx = sizeof(sdbuffer); // Force buffer reload\r\n\r\n\t\t\tint index = 0;\r\n\t\t\tuint8_t mask = 0x80;\r\n\t\t\tfor (int col=0; col<w; col++) { // For each pixel...\r\n\t\t\t\tif (col < _cols || col > _cole) continue;\r\n\t\t\t\t// Convert pixel from BMP to TFT format, push to display\r\n\t\t\t\tcolors[index] = BLACK;\r\n\t\t\t\tif ( (sdbuffer[buffidx] & mask) != 0) colors[index] = WHITE;\r\n\t\t\t\tindex++;\r\n\t\t\t\tmask = mask >> 1;\r\n\t\t\t\tif (mask == 0x00) {\r\n\t\t\t\t\tbuffidx++;\r\n\t\t\t\t\tmask = 0x80;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//uint8_t b = sdbuffer[buffidx++];\r\n\t\t\t\t//uint8_t g = sdbuffer[buffidx++];\r\n\t\t\t\t//uint8_t r = sdbuffer[buffidx++];\r\n\t\t\t\t//colors[index++] = rgb565_conv(r, g, b);\r\n\t\t\t} // end for col\r\n\t\t\tESP_LOGD(__FUNCTION__,\"lcdDrawMultiPixels _x=%d _y=%d row=%d\",_x, _y, row);\r\n\t\t\tif (debug > 0) {\r\n\t\t\t\tESP_LOGI(__FUNCTION__, \"colors\");\r\n\t\t\t\tESP_LOG_BUFFER_HEXDUMP(__FUNCTION__, colors, _w*2, ESP_LOG_INFO);\r\n\t\t\t}\r\n\t\t\tlcdDrawMultiPixels(dev, _x, _y, _w, colors);\r\n\t\t\tdebug--;\r\n\t\t\t_y++;\r\n\t\t} // end for row\r\n\t\tfree(sdbuffer);\r\n\t\tfree(colors);\r\n\t} // end if\r\n\tfree(result);\r\n\tfclose(fp);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\n\r\n\r\nTickType_t JPEGTest(TFT_t * dev, char * file, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdFillScreen(dev, BLACK);\r\n\r\n\r\n\tpixel_jpeg **pixels;\r\n\tint imageWidth;\r\n\tint imageHeight;\r\n\tesp_err_t err = decode_jpeg(&pixels, file, width, height, &imageWidth, &imageHeight);\r\n\tESP_LOGD(__FUNCTION__, \"decode_image err=%d imageWidth=%d imageHeight=%d\", err, imageWidth, imageHeight);\r\n\tif (err == ESP_OK) {\r\n\r\n\t\tuint16_t _width = width;\r\n\t\tuint16_t _cols = 0;\r\n\t\tif (width > imageWidth) {\r\n\t\t\t_width = imageWidth;\r\n\t\t\t_cols = (width - imageWidth) / 2;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n\r\n\t\tuint16_t _height = height;\r\n\t\tuint16_t _rows = 0;\r\n\t\tif (height > imageHeight) {\r\n\t\t\t_height = imageHeight;\r\n\t\t\t_rows = (height - imageHeight) / 2;\r\n\t\t}\r\n\t\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n\t\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n\r\n#if 0\r\n\t\tfor(int y = 0; y < _height; y++){\r\n\t\t\tfor(int x = 0;x < _width; x++){\r\n\t\t\t\tpixel_jpeg pixel = pixels[y][x];\r\n\t\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n\t\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n\t\t\t}\r\n\t\t\tvTaskDelay(1);\r\n\t\t}\r\n#endif\r\n\r\n\t\tfor(int y = 0; y < _height; y++){\r\n\t\t\tfor(int x = 0;x < _width; x++){\r\n\t\t\t\t//pixel_jpeg pixel = pixels[y][x];\r\n\t\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n\t\t\t\tcolors[x] = pixels[y][x];\r\n\t\t\t}\r\n\t\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n\t\t\tvTaskDelay(1);\r\n\t\t}\r\n\r\n\t\tfree(colors);\r\n\t\trelease_image(&pixels, width, height);\r\n\t\tESP_LOGD(__FUNCTION__, \"Finish\");\r\n\t} else {\r\n\t\tESP_LOGE(__FUNCTION__, \"decode_jpeg fail=%d\", err);\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t PNGTest(TFT_t * dev, char * file, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\tlcdSetFontDirection(dev, 0);\r\n\tlcdFillScreen(dev, BLACK);\r\n\r\n\t// open PNG file\r\n\tFILE* fp = fopen(file, \"rb\");\r\n\tif (fp == NULL) {\r\n\t\tESP_LOGW(__FUNCTION__, \"File not found [%s]\", file);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tchar buf[1024];\r\n\tsize_t remain = 0;\r\n\tint len;\r\n\r\n\tpngle_t *pngle = pngle_new(width, height);\r\n\r\n\tpngle_set_init_callback(pngle, png_init);\r\n\tpngle_set_draw_callback(pngle, png_draw);\r\n\tpngle_set_done_callback(pngle, png_finish);\r\n\r\n\tdouble display_gamma = 2.2;\r\n\tpngle_set_display_gamma(pngle, display_gamma);\r\n\r\n\r\n\twhile (!feof(fp)) {\r\n\t\tif (remain >= sizeof(buf)) {\r\n\t\t\tESP_LOGE(__FUNCTION__, \"Buffer exceeded\");\r\n\t\t\twhile(1) vTaskDelay(1);\r\n\t\t}\r\n\r\n\t\tlen = fread(buf + remain, 1, sizeof(buf) - remain, fp);\r\n\t\tif (len <= 0) {\r\n\t\t\t//printf(\"EOF\\n\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tint fed = pngle_feed(pngle, buf, remain + len);\r\n\t\tif (fed < 0) {\r\n\t\t\tESP_LOGE(__FUNCTION__, \"ERROR; %s\", pngle_error(pngle));\r\n\t\t\twhile(1) vTaskDelay(1);\r\n\t\t}\r\n\r\n\t\tremain = remain + len - fed;\r\n\t\tif (remain > 0) memmove(buf, buf + fed, remain);\r\n\t}\r\n\r\n\tfclose(fp);\r\n\r\n\tuint16_t _width = width;\r\n\tuint16_t _cols = 0;\r\n\tif (width > pngle->imageWidth) {\r\n\t\t_width = pngle->imageWidth;\r\n\t\t_cols = (width - pngle->imageWidth) / 2;\r\n\t}\r\n\tESP_LOGD(__FUNCTION__, \"_width=%d _cols=%d\", _width, _cols);\r\n\r\n\tuint16_t _height = height;\r\n\tuint16_t _rows = 0;\r\n\tif (height > pngle->imageHeight) {\r\n\t\t\t_height = pngle->imageHeight;\r\n\t\t\t_rows = (height - pngle->imageHeight) / 2;\r\n\t}\r\n\tESP_LOGD(__FUNCTION__, \"_height=%d _rows=%d\", _height, _rows);\r\n\tuint16_t *colors = (uint16_t*)malloc(sizeof(uint16_t) * _width);\r\n\r\n#if 0\r\n\tfor(int y = 0; y < _height; y++){\r\n\t\tfor(int x = 0;x < _width; x++){\r\n\t\t\tpixel_png pixel = pngle->pixels[y][x];\r\n\t\t\tuint16_t color = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n\t\t\tlcdDrawPixel(dev, x+_cols, y+_rows, color);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tfor(int y = 0; y < _height; y++){\r\n\t\tfor(int x = 0;x < _width; x++){\r\n\t\t\t//pixel_png pixel = pngle->pixels[y][x];\r\n\t\t\t//colors[x] = rgb565_conv(pixel.red, pixel.green, pixel.blue);\r\n\t\t\tcolors[x] = pngle->pixels[y][x];\r\n\t\t}\r\n\t\tlcdDrawMultiPixels(dev, _cols, y+_rows, _width, colors);\r\n\t\tvTaskDelay(1);\r\n\t}\r\n\tfree(colors);\r\n\tpngle_destroy(pngle, width, height);\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nTickType_t CodeTest(TFT_t * dev, FontxFile *fx, int width, int height) {\r\n\tTickType_t startTick, endTick, diffTick;\r\n\tstartTick = xTaskGetTickCount();\r\n\r\n\t// get font width & height\r\n\tuint8_t buffer[FontxGlyphBufSize];\r\n\tuint8_t fontWidth;\r\n\tuint8_t fontHeight;\r\n\tGetFontx(fx, 0, buffer, &fontWidth, &fontHeight);\r\n\t//ESP_LOGI(__FUNCTION__,\"fontWidth=%d fontHeight=%d\",fontWidth,fontHeight);\r\n\tuint8_t xmoji = width / fontWidth;\r\n\tuint8_t ymoji = height / fontHeight;\r\n\t//ESP_LOGI(__FUNCTION__,\"xmoji=%d ymoji=%d\",xmoji, ymoji);\r\n\r\n\r\n\tuint16_t color;\r\n\tlcdFillScreen(dev, BLACK);\r\n\tuint8_t code;\r\n\r\n\tcolor = CYAN;\r\n\tlcdSetFontDirection(dev, 0);\r\n\tcode = 0xA0;\r\n\tfor(int y=0;y<ymoji;y++) {\r\n\t\tuint16_t xpos = 0;\r\n\t\tuint16_t ypos =  fontHeight*(y+1)-1;\r\n\t\tfor(int x=0;x<xmoji;x++) {\r\n\t\t\txpos = lcdDrawCode(dev, fx, xpos, ypos, code, color);\r\n\t\t\tif (code == 0xFF) break;\r\n\t\t\tcode++;\r\n\t\t}\r\n\t}\r\n\r\n\tendTick = xTaskGetTickCount();\r\n\tdiffTick = endTick - startTick;\r\n\tESP_LOGI(__FUNCTION__, \"elapsed time[ms]:%\"PRIu32,diffTick*portTICK_PERIOD_MS);\r\n\treturn diffTick;\r\n}\r\n\r\nvoid ST7789(void *pvParameters)\r\n{\r\n\t// set font file\r\n\tFontxFile fx16G[2];\r\n\tFontxFile fx24G[2];\r\n\tFontxFile fx32G[2];\r\n\tFontxFile fx32L[2];\r\n\tInitFontx(fx16G,\"/spiffs/ILGH16XB.FNT\",\"\"); // 8x16Dot Gothic\r\n\tInitFontx(fx24G,\"/spiffs/ILGH24XB.FNT\",\"\"); // 12x24Dot Gothic\r\n\tInitFontx(fx32G,\"/spiffs/ILGH32XB.FNT\",\"\"); // 16x32Dot Gothic\r\n\tInitFontx(fx32L,\"/spiffs/LATIN32B.FNT\",\"\"); // 16x32Dot Latin\r\n\r\n\tFontxFile fx16M[2];\r\n\tFontxFile fx24M[2];\r\n\tFontxFile fx32M[2];\r\n\tInitFontx(fx16M,\"/spiffs/ILMH16XB.FNT\",\"\"); // 8x16Dot Mincyo\r\n\tInitFontx(fx24M,\"/spiffs/ILMH24XB.FNT\",\"\"); // 12x24Dot Mincyo\r\n\tInitFontx(fx32M,\"/spiffs/ILMH32XB.FNT\",\"\"); // 16x32Dot Mincyo\r\n\t\r\n\tTFT_t dev;\r\n\tspi_master_init(&dev, CONFIG_MOSI_GPIO, CONFIG_SCLK_GPIO, CONFIG_CS_GPIO, CONFIG_DC_GPIO, CONFIG_RESET_GPIO, CONFIG_BL_GPIO);\r\n\tlcdInit(&dev, CONFIG_WIDTH, CONFIG_HEIGHT, CONFIG_OFFSETX, CONFIG_OFFSETY);\r\n\r\n#if CONFIG_INVERSION\r\n\tESP_LOGI(TAG, \"Enable Display Inversion\");\r\n\tlcdInversionOn(&dev);\r\n#endif\r\n\r\n#if 0\r\n\twhile (1) {\r\n\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tchar file[32];\r\n\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n#endif\r\n\t}\r\n#endif\r\n\r\n#if 0\r\n\t//for TEST\r\n\tlcdDrawFillRect(&dev, 0, 0, 10, 10, RED);\r\n\tlcdDrawFillRect(&dev, 10, 10, 20, 20, GREEN);\r\n\tlcdDrawFillRect(&dev, 20, 20, 30, 30, BLUE);\r\n#endif\r\n\r\n\twhile(1) {\r\n\r\n\t\tFillTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tColorBarTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tArrowTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tLineTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tCircleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tRoundRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tRectAngleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tTriangleTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tif (CONFIG_WIDTH >= 240) {\r\n\t\t\tDirectionTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t} else {\r\n\t\t\tDirectionTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t}\r\n\t\tWAIT;\r\n\r\n\t\tif (CONFIG_WIDTH >= 240) {\r\n\t\t\tHorizontalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t} else {\r\n\t\t\tHorizontalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t}\r\n\t\tWAIT;\r\n\r\n\t\tif (CONFIG_WIDTH >= 240) {\r\n\t\t\tVerticalTest(&dev, fx24G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t} else {\r\n\t\t\tVerticalTest(&dev, fx16G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\t}\r\n\t\tWAIT;\r\n\r\n\t\tFillRectTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tColorTest(&dev, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tCodeTest(&dev, fx32G, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tCodeTest(&dev, fx32L, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tchar file[32];\r\n\t\tstrcpy(file, \"/spiffs/image.bmp\");\r\n\t\tBMPTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n#ifndef CONFIG_IDF_TARGET_ESP32S2\r\n\t\tstrcpy(file, \"/spiffs/esp32.jpeg\");\r\n\t\tJPEGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n#endif\r\n\r\n\t\tstrcpy(file, \"/spiffs/esp_logo.png\");\r\n\t\tPNGTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\tstrcpy(file, \"/spiffs/qrcode.bmp\");\r\n\t\tQRTest(&dev, file, CONFIG_WIDTH, CONFIG_HEIGHT);\r\n\t\tWAIT;\r\n\r\n\t\t// Multi Font Test\r\n\t\tuint16_t color;\r\n\t\tuint8_t ascii[40];\r\n\t\tuint16_t margin = 10;\r\n\t\tlcdFillScreen(&dev, BLACK);\r\n\t\tcolor = WHITE;\r\n\t\tlcdSetFontDirection(&dev, 0);\r\n\t\tuint16_t xpos = 0;\r\n\t\tuint16_t ypos = 15;\r\n\t\tint xd = 0;\r\n\t\tint yd = 1;\r\n\t\tif(CONFIG_WIDTH < CONFIG_HEIGHT) {\r\n\t\t\tlcdSetFontDirection(&dev, 1);\r\n\t\t\txpos = (CONFIG_WIDTH-1)-16;\r\n\t\t\typos = 0;\r\n\t\t\txd = 1;\r\n\t\t\tyd = 0;\r\n\t\t}\r\n\t\tstrcpy((char *)ascii, \"16Dot Gothic Font\");\r\n\t\tlcdDrawString(&dev, fx16G, xpos, ypos, ascii, color);\r\n\r\n\t\txpos = xpos - (24 * xd) - (margin * xd);\r\n\t\typos = ypos + (16 * yd) + (margin * yd);\r\n\t\tstrcpy((char *)ascii, \"24Dot Gothic Font\");\r\n\t\tlcdDrawString(&dev, fx24G, xpos, ypos, ascii, color);\r\n\r\n\t\txpos = xpos - (32 * xd) - (margin * xd);\r\n\t\typos = ypos + (24 * yd) + (margin * yd);\r\n\t\tif (CONFIG_WIDTH >= 240) {\r\n\t\t\tstrcpy((char *)ascii, \"32Dot Gothic Font\");\r\n\t\t\tlcdDrawString(&dev, fx32G, xpos, ypos, ascii, color);\r\n\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n\t\t\typos = ypos + (32 * yd) + (margin * yd);\r\n\t\t}\r\n\r\n\t\txpos = xpos - (10 * xd) - (margin * xd);\r\n\t\typos = ypos + (10 * yd) + (margin * yd);\r\n\t\tstrcpy((char *)ascii, \"16Dot Mincyo Font\");\r\n\t\tlcdDrawString(&dev, fx16M, xpos, ypos, ascii, color);\r\n\r\n\t\txpos = xpos - (24 * xd) - (margin * xd);;\r\n\t\typos = ypos + (16 * yd) + (margin * yd);\r\n\t\tstrcpy((char *)ascii, \"24Dot Mincyo Font\");\r\n\t\tlcdDrawString(&dev, fx24M, xpos, ypos, ascii, color);\r\n\r\n\t\tif (CONFIG_WIDTH >= 240) {\r\n\t\t\txpos = xpos - (32 * xd) - (margin * xd);;\r\n\t\t\typos = ypos + (24 * yd) + (margin * yd);\r\n\t\t\tstrcpy((char *)ascii, \"32Dot Mincyo Font\");\r\n\t\t\tlcdDrawString(&dev, fx32M, xpos, ypos, ascii, color);\r\n\t\t}\r\n\t\tlcdSetFontDirection(&dev, 0);\r\n\t\tWAIT;\r\n\r\n\t} // end while\r\n\r\n\t// never reach\r\n\twhile (1) {\r\n\t\tvTaskDelay(2000 / portTICK_PERIOD_MS);\r\n\t}\r\n}\r\n\r\n\r\nvoid app_main(void)\r\n{\r\n\tESP_LOGI(TAG, \"Initializing SPIFFS\");\r\n\r\n\tesp_vfs_spiffs_conf_t conf = {\r\n\t\t.base_path = \"/spiffs\",\r\n\t\t.partition_label = NULL,\r\n\t\t.max_files = 12,\r\n\t\t.format_if_mount_failed =true\r\n\t};\r\n\r\n\t// Use settings defined above toinitialize and mount SPIFFS filesystem.\r\n\t// Note: esp_vfs_spiffs_register is anall-in-one convenience function.\r\n\tesp_err_t ret = esp_vfs_spiffs_register(&conf);\r\n\r\n\tif (ret != ESP_OK) {\r\n\t\tif (ret == ESP_FAIL) {\r\n\t\t\tESP_LOGE(TAG, \"Failed to mount or format filesystem\");\r\n\t\t} else if (ret == ESP_ERR_NOT_FOUND) {\r\n\t\t\tESP_LOGE(TAG, \"Failed to find SPIFFS partition\");\r\n\t\t} else {\r\n\t\t\tESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\",esp_err_to_name(ret));\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\tsize_t total = 0, used = 0;\r\n\tret = esp_spiffs_info(NULL, &total,&used);\r\n\tif (ret != ESP_OK) {\r\n\t\tESP_LOGE(TAG,\"Failed to get SPIFFS partition information (%s)\",esp_err_to_name(ret));\r\n\t} else {\r\n\t\tESP_LOGI(TAG,\"Partition size: total: %d, used: %d\", total, used);\r\n\t}\r\n\r\n\tSPIFFS_Directory(\"/spiffs/\");\r\n\txTaskCreate(ST7789, \"ST7789\", 1024*6, NULL, 2, NULL);\r\n}\r\n"
        }
    ]
}