{
    "sourceFile": "main/st7796s.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1731814870967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731817014144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -538,8 +538,367 @@\n     lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n     lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n }\r\n \r\n+// Draw circle\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    do {\r\n+        lcdDrawPixel(dev, x0 - x, y0 + y, color);\r\n+        lcdDrawPixel(dev, x0 - y, y0 - x, color);\r\n+        lcdDrawPixel(dev, x0 + x, y0 - y, color);\r\n+        lcdDrawPixel(dev, x0 + y, y0 + x, color);\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+}\r\n+\r\n+// Draw circle of filling\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawFillCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    int ChangeX;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    ChangeX = 1;\r\n+    do {\r\n+        if (ChangeX) {\r\n+            lcdDrawLine(dev, x0 - x, y0 - y, x0 - x, y0 + y, color);\r\n+            lcdDrawLine(dev, x0 + x, y0 - y, x0 + x, y0 + y, color);\r\n+        }\r\n+        ChangeX = (old_err = err) <= x;\r\n+        if (ChangeX)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y <= 0);\r\n+}\r\n+\r\n+// Draw rectangle with round corner\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawRoundRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    uint16_t temp;\r\n+\r\n+    if (x1 > x2) {\r\n+        temp = x1;\r\n+        x1 = x2;\r\n+        x2 = temp;\r\n+    }\r\n+\r\n+    if (y1 > y2) {\r\n+        temp = y1;\r\n+        y1 = y2;\r\n+        y2 = temp;\r\n+    }\r\n+\r\n+    if (x2 - x1 < r)\r\n+        return;\r\n+    if (y2 - y1 < r)\r\n+        return;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+\r\n+    do {\r\n+        if (x) {\r\n+            lcdDrawPixel(dev, x1 + r - x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x1 + r - x, y2 - r - y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y2 - r - y, color);\r\n+        }\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+\r\n+    lcdDrawLine(dev, x1 + r, y1, x2 - r, y1, color);\r\n+    lcdDrawLine(dev, x1 + r, y2, x2 - r, y2, color);\r\n+    lcdDrawLine(dev, x1, y1 + r, x1, y2 - r, color);\r\n+    lcdDrawLine(dev, x2, y1 + r, x2, y2 - r, color);\r\n+}\r\n+\r\n+// Draw arrow\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n+void lcdDrawArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+}\r\n+\r\n+// Draw arrow of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+void lcdDrawFillArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x0, y0, x1, y1, color);\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+\r\n+    for (int ww = w - 1; ww > 0; ww--) {\r\n+        L[0] = x1 - Uy * ww - Ux * v;\r\n+        L[1] = y1 + Ux * ww - Uy * v;\r\n+        R[0] = x1 + Uy * ww - Ux * v;\r\n+        R[1] = y1 - Ux * ww - Uy * v;\r\n+        lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+        lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    }\r\n+}\r\n+\r\n+// RGB565 conversion\r\n+// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n+// Bit image \"RRRRRGGGGGGBBBBB\"\r\n+uint16_t rgb565_conv(uint16_t r, uint16_t g, uint16_t b) {\r\n+    return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n+}\r\n+\r\n+// Draw ASCII character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// ascii: ascii code\r\n+// color:color\r\n+int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n+\tuint16_t xx,yy,bit,ofs;\r\n+\tunsigned char fonts[128]; // font pattern\r\n+\tunsigned char pw, ph;\r\n+\tint h,w;\r\n+\tuint16_t mask;\r\n+\tbool rc;\r\n+\r\n+\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n+\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n+\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n+\tif (!rc) return 0;\r\n+\r\n+\tint16_t xd1 = 0;\r\n+\tint16_t yd1 = 0;\r\n+\tint16_t xd2 = 0;\r\n+\tint16_t yd2 = 0;\r\n+\tuint16_t xss = 0;\r\n+\tuint16_t yss = 0;\r\n+\tint16_t xsd = 0;\r\n+\tint16_t ysd = 0;\r\n+\tint16_t next = 0;\r\n+\tuint16_t x0  = 0;\r\n+\tuint16_t x1  = 0;\r\n+\tuint16_t y0  = 0;\r\n+\tuint16_t y1  = 0;\r\n+\tif (dev->_font_direction == 0) {\r\n+\t\txd1 = +1;\r\n+\t\tyd1 = +1; //-1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y - (ph - 1);\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x + pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y - (ph-1);\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n+\t} else if (dev->_font_direction == 2) {\r\n+\t\txd1 = -1;\r\n+\t\tyd1 = -1; //+1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y + ph + 1;\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x - pw;\r\n+\r\n+\t\tx0\t= x - (pw-1);\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y + (ph-1);\r\n+\t} else if (dev->_font_direction == 1) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = -1;\r\n+\t\tyd2 = +1; //-1;\r\n+\t\txss =  x + ph;\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y + pw; //y - pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x + (ph-1);\r\n+\t\ty1\t= y + (pw-1);\r\n+\t} else if (dev->_font_direction == 3) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = +1;\r\n+\t\tyd2 = -1; //+1;\r\n+\t\txss =  x - (ph - 1);\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y - pw; //y + pw;\r\n+\r\n+\t\tx0\t= x - (ph-1);\r\n+\t\ty0\t= y - (pw-1);\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y;\r\n+\t}\r\n+\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\t\r\n+\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1, y1, dev->_font_fill_color);\r\n+\r\n+\r\n+\tint bits;\r\n+\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n+\tofs = 0;\r\n+\tyy = yss;\r\n+\txx = xss;\r\n+\tfor(h=0;h<ph;h++) {\r\n+\t\tif(xsd) xx = xss;\r\n+\t\tif(ysd) yy = yss;\r\n+\t\t//for(w=0;w<(pw/8);w++) {\r\n+\t\tbits = pw;\r\n+\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n+\t\t\tmask = 0x80;\r\n+\t\t\tfor(bit=0;bit<8;bit++) {\r\n+\t\t\t\tbits--;\r\n+\t\t\t\tif (bits < 0) continue;\r\n+\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n+\t\t\t\tif (fonts[ofs] & mask) {\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\txx = xx + xd1;\r\n+\t\t\t\tyy = yy + yd2;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t}\r\n+\t\t\tofs++;\r\n+\t\t}\r\n+\t\tyy = yy + yd1;\r\n+\t\txx = xx + xd2;\r\n+\t}\r\n+\r\n+\tif (next < 0) next = 0;\r\n+\treturn next;\r\n+}\r\n+\r\n+int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n+\tint length = strlen((char *)ascii);\r\n+\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n+\tfor(int i=0;i<length;i++) {\r\n+\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+\r\n+// Draw Non-Alphanumeric character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// code:character code\r\n+// color:color\r\n+int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n+\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n+\tif (dev->_font_direction == 0)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 1)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 2)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 3)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n #if 0\r\n // Draw UTF8 character\r\n // x:X coordinate\r\n // y:Y coordinate\r\n"
                },
                {
                    "date": 1731817443853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -984,9 +984,9 @@\n \r\n // Backlight ON\r\n void lcdBacklightOn(TFT_t *dev) {\r\n     if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 1);\r\n+        gpio_set_level(dev->_bl, 0);\r\n         ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n     }\r\n }\r\n \r\n"
                },
                {
                    "date": 1731817829989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -976,9 +976,9 @@\n \r\n // Backlight OFF\r\n void lcdBacklightOff(TFT_t *dev) {\r\n     if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 0);\r\n+        gpio_set_level(dev->_bl, 12);\r\n         ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n     }\r\n }\r\n \r\n"
                },
                {
                    "date": 1731817969660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1004 @@\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+#include <math.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+\r\n+#include <driver/spi_master.h>\r\n+#include <driver/gpio.h>\r\n+#include \"esp_log.h\"\r\n+\r\n+#include \"st7796s.h\"  // Updated to the correct header file\r\n+\r\n+#define TAG \"ST7796S\"\r\n+#define _DEBUG_ 0\r\n+\r\n+#if CONFIG_SPI2_HOST\r\n+#define HOST_ID SPI2_HOST\r\n+#elif CONFIG_SPI3_HOST\r\n+#define HOST_ID SPI3_HOST\r\n+#endif\r\n+\r\n+static const int SPI_Command_Mode = 0;\r\n+static const int SPI_Data_Mode = 1;\r\n+static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n+\r\n+void spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n+                     int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n+    esp_err_t ret;\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n+    if (GPIO_CS >= 0) {\r\n+        gpio_reset_pin(GPIO_CS);\r\n+        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_CS, 1);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n+    gpio_reset_pin(GPIO_DC);\r\n+    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n+    gpio_set_level(GPIO_DC, 0);\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n+    if (GPIO_RESET >= 0) {\r\n+        gpio_reset_pin(GPIO_RESET);\r\n+        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_RESET, 1);  // Ensure the reset pin starts high\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 0);  // Pulse reset pin\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n+        delayMS(100);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n+\r\n+    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n+    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n+    spi_bus_config_t buscfg = {\r\n+        .mosi_io_num = GPIO_MOSI,\r\n+        .miso_io_num = -1,\r\n+        .sclk_io_num = GPIO_SCLK,\r\n+        .quadwp_io_num = -1,\r\n+        .quadhd_io_num = -1,\r\n+        .max_transfer_sz = 6 * 1024,\r\n+        .flags = SPICOMMON_BUSFLAG_MASTER,\r\n+    };\r\n+\r\n+    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n+    ESP_LOGI(TAG, \"spi_bus_initialize=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    spi_device_interface_config_t devcfg;\r\n+    memset(&devcfg, 0, sizeof(devcfg));\r\n+    devcfg.clock_speed_hz = SPI_Frequency;\r\n+    devcfg.queue_size = 7;\r\n+    devcfg.mode = 0;  // Changed from 2 to 0\r\n+    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+\r\n+    if (GPIO_CS >= 0) {\r\n+        devcfg.spics_io_num = GPIO_CS;\r\n+    } else {\r\n+        devcfg.spics_io_num = -1;\r\n+    }\r\n+\r\n+    spi_device_handle_t handle;\r\n+    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n+    ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    dev->_dc = GPIO_DC;\r\n+    dev->_bl = GPIO_BL;\r\n+    dev->_SPIHandle = handle;\r\n+}\r\n+\r\n+bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n+    spi_transaction_t SPITransaction;\r\n+    esp_err_t ret;\r\n+\r\n+    if (DataLength > 0) {\r\n+        memset(&SPITransaction, 0, sizeof(spi_transaction_t));\r\n+        SPITransaction.length = DataLength * 8;\r\n+        SPITransaction.tx_buffer = Data;\r\n+        ret = spi_device_polling_transmit(SPIHandle, &SPITransaction);\r\n+        assert(ret == ESP_OK);\r\n+    }\r\n+\r\n+    return true;\r\n+}\r\n+\r\n+bool spi_master_write_command(TFT_t *dev, uint8_t cmd) {\r\n+    uint8_t Byte = cmd;\r\n+    gpio_set_level(dev->_dc, SPI_Command_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n+}\r\n+\r\n+bool spi_master_write_data_byte(TFT_t *dev, uint8_t data) {\r\n+    uint8_t Byte = data;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n+}\r\n+\r\n+bool spi_master_write_data_word(TFT_t *dev, uint16_t data) {\r\n+    uint8_t Byte[2];\r\n+    Byte[0] = (data >> 8) & 0xFF;\r\n+    Byte[1] = data & 0xFF;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, Byte, 2);\r\n+}\r\n+\r\n+bool spi_master_write_addr(TFT_t *dev, uint16_t addr1, uint16_t addr2) {\r\n+    uint8_t Byte[4];\r\n+    Byte[0] = (addr1 >> 8) & 0xFF;\r\n+    Byte[1] = addr1 & 0xFF;\r\n+    Byte[2] = (addr2 >> 8) & 0xFF;\r\n+    Byte[3] = addr2 & 0xFF;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, Byte, 4);\r\n+}\r\n+\r\n+bool spi_master_write_color(TFT_t *dev, uint16_t color, uint32_t size) {\r\n+    uint8_t Byte[1024];\r\n+    uint32_t len = size * 2;\r\n+    uint32_t max_chunk = sizeof(Byte);\r\n+\r\n+    while (len > 0) {\r\n+        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n+        uint32_t color_count = chunk_size / 2;\r\n+        for (uint32_t i = 0; i < color_count; i++) {\r\n+            Byte[i * 2] = (color >> 8) & 0xFF;\r\n+            Byte[i * 2 + 1] = color & 0xFF;\r\n+        }\r\n+        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n+        len -= chunk_size;\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Add 202001\r\n+bool spi_master_write_colors(TFT_t *dev, uint16_t *colors, uint16_t size) {\r\n+    uint8_t Byte[1024];\r\n+    uint32_t index = 0;\r\n+    uint32_t len = size * 2;\r\n+    uint32_t max_chunk = sizeof(Byte);\r\n+\r\n+    while (len > 0) {\r\n+        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n+        uint32_t color_count = chunk_size / 2;\r\n+        for (uint32_t i = 0; i < color_count; i++) {\r\n+            Byte[i * 2] = (colors[index] >> 8) & 0xFF;\r\n+            Byte[i * 2 + 1] = colors[index] & 0xFF;\r\n+            index++;\r\n+        }\r\n+        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n+        len -= chunk_size;\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+void delayMS(int ms) {\r\n+    vTaskDelay(pdMS_TO_TICKS(ms));\r\n+}\r\n+\r\n+void lcdInit(TFT_t *dev, int width, int height, int offsetx, int offsety) {\r\n+    dev->_width = width;\r\n+    dev->_height = height;\r\n+    dev->_offsetx = offsetx;\r\n+    dev->_offsety = offsety;\r\n+    dev->_font_direction = DIRECTION0;\r\n+    dev->_font_fill = false;\r\n+    dev->_font_underline = false;\r\n+\r\n+    ESP_LOGI(TAG, \"Initializing ST7796S LCD\");\r\n+\r\n+    // Hardware reset\r\n+    if (dev->_reset >= 0) {\r\n+        gpio_set_level(dev->_reset, 0); // Set RESX low\r\n+        delayMS(20);                   // Minimum 10ms\r\n+        gpio_set_level(dev->_reset, 1); // Set RESX high\r\n+        delayMS(120);                  // Wait for reset complete\r\n+    }\r\n+\r\n+    // Software reset\r\n+    ESP_LOGI(TAG, \"Sending Software Reset\");\r\n+    spi_master_write_command(dev, 0x01);  // SWRESET: Software Reset\r\n+    delayMS(150);                        // Wait for reset process\r\n+\r\n+    // Exit Sleep mode\r\n+    ESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n+    spi_master_write_command(dev, 0x11);  // SLPOUT: Sleep Out\r\n+    delayMS(120);\r\n+\r\n+    // Memory Data Access Control\r\n+    ESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n+    spi_master_write_command(dev, 0x36);  // MADCTL: Memory Data Access Control\r\n+    spi_master_write_data_byte(dev, 0x48); // Adjust orientation (0x48 for default landscape)\r\n+    delayMS(10);\r\n+\r\n+    // Interface Pixel Format (16-bit/pixel)\r\n+    ESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n+    spi_master_write_command(dev, 0x3A);  // COLMOD: Interface Pixel Format\r\n+    spi_master_write_data_byte(dev, 0x55); // 16-bit/pixel (RGB 5-6-5)\r\n+    delayMS(10);\r\n+\r\n+    // Porch Setting\r\n+    ESP_LOGI(TAG, \"Setting Porch Control\");\r\n+    spi_master_write_command(dev, 0xB2);  // PORCTRL: Porch Control\r\n+    spi_master_write_data_byte(dev, 0x0C); // Front Porch\r\n+    spi_master_write_data_byte(dev, 0x0C); // Back Porch\r\n+    spi_master_write_data_byte(dev, 0x00); // Vertical Porch\r\n+    spi_master_write_data_byte(dev, 0x33);\r\n+    spi_master_write_data_byte(dev, 0x33);\r\n+    delayMS(10);\r\n+\r\n+    // VCOM Setting\r\n+    ESP_LOGI(TAG, \"Setting VCOM\");\r\n+    spi_master_write_command(dev, 0xBB);  // VCOMS: VCOM Setting\r\n+    spi_master_write_data_byte(dev, 0x35); // VCOM voltage level (1.175V)\r\n+    delayMS(10);\r\n+\r\n+    // LCM Control\r\n+    ESP_LOGI(TAG, \"Setting LCM Control\");\r\n+    spi_master_write_command(dev, 0xC0);  // LCMCTRL: LCM Control\r\n+    spi_master_write_data_byte(dev, 0x2C); // Default\r\n+    delayMS(10);\r\n+\r\n+    // VDV and VRH Command Enable\r\n+    ESP_LOGI(TAG, \"Enabling VDV and VRH Commands\");\r\n+    spi_master_write_command(dev, 0xC2);  // VDVVRHEN: Enable VDV and VRH\r\n+    spi_master_write_data_byte(dev, 0x01); // Enable\r\n+    delayMS(10);\r\n+\r\n+    // VRH Set\r\n+    ESP_LOGI(TAG, \"Setting VRH\");\r\n+    spi_master_write_command(dev, 0xC3);  // VRHS: VRH Set\r\n+    spi_master_write_data_byte(dev, 0x12); // Default\r\n+    delayMS(10);\r\n+\r\n+    // VDV Set\r\n+    ESP_LOGI(TAG, \"Setting VDV\");\r\n+    spi_master_write_command(dev, 0xC4);  // VDVS: VDV Set\r\n+    spi_master_write_data_byte(dev, 0x20); // Default\r\n+    delayMS(10);\r\n+\r\n+    // Frame Rate Control\r\n+    ESP_LOGI(TAG, \"Setting Frame Rate Control\");\r\n+    spi_master_write_command(dev, 0xC6);  // FRCTRL2: Frame Rate Control\r\n+    spi_master_write_data_byte(dev, 0x0F); // Default frame rate: 60Hz\r\n+    delayMS(10);\r\n+\r\n+    // Power Control 1\r\n+    ESP_LOGI(TAG, \"Setting Power Control 1\");\r\n+    spi_master_write_command(dev, 0xD0);  // PWCTRL1: Power Control 1\r\n+    spi_master_write_data_byte(dev, 0xA4); // Default\r\n+    spi_master_write_data_byte(dev, 0xA1); // Default\r\n+    delayMS(10);\r\n+\r\n+    // Positive Voltage Gamma Control\r\n+    ESP_LOGI(TAG, \"Setting Positive Voltage Gamma Control\");\r\n+    spi_master_write_command(dev, 0xE0);  // PGAMCTRL: Positive Gamma Control\r\n+    uint8_t positive_gamma[] = {0xD0, 0x08, 0x11, 0x08, 0x0C, 0x15, 0x39, 0x33, 0x50, 0x36, 0x13, 0x14, 0x29, 0x2D};\r\n+    for (int i = 0; i < sizeof(positive_gamma); i++) {\r\n+        spi_master_write_data_byte(dev, positive_gamma[i]);\r\n+    }\r\n+    delayMS(10);\r\n+\r\n+    // Negative Voltage Gamma Control\r\n+    ESP_LOGI(TAG, \"Setting Negative Voltage Gamma Control\");\r\n+    spi_master_write_command(dev, 0xE1);  // NVGAMCTRL: Negative Gamma Control\r\n+    uint8_t negative_gamma[] = {0xD0, 0x08, 0x10, 0x08, 0x06, 0x06, 0x39, 0x44, 0x51, 0x0B, 0x16, 0x14, 0x2F, 0x31};\r\n+    for (int i = 0; i < sizeof(negative_gamma); i++) {\r\n+        spi_master_write_data_byte(dev, negative_gamma[i]);\r\n+    }\r\n+    delayMS(10);\r\n+\r\n+    // Enable Display Inversion\r\n+    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n+    delayMS(10);\r\n+\r\n+    // Normal Display Mode On\r\n+    ESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n+    spi_master_write_command(dev, 0x13);  // NORON: Normal Display Mode On\r\n+    delayMS(10);\r\n+\r\n+    // Turn on Display\r\n+    ESP_LOGI(TAG, \"Turning Display On\");\r\n+    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n+    delayMS(120);                          // Wait for display to turn on\r\n+\r\n+    // Backlight control\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 1);\r\n+        ESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n+    }\r\n+}\r\n+\r\n+// Draw pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// color:color\r\n+void lcdDrawPixel(TFT_t *dev, uint16_t x, uint16_t y, uint16_t color) {\r\n+    if (x >= dev->_width)\r\n+        return;\r\n+    if (y >= dev->_height)\r\n+        return;\r\n+\r\n+    uint16_t _x = x + dev->_offsetx;\r\n+    uint16_t _y = y + dev->_offsety;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x, _x);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y, _y);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+    spi_master_write_data_word(dev, color);\r\n+}\r\n+\r\n+// Draw multi pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// size:Number of colors\r\n+// colors:colors\r\n+void lcdDrawMultiPixels(TFT_t *dev, uint16_t x, uint16_t y, uint16_t size, uint16_t *colors) {\r\n+    if (x + size > dev->_width)\r\n+        return;\r\n+    if (y >= dev->_height)\r\n+        return;\r\n+\r\n+    uint16_t _x1 = x + dev->_offsetx;\r\n+    uint16_t _x2 = _x1 + (size - 1);\r\n+    uint16_t _y1 = y + dev->_offsety;\r\n+    uint16_t _y2 = _y1;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x1, _x2);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y1, _y2);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+    spi_master_write_colors(dev, colors, size);\r\n+}\r\n+\r\n+// Draw rectangle of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End X coordinate\r\n+// y2:End Y coordinate\r\n+// color:color\r\n+void lcdDrawFillRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    if (x1 >= dev->_width)\r\n+        return;\r\n+    if (x2 >= dev->_width)\r\n+        x2 = dev->_width - 1;\r\n+    if (y1 >= dev->_height)\r\n+        return;\r\n+    if (y2 >= dev->_height)\r\n+        y2 = dev->_height - 1;\r\n+\r\n+    uint16_t _x1 = x1 + dev->_offsetx;\r\n+    uint16_t _x2 = x2 + dev->_offsetx;\r\n+    uint16_t _y1 = y1 + dev->_offsety;\r\n+    uint16_t _y2 = y2 + dev->_offsety;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x1, _x2);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y1, _y2);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+\r\n+    uint32_t size = (_x2 - _x1 + 1) * (_y2 - _y1 + 1);\r\n+    spi_master_write_color(dev, color, size);\r\n+}\r\n+\r\n+// Display OFF\r\n+void lcdDisplayOff(TFT_t *dev) {\r\n+    spi_master_write_command(dev, 0x28);  // DISPOFF: Display Off\r\n+}\r\n+\r\n+// Display ON\r\n+void lcdDisplayOn(TFT_t *dev) {\r\n+    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n+}\r\n+\r\n+// Fill screen\r\n+// color:color\r\n+void lcdFillScreen(TFT_t *dev, uint16_t color) {\r\n+    lcdDrawFillRect(dev, 0, 0, dev->_width - 1, dev->_height - 1, color);\r\n+}\r\n+\r\n+// Draw line\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawLine(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    int dx, dy, sx, sy, err, e2;\r\n+\r\n+    dx = abs(x2 - x1);\r\n+    dy = -abs(y2 - y1);\r\n+\r\n+    sx = (x1 < x2) ? 1 : -1;\r\n+    sy = (y1 < y2) ? 1 : -1;\r\n+\r\n+    err = dx + dy;\r\n+\r\n+    while (1) {\r\n+        lcdDrawPixel(dev, x1, y1, color);\r\n+        if (x1 == x2 && y1 == y2)\r\n+            break;\r\n+        e2 = 2 * err;\r\n+        if (e2 >= dy) {\r\n+            err += dy;\r\n+            x1 += sx;\r\n+        }\r\n+        if (e2 <= dx) {\r\n+            err += dx;\r\n+            y1 += sy;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// Draw rectangle\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    lcdDrawLine(dev, x1, y1, x2, y1, color);\r\n+    lcdDrawLine(dev, x2, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x2, y2, x1, y2, color);\r\n+    lcdDrawLine(dev, x1, y2, x1, y1, color);\r\n+}\r\n+\r\n+// Draw rectangle with angle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of rectangle\r\n+// h:Height of rectangle\r\n+// angle:Angle of rectangle\r\n+// color:color\r\n+\r\n+// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawRectAngle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+    double xd, yd, rd;\r\n+    int x1, y1;\r\n+    int x2, y2;\r\n+    int x3, y3;\r\n+    int x4, y4;\r\n+    rd = -angle * M_PI / 180.0;\r\n+    xd = 0.0 - w / 2;\r\n+    yd = h / 2;\r\n+    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    yd = 0.0 - yd;\r\n+    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = w / 2;\r\n+    yd = h / 2;\r\n+    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    yd = 0.0 - yd;\r\n+    x4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+    lcdDrawLine(dev, x2, y2, x4, y4, color);\r\n+    lcdDrawLine(dev, x3, y3, x4, y4, color);\r\n+}\r\n+\r\n+// Draw triangle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of triangle\r\n+// h:Height of triangle\r\n+// angle:Angle of triangle\r\n+// color:color\r\n+\r\n+// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawTriangle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+    double xd, yd, rd;\r\n+    int x1, y1;\r\n+    int x2, y2;\r\n+    int x3, y3;\r\n+    rd = -angle * M_PI / 180.0;\r\n+    xd = 0.0;\r\n+    yd = h / 2;\r\n+    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = w / 2;\r\n+    yd = 0.0 - yd;\r\n+    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = 0.0 - w / 2;\r\n+    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+    lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n+}\r\n+\r\n+// Draw circle\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    do {\r\n+        lcdDrawPixel(dev, x0 - x, y0 + y, color);\r\n+        lcdDrawPixel(dev, x0 - y, y0 - x, color);\r\n+        lcdDrawPixel(dev, x0 + x, y0 - y, color);\r\n+        lcdDrawPixel(dev, x0 + y, y0 + x, color);\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+}\r\n+\r\n+// Draw circle of filling\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawFillCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    int ChangeX;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    ChangeX = 1;\r\n+    do {\r\n+        if (ChangeX) {\r\n+            lcdDrawLine(dev, x0 - x, y0 - y, x0 - x, y0 + y, color);\r\n+            lcdDrawLine(dev, x0 + x, y0 - y, x0 + x, y0 + y, color);\r\n+        }\r\n+        ChangeX = (old_err = err) <= x;\r\n+        if (ChangeX)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y <= 0);\r\n+}\r\n+\r\n+// Draw rectangle with round corner\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawRoundRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    uint16_t temp;\r\n+\r\n+    if (x1 > x2) {\r\n+        temp = x1;\r\n+        x1 = x2;\r\n+        x2 = temp;\r\n+    }\r\n+\r\n+    if (y1 > y2) {\r\n+        temp = y1;\r\n+        y1 = y2;\r\n+        y2 = temp;\r\n+    }\r\n+\r\n+    if (x2 - x1 < r)\r\n+        return;\r\n+    if (y2 - y1 < r)\r\n+        return;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+\r\n+    do {\r\n+        if (x) {\r\n+            lcdDrawPixel(dev, x1 + r - x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x1 + r - x, y2 - r - y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y2 - r - y, color);\r\n+        }\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+\r\n+    lcdDrawLine(dev, x1 + r, y1, x2 - r, y1, color);\r\n+    lcdDrawLine(dev, x1 + r, y2, x2 - r, y2, color);\r\n+    lcdDrawLine(dev, x1, y1 + r, x1, y2 - r, color);\r\n+    lcdDrawLine(dev, x2, y1 + r, x2, y2 - r, color);\r\n+}\r\n+\r\n+// Draw arrow\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n+void lcdDrawArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+}\r\n+\r\n+// Draw arrow of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+void lcdDrawFillArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x0, y0, x1, y1, color);\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+\r\n+    for (int ww = w - 1; ww > 0; ww--) {\r\n+        L[0] = x1 - Uy * ww - Ux * v;\r\n+        L[1] = y1 + Ux * ww - Uy * v;\r\n+        R[0] = x1 + Uy * ww - Ux * v;\r\n+        R[1] = y1 - Ux * ww - Uy * v;\r\n+        lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+        lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    }\r\n+}\r\n+\r\n+// RGB565 conversion\r\n+// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n+// Bit image \"RRRRRGGGGGGBBBBB\"\r\n+uint16_t rgb565_conv(uint16_t r, uint16_t g, uint16_t b) {\r\n+    return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n+}\r\n+\r\n+// Draw ASCII character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// ascii: ascii code\r\n+// color:color\r\n+int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n+\tuint16_t xx,yy,bit,ofs;\r\n+\tunsigned char fonts[128]; // font pattern\r\n+\tunsigned char pw, ph;\r\n+\tint h,w;\r\n+\tuint16_t mask;\r\n+\tbool rc;\r\n+\r\n+\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n+\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n+\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n+\tif (!rc) return 0;\r\n+\r\n+\tint16_t xd1 = 0;\r\n+\tint16_t yd1 = 0;\r\n+\tint16_t xd2 = 0;\r\n+\tint16_t yd2 = 0;\r\n+\tuint16_t xss = 0;\r\n+\tuint16_t yss = 0;\r\n+\tint16_t xsd = 0;\r\n+\tint16_t ysd = 0;\r\n+\tint16_t next = 0;\r\n+\tuint16_t x0  = 0;\r\n+\tuint16_t x1  = 0;\r\n+\tuint16_t y0  = 0;\r\n+\tuint16_t y1  = 0;\r\n+\tif (dev->_font_direction == 0) {\r\n+\t\txd1 = +1;\r\n+\t\tyd1 = +1; //-1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y - (ph - 1);\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x + pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y - (ph-1);\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n+\t} else if (dev->_font_direction == 2) {\r\n+\t\txd1 = -1;\r\n+\t\tyd1 = -1; //+1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y + ph + 1;\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x - pw;\r\n+\r\n+\t\tx0\t= x - (pw-1);\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y + (ph-1);\r\n+\t} else if (dev->_font_direction == 1) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = -1;\r\n+\t\tyd2 = +1; //-1;\r\n+\t\txss =  x + ph;\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y + pw; //y - pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x + (ph-1);\r\n+\t\ty1\t= y + (pw-1);\r\n+\t} else if (dev->_font_direction == 3) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = +1;\r\n+\t\tyd2 = -1; //+1;\r\n+\t\txss =  x - (ph - 1);\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y - pw; //y + pw;\r\n+\r\n+\t\tx0\t= x - (ph-1);\r\n+\t\ty0\t= y - (pw-1);\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y;\r\n+\t}\r\n+\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\t\r\n+\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1, y1, dev->_font_fill_color);\r\n+\r\n+\r\n+\tint bits;\r\n+\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n+\tofs = 0;\r\n+\tyy = yss;\r\n+\txx = xss;\r\n+\tfor(h=0;h<ph;h++) {\r\n+\t\tif(xsd) xx = xss;\r\n+\t\tif(ysd) yy = yss;\r\n+\t\t//for(w=0;w<(pw/8);w++) {\r\n+\t\tbits = pw;\r\n+\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n+\t\t\tmask = 0x80;\r\n+\t\t\tfor(bit=0;bit<8;bit++) {\r\n+\t\t\t\tbits--;\r\n+\t\t\t\tif (bits < 0) continue;\r\n+\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n+\t\t\t\tif (fonts[ofs] & mask) {\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\txx = xx + xd1;\r\n+\t\t\t\tyy = yy + yd2;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t}\r\n+\t\t\tofs++;\r\n+\t\t}\r\n+\t\tyy = yy + yd1;\r\n+\t\txx = xx + xd2;\r\n+\t}\r\n+\r\n+\tif (next < 0) next = 0;\r\n+\treturn next;\r\n+}\r\n+\r\n+int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n+\tint length = strlen((char *)ascii);\r\n+\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n+\tfor(int i=0;i<length;i++) {\r\n+\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+\r\n+// Draw Non-Alphanumeric character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// code:character code\r\n+// color:color\r\n+int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n+\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n+\tif (dev->_font_direction == 0)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 1)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 2)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 3)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+#if 0\r\n+// Draw UTF8 character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utf8:UTF8 code\r\n+// color:color\r\n+int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n+    uint16_t sjis[1];\r\n+\r\n+    sjis[0] = UTF2SJIS(utf8);\r\n+    if(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n+    return lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n+}\r\n+\r\n+// Draw UTF8 string\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utfs:UTF8 string\r\n+// color:color\r\n+int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n+\r\n+    int i;\r\n+    int spos;\r\n+    uint16_t sjis[64];\r\n+    spos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n+    if(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n+    ESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n+    for(i=0;i<spos;i++) {\r\n+        if(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n+        if (dev->_font_direction == 0)\r\n+            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 1)\r\n+            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 2)\r\n+            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 3)\r\n+            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+    }\r\n+    if (dev->_font_direction == 0) return x;\r\n+    if (dev->_font_direction == 2) return x;\r\n+    if (dev->_font_direction == 1) return y;\r\n+    if (dev->_font_direction == 3) return y;\r\n+    return 0;\r\n+}\r\n+#endif\r\n+\r\n+// Set font direction\r\n+// dir:Direction\r\n+void lcdSetFontDirection(TFT_t *dev, uint16_t dir) {\r\n+    dev->_font_direction = dir;\r\n+}\r\n+\r\n+// Set font filling\r\n+// color:fill color\r\n+void lcdSetFontFill(TFT_t *dev, uint16_t color) {\r\n+    dev->_font_fill = true;\r\n+    dev->_font_fill_color = color;\r\n+}\r\n+\r\n+// UnSet font filling\r\n+void lcdUnsetFontFill(TFT_t *dev) {\r\n+    dev->_font_fill = false;\r\n+}\r\n+\r\n+// Set font underline\r\n+// color:frame color\r\n+void lcdSetFontUnderLine(TFT_t *dev, uint16_t color) {\r\n+    dev->_font_underline = true;\r\n+    dev->_font_underline_color = color;\r\n+}\r\n+\r\n+// UnSet font underline\r\n+void lcdUnsetFontUnderLine(TFT_t *dev) {\r\n+    dev->_font_underline = false;\r\n+}\r\n+\r\n+// Backlight ON\r\n+void lcdBacklightOn(TFT_t *dev) {\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 1);  // Set backlight pin high\r\n+        ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n+    }\r\n+}\r\n+\r\n+// Backlight OFF\r\n+void lcdBacklightOff(TFT_t *dev) {\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 0);  // Set backlight pin low\r\n+        ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n+    }\r\n+}\r\n+\r\n+\r\n+// Display Inversion Off\r\n+void lcdInversionOff(TFT_t *dev) {\r\n+    ESP_LOGI(TAG, \"Disabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x20);  // INVOFF: Display Inversion Off\r\n+}\r\n+\r\n+// Display Inversion On\r\n+void lcdInversionOn(TFT_t *dev) {\r\n+    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n+}\r\n"
                },
                {
                    "date": 1731818151752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,20 +27,23 @@\n void spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n                      int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n     esp_err_t ret;\r\n \r\n+    // Initialize CS pin\r\n     ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n     if (GPIO_CS >= 0) {\r\n         gpio_reset_pin(GPIO_CS);\r\n         gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n         gpio_set_level(GPIO_CS, 1);\r\n     }\r\n \r\n+    // Initialize DC pin\r\n     ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n     gpio_reset_pin(GPIO_DC);\r\n     gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n     gpio_set_level(GPIO_DC, 0);\r\n \r\n+    // Initialize RESET pin\r\n     ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n     if (GPIO_RESET >= 0) {\r\n         gpio_reset_pin(GPIO_RESET);\r\n         gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n@@ -51,16 +54,9 @@\n         gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n         delayMS(100);\r\n     }\r\n \r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n-\r\n+    // Initialize SPI bus\r\n     ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n     ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n     spi_bus_config_t buscfg = {\r\n         .mosi_io_num = GPIO_MOSI,\r\n@@ -79,9 +75,9 @@\n     spi_device_interface_config_t devcfg;\r\n     memset(&devcfg, 0, sizeof(devcfg));\r\n     devcfg.clock_speed_hz = SPI_Frequency;\r\n     devcfg.queue_size = 7;\r\n-    devcfg.mode = 0;  // Changed from 2 to 0\r\n+    devcfg.mode = 0;  // SPI mode 0\r\n     devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n \r\n     if (GPIO_CS >= 0) {\r\n         devcfg.spics_io_num = GPIO_CS;\r\n@@ -93,13 +89,24 @@\n     ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n     ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n     assert(ret == ESP_OK);\r\n \r\n+    // Store GPIO numbers and SPI handle in device structure\r\n     dev->_dc = GPIO_DC;\r\n     dev->_bl = GPIO_BL;\r\n     dev->_SPIHandle = handle;\r\n+\r\n+    // Initialize Backlight pin AFTER SPI initialization\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n }\r\n \r\n+\r\n bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n     spi_transaction_t SPITransaction;\r\n     esp_err_t ret;\r\n \r\n@@ -1001,1007 +1008,4 @@\n void lcdInversionOn(TFT_t *dev) {\r\n     ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n     spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n }\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-#include <math.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-\r\n-#include <driver/spi_master.h>\r\n-#include <driver/gpio.h>\r\n-#include \"esp_log.h\"\r\n-\r\n-#include \"st7796s.h\"  // Updated to the correct header file\r\n-\r\n-#define TAG \"ST7796S\"\r\n-#define _DEBUG_ 0\r\n-\r\n-#if CONFIG_SPI2_HOST\r\n-#define HOST_ID SPI2_HOST\r\n-#elif CONFIG_SPI3_HOST\r\n-#define HOST_ID SPI3_HOST\r\n-#endif\r\n-\r\n-static const int SPI_Command_Mode = 0;\r\n-static const int SPI_Data_Mode = 1;\r\n-static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n-\r\n-void spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n-                     int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n-    esp_err_t ret;\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n-    if (GPIO_CS >= 0) {\r\n-        gpio_reset_pin(GPIO_CS);\r\n-        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_CS, 1);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n-    gpio_reset_pin(GPIO_DC);\r\n-    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n-    gpio_set_level(GPIO_DC, 0);\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n-    if (GPIO_RESET >= 0) {\r\n-        gpio_reset_pin(GPIO_RESET);\r\n-        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_RESET, 1);  // Ensure the reset pin starts high\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 0);  // Pulse reset pin\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n-        delayMS(100);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n-\r\n-    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n-    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n-    spi_bus_config_t buscfg = {\r\n-        .mosi_io_num = GPIO_MOSI,\r\n-        .miso_io_num = -1,\r\n-        .sclk_io_num = GPIO_SCLK,\r\n-        .quadwp_io_num = -1,\r\n-        .quadhd_io_num = -1,\r\n-        .max_transfer_sz = 6 * 1024,\r\n-        .flags = SPICOMMON_BUSFLAG_MASTER,\r\n-    };\r\n-\r\n-    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n-    ESP_LOGI(TAG, \"spi_bus_initialize=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    spi_device_interface_config_t devcfg;\r\n-    memset(&devcfg, 0, sizeof(devcfg));\r\n-    devcfg.clock_speed_hz = SPI_Frequency;\r\n-    devcfg.queue_size = 7;\r\n-    devcfg.mode = 0;  // Changed from 2 to 0\r\n-    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n-\r\n-    if (GPIO_CS >= 0) {\r\n-        devcfg.spics_io_num = GPIO_CS;\r\n-    } else {\r\n-        devcfg.spics_io_num = -1;\r\n-    }\r\n-\r\n-    spi_device_handle_t handle;\r\n-    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n-    ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    dev->_dc = GPIO_DC;\r\n-    dev->_bl = GPIO_BL;\r\n-    dev->_SPIHandle = handle;\r\n-}\r\n-\r\n-bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n-    spi_transaction_t SPITransaction;\r\n-    esp_err_t ret;\r\n-\r\n-    if (DataLength > 0) {\r\n-        memset(&SPITransaction, 0, sizeof(spi_transaction_t));\r\n-        SPITransaction.length = DataLength * 8;\r\n-        SPITransaction.tx_buffer = Data;\r\n-        ret = spi_device_polling_transmit(SPIHandle, &SPITransaction);\r\n-        assert(ret == ESP_OK);\r\n-    }\r\n-\r\n-    return true;\r\n-}\r\n-\r\n-bool spi_master_write_command(TFT_t *dev, uint8_t cmd) {\r\n-    uint8_t Byte = cmd;\r\n-    gpio_set_level(dev->_dc, SPI_Command_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n-}\r\n-\r\n-bool spi_master_write_data_byte(TFT_t *dev, uint8_t data) {\r\n-    uint8_t Byte = data;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n-}\r\n-\r\n-bool spi_master_write_data_word(TFT_t *dev, uint16_t data) {\r\n-    uint8_t Byte[2];\r\n-    Byte[0] = (data >> 8) & 0xFF;\r\n-    Byte[1] = data & 0xFF;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, Byte, 2);\r\n-}\r\n-\r\n-bool spi_master_write_addr(TFT_t *dev, uint16_t addr1, uint16_t addr2) {\r\n-    uint8_t Byte[4];\r\n-    Byte[0] = (addr1 >> 8) & 0xFF;\r\n-    Byte[1] = addr1 & 0xFF;\r\n-    Byte[2] = (addr2 >> 8) & 0xFF;\r\n-    Byte[3] = addr2 & 0xFF;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, Byte, 4);\r\n-}\r\n-\r\n-bool spi_master_write_color(TFT_t *dev, uint16_t color, uint32_t size) {\r\n-    uint8_t Byte[1024];\r\n-    uint32_t len = size * 2;\r\n-    uint32_t max_chunk = sizeof(Byte);\r\n-\r\n-    while (len > 0) {\r\n-        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n-        uint32_t color_count = chunk_size / 2;\r\n-        for (uint32_t i = 0; i < color_count; i++) {\r\n-            Byte[i * 2] = (color >> 8) & 0xFF;\r\n-            Byte[i * 2 + 1] = color & 0xFF;\r\n-        }\r\n-        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n-        len -= chunk_size;\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Add 202001\r\n-bool spi_master_write_colors(TFT_t *dev, uint16_t *colors, uint16_t size) {\r\n-    uint8_t Byte[1024];\r\n-    uint32_t index = 0;\r\n-    uint32_t len = size * 2;\r\n-    uint32_t max_chunk = sizeof(Byte);\r\n-\r\n-    while (len > 0) {\r\n-        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n-        uint32_t color_count = chunk_size / 2;\r\n-        for (uint32_t i = 0; i < color_count; i++) {\r\n-            Byte[i * 2] = (colors[index] >> 8) & 0xFF;\r\n-            Byte[i * 2 + 1] = colors[index] & 0xFF;\r\n-            index++;\r\n-        }\r\n-        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n-        len -= chunk_size;\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-void delayMS(int ms) {\r\n-    vTaskDelay(pdMS_TO_TICKS(ms));\r\n-}\r\n-\r\n-void lcdInit(TFT_t *dev, int width, int height, int offsetx, int offsety) {\r\n-    dev->_width = width;\r\n-    dev->_height = height;\r\n-    dev->_offsetx = offsetx;\r\n-    dev->_offsety = offsety;\r\n-    dev->_font_direction = DIRECTION0;\r\n-    dev->_font_fill = false;\r\n-    dev->_font_underline = false;\r\n-\r\n-    ESP_LOGI(TAG, \"Initializing ST7796S LCD\");\r\n-\r\n-    // Hardware reset\r\n-    if (dev->_reset >= 0) {\r\n-        gpio_set_level(dev->_reset, 0); // Set RESX low\r\n-        delayMS(20);                   // Minimum 10ms\r\n-        gpio_set_level(dev->_reset, 1); // Set RESX high\r\n-        delayMS(120);                  // Wait for reset complete\r\n-    }\r\n-\r\n-    // Software reset\r\n-    ESP_LOGI(TAG, \"Sending Software Reset\");\r\n-    spi_master_write_command(dev, 0x01);  // SWRESET: Software Reset\r\n-    delayMS(150);                        // Wait for reset process\r\n-\r\n-    // Exit Sleep mode\r\n-    ESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n-    spi_master_write_command(dev, 0x11);  // SLPOUT: Sleep Out\r\n-    delayMS(120);\r\n-\r\n-    // Memory Data Access Control\r\n-    ESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n-    spi_master_write_command(dev, 0x36);  // MADCTL: Memory Data Access Control\r\n-    spi_master_write_data_byte(dev, 0x48); // Adjust orientation (0x48 for default landscape)\r\n-    delayMS(10);\r\n-\r\n-    // Interface Pixel Format (16-bit/pixel)\r\n-    ESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n-    spi_master_write_command(dev, 0x3A);  // COLMOD: Interface Pixel Format\r\n-    spi_master_write_data_byte(dev, 0x55); // 16-bit/pixel (RGB 5-6-5)\r\n-    delayMS(10);\r\n-\r\n-    // Porch Setting\r\n-    ESP_LOGI(TAG, \"Setting Porch Control\");\r\n-    spi_master_write_command(dev, 0xB2);  // PORCTRL: Porch Control\r\n-    spi_master_write_data_byte(dev, 0x0C); // Front Porch\r\n-    spi_master_write_data_byte(dev, 0x0C); // Back Porch\r\n-    spi_master_write_data_byte(dev, 0x00); // Vertical Porch\r\n-    spi_master_write_data_byte(dev, 0x33);\r\n-    spi_master_write_data_byte(dev, 0x33);\r\n-    delayMS(10);\r\n-\r\n-    // VCOM Setting\r\n-    ESP_LOGI(TAG, \"Setting VCOM\");\r\n-    spi_master_write_command(dev, 0xBB);  // VCOMS: VCOM Setting\r\n-    spi_master_write_data_byte(dev, 0x35); // VCOM voltage level (1.175V)\r\n-    delayMS(10);\r\n-\r\n-    // LCM Control\r\n-    ESP_LOGI(TAG, \"Setting LCM Control\");\r\n-    spi_master_write_command(dev, 0xC0);  // LCMCTRL: LCM Control\r\n-    spi_master_write_data_byte(dev, 0x2C); // Default\r\n-    delayMS(10);\r\n-\r\n-    // VDV and VRH Command Enable\r\n-    ESP_LOGI(TAG, \"Enabling VDV and VRH Commands\");\r\n-    spi_master_write_command(dev, 0xC2);  // VDVVRHEN: Enable VDV and VRH\r\n-    spi_master_write_data_byte(dev, 0x01); // Enable\r\n-    delayMS(10);\r\n-\r\n-    // VRH Set\r\n-    ESP_LOGI(TAG, \"Setting VRH\");\r\n-    spi_master_write_command(dev, 0xC3);  // VRHS: VRH Set\r\n-    spi_master_write_data_byte(dev, 0x12); // Default\r\n-    delayMS(10);\r\n-\r\n-    // VDV Set\r\n-    ESP_LOGI(TAG, \"Setting VDV\");\r\n-    spi_master_write_command(dev, 0xC4);  // VDVS: VDV Set\r\n-    spi_master_write_data_byte(dev, 0x20); // Default\r\n-    delayMS(10);\r\n-\r\n-    // Frame Rate Control\r\n-    ESP_LOGI(TAG, \"Setting Frame Rate Control\");\r\n-    spi_master_write_command(dev, 0xC6);  // FRCTRL2: Frame Rate Control\r\n-    spi_master_write_data_byte(dev, 0x0F); // Default frame rate: 60Hz\r\n-    delayMS(10);\r\n-\r\n-    // Power Control 1\r\n-    ESP_LOGI(TAG, \"Setting Power Control 1\");\r\n-    spi_master_write_command(dev, 0xD0);  // PWCTRL1: Power Control 1\r\n-    spi_master_write_data_byte(dev, 0xA4); // Default\r\n-    spi_master_write_data_byte(dev, 0xA1); // Default\r\n-    delayMS(10);\r\n-\r\n-    // Positive Voltage Gamma Control\r\n-    ESP_LOGI(TAG, \"Setting Positive Voltage Gamma Control\");\r\n-    spi_master_write_command(dev, 0xE0);  // PGAMCTRL: Positive Gamma Control\r\n-    uint8_t positive_gamma[] = {0xD0, 0x08, 0x11, 0x08, 0x0C, 0x15, 0x39, 0x33, 0x50, 0x36, 0x13, 0x14, 0x29, 0x2D};\r\n-    for (int i = 0; i < sizeof(positive_gamma); i++) {\r\n-        spi_master_write_data_byte(dev, positive_gamma[i]);\r\n-    }\r\n-    delayMS(10);\r\n-\r\n-    // Negative Voltage Gamma Control\r\n-    ESP_LOGI(TAG, \"Setting Negative Voltage Gamma Control\");\r\n-    spi_master_write_command(dev, 0xE1);  // NVGAMCTRL: Negative Gamma Control\r\n-    uint8_t negative_gamma[] = {0xD0, 0x08, 0x10, 0x08, 0x06, 0x06, 0x39, 0x44, 0x51, 0x0B, 0x16, 0x14, 0x2F, 0x31};\r\n-    for (int i = 0; i < sizeof(negative_gamma); i++) {\r\n-        spi_master_write_data_byte(dev, negative_gamma[i]);\r\n-    }\r\n-    delayMS(10);\r\n-\r\n-    // Enable Display Inversion\r\n-    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n-    delayMS(10);\r\n-\r\n-    // Normal Display Mode On\r\n-    ESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n-    spi_master_write_command(dev, 0x13);  // NORON: Normal Display Mode On\r\n-    delayMS(10);\r\n-\r\n-    // Turn on Display\r\n-    ESP_LOGI(TAG, \"Turning Display On\");\r\n-    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n-    delayMS(120);                          // Wait for display to turn on\r\n-\r\n-    // Backlight control\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 1);\r\n-        ESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n-    }\r\n-}\r\n-\r\n-// Draw pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// color:color\r\n-void lcdDrawPixel(TFT_t *dev, uint16_t x, uint16_t y, uint16_t color) {\r\n-    if (x >= dev->_width)\r\n-        return;\r\n-    if (y >= dev->_height)\r\n-        return;\r\n-\r\n-    uint16_t _x = x + dev->_offsetx;\r\n-    uint16_t _y = y + dev->_offsety;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x, _x);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y, _y);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-    spi_master_write_data_word(dev, color);\r\n-}\r\n-\r\n-// Draw multi pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// size:Number of colors\r\n-// colors:colors\r\n-void lcdDrawMultiPixels(TFT_t *dev, uint16_t x, uint16_t y, uint16_t size, uint16_t *colors) {\r\n-    if (x + size > dev->_width)\r\n-        return;\r\n-    if (y >= dev->_height)\r\n-        return;\r\n-\r\n-    uint16_t _x1 = x + dev->_offsetx;\r\n-    uint16_t _x2 = _x1 + (size - 1);\r\n-    uint16_t _y1 = y + dev->_offsety;\r\n-    uint16_t _y2 = _y1;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x1, _x2);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y1, _y2);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-    spi_master_write_colors(dev, colors, size);\r\n-}\r\n-\r\n-// Draw rectangle of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End X coordinate\r\n-// y2:End Y coordinate\r\n-// color:color\r\n-void lcdDrawFillRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    if (x1 >= dev->_width)\r\n-        return;\r\n-    if (x2 >= dev->_width)\r\n-        x2 = dev->_width - 1;\r\n-    if (y1 >= dev->_height)\r\n-        return;\r\n-    if (y2 >= dev->_height)\r\n-        y2 = dev->_height - 1;\r\n-\r\n-    uint16_t _x1 = x1 + dev->_offsetx;\r\n-    uint16_t _x2 = x2 + dev->_offsetx;\r\n-    uint16_t _y1 = y1 + dev->_offsety;\r\n-    uint16_t _y2 = y2 + dev->_offsety;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x1, _x2);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y1, _y2);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-\r\n-    uint32_t size = (_x2 - _x1 + 1) * (_y2 - _y1 + 1);\r\n-    spi_master_write_color(dev, color, size);\r\n-}\r\n-\r\n-// Display OFF\r\n-void lcdDisplayOff(TFT_t *dev) {\r\n-    spi_master_write_command(dev, 0x28);  // DISPOFF: Display Off\r\n-}\r\n-\r\n-// Display ON\r\n-void lcdDisplayOn(TFT_t *dev) {\r\n-    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n-}\r\n-\r\n-// Fill screen\r\n-// color:color\r\n-void lcdFillScreen(TFT_t *dev, uint16_t color) {\r\n-    lcdDrawFillRect(dev, 0, 0, dev->_width - 1, dev->_height - 1, color);\r\n-}\r\n-\r\n-// Draw line\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawLine(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    int dx, dy, sx, sy, err, e2;\r\n-\r\n-    dx = abs(x2 - x1);\r\n-    dy = -abs(y2 - y1);\r\n-\r\n-    sx = (x1 < x2) ? 1 : -1;\r\n-    sy = (y1 < y2) ? 1 : -1;\r\n-\r\n-    err = dx + dy;\r\n-\r\n-    while (1) {\r\n-        lcdDrawPixel(dev, x1, y1, color);\r\n-        if (x1 == x2 && y1 == y2)\r\n-            break;\r\n-        e2 = 2 * err;\r\n-        if (e2 >= dy) {\r\n-            err += dy;\r\n-            x1 += sx;\r\n-        }\r\n-        if (e2 <= dx) {\r\n-            err += dx;\r\n-            y1 += sy;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-// Draw rectangle\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    lcdDrawLine(dev, x1, y1, x2, y1, color);\r\n-    lcdDrawLine(dev, x2, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x2, y2, x1, y2, color);\r\n-    lcdDrawLine(dev, x1, y2, x1, y1, color);\r\n-}\r\n-\r\n-// Draw rectangle with angle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of rectangle\r\n-// h:Height of rectangle\r\n-// angle:Angle of rectangle\r\n-// color:color\r\n-\r\n-// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawRectAngle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-    double xd, yd, rd;\r\n-    int x1, y1;\r\n-    int x2, y2;\r\n-    int x3, y3;\r\n-    int x4, y4;\r\n-    rd = -angle * M_PI / 180.0;\r\n-    xd = 0.0 - w / 2;\r\n-    yd = h / 2;\r\n-    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    yd = 0.0 - yd;\r\n-    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = w / 2;\r\n-    yd = h / 2;\r\n-    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    yd = 0.0 - yd;\r\n-    x4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-    lcdDrawLine(dev, x2, y2, x4, y4, color);\r\n-    lcdDrawLine(dev, x3, y3, x4, y4, color);\r\n-}\r\n-\r\n-// Draw triangle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of triangle\r\n-// h:Height of triangle\r\n-// angle:Angle of triangle\r\n-// color:color\r\n-\r\n-// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawTriangle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-    double xd, yd, rd;\r\n-    int x1, y1;\r\n-    int x2, y2;\r\n-    int x3, y3;\r\n-    rd = -angle * M_PI / 180.0;\r\n-    xd = 0.0;\r\n-    yd = h / 2;\r\n-    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = w / 2;\r\n-    yd = 0.0 - yd;\r\n-    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = 0.0 - w / 2;\r\n-    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-    lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n-}\r\n-\r\n-// Draw circle\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-    do {\r\n-        lcdDrawPixel(dev, x0 - x, y0 + y, color);\r\n-        lcdDrawPixel(dev, x0 - y, y0 - x, color);\r\n-        lcdDrawPixel(dev, x0 + x, y0 - y, color);\r\n-        lcdDrawPixel(dev, x0 + y, y0 + x, color);\r\n-        if ((old_err = err) <= x)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y < 0);\r\n-}\r\n-\r\n-// Draw circle of filling\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawFillCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-    int ChangeX;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-    ChangeX = 1;\r\n-    do {\r\n-        if (ChangeX) {\r\n-            lcdDrawLine(dev, x0 - x, y0 - y, x0 - x, y0 + y, color);\r\n-            lcdDrawLine(dev, x0 + x, y0 - y, x0 + x, y0 + y, color);\r\n-        }\r\n-        ChangeX = (old_err = err) <= x;\r\n-        if (ChangeX)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y <= 0);\r\n-}\r\n-\r\n-// Draw rectangle with round corner\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawRoundRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-    uint16_t temp;\r\n-\r\n-    if (x1 > x2) {\r\n-        temp = x1;\r\n-        x1 = x2;\r\n-        x2 = temp;\r\n-    }\r\n-\r\n-    if (y1 > y2) {\r\n-        temp = y1;\r\n-        y1 = y2;\r\n-        y2 = temp;\r\n-    }\r\n-\r\n-    if (x2 - x1 < r)\r\n-        return;\r\n-    if (y2 - y1 < r)\r\n-        return;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-\r\n-    do {\r\n-        if (x) {\r\n-            lcdDrawPixel(dev, x1 + r - x, y1 + r + y, color);\r\n-            lcdDrawPixel(dev, x2 - r + x, y1 + r + y, color);\r\n-            lcdDrawPixel(dev, x1 + r - x, y2 - r - y, color);\r\n-            lcdDrawPixel(dev, x2 - r + x, y2 - r - y, color);\r\n-        }\r\n-        if ((old_err = err) <= x)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y < 0);\r\n-\r\n-    lcdDrawLine(dev, x1 + r, y1, x2 - r, y1, color);\r\n-    lcdDrawLine(dev, x1 + r, y2, x2 - r, y2, color);\r\n-    lcdDrawLine(dev, x1, y1 + r, x1, y2 - r, color);\r\n-    lcdDrawLine(dev, x2, y1 + r, x2, y2 - r, color);\r\n-}\r\n-\r\n-// Draw arrow\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the bottom\r\n-// color:color\r\n-// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n-void lcdDrawArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n-    double Vx = x1 - x0;\r\n-    double Vy = y1 - y0;\r\n-    double v = sqrt(Vx * Vx + Vy * Vy);\r\n-    double Ux = Vx / v;\r\n-    double Uy = Vy / v;\r\n-\r\n-    uint16_t L[2], R[2];\r\n-    L[0] = x1 - Uy * w - Ux * v;\r\n-    L[1] = y1 + Ux * w - Uy * v;\r\n-    R[0] = x1 + Uy * w - Ux * v;\r\n-    R[1] = y1 - Ux * w - Uy * v;\r\n-\r\n-    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-}\r\n-\r\n-// Draw arrow of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the bottom\r\n-// color:color\r\n-void lcdDrawFillArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n-    double Vx = x1 - x0;\r\n-    double Vy = y1 - y0;\r\n-    double v = sqrt(Vx * Vx + Vy * Vy);\r\n-    double Ux = Vx / v;\r\n-    double Uy = Vy / v;\r\n-\r\n-    uint16_t L[2], R[2];\r\n-    L[0] = x1 - Uy * w - Ux * v;\r\n-    L[1] = y1 + Ux * w - Uy * v;\r\n-    R[0] = x1 + Uy * w - Ux * v;\r\n-    R[1] = y1 - Ux * w - Uy * v;\r\n-\r\n-    lcdDrawLine(dev, x0, y0, x1, y1, color);\r\n-    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-\r\n-    for (int ww = w - 1; ww > 0; ww--) {\r\n-        L[0] = x1 - Uy * ww - Ux * v;\r\n-        L[1] = y1 + Ux * ww - Uy * v;\r\n-        R[0] = x1 + Uy * ww - Ux * v;\r\n-        R[1] = y1 - Ux * ww - Uy * v;\r\n-        lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-        lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    }\r\n-}\r\n-\r\n-// RGB565 conversion\r\n-// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n-// Bit image \"RRRRRGGGGGGBBBBB\"\r\n-uint16_t rgb565_conv(uint16_t r, uint16_t g, uint16_t b) {\r\n-    return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n-}\r\n-\r\n-// Draw ASCII character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// ascii: ascii code\r\n-// color:color\r\n-int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n-\tuint16_t xx,yy,bit,ofs;\r\n-\tunsigned char fonts[128]; // font pattern\r\n-\tunsigned char pw, ph;\r\n-\tint h,w;\r\n-\tuint16_t mask;\r\n-\tbool rc;\r\n-\r\n-\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n-\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n-\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n-\tif (!rc) return 0;\r\n-\r\n-\tint16_t xd1 = 0;\r\n-\tint16_t yd1 = 0;\r\n-\tint16_t xd2 = 0;\r\n-\tint16_t yd2 = 0;\r\n-\tuint16_t xss = 0;\r\n-\tuint16_t yss = 0;\r\n-\tint16_t xsd = 0;\r\n-\tint16_t ysd = 0;\r\n-\tint16_t next = 0;\r\n-\tuint16_t x0  = 0;\r\n-\tuint16_t x1  = 0;\r\n-\tuint16_t y0  = 0;\r\n-\tuint16_t y1  = 0;\r\n-\tif (dev->_font_direction == 0) {\r\n-\t\txd1 = +1;\r\n-\t\tyd1 = +1; //-1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y - (ph - 1);\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x + pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y - (ph-1);\r\n-\t\tx1\t= x + (pw-1);\r\n-\t\ty1\t= y;\r\n-\t} else if (dev->_font_direction == 2) {\r\n-\t\txd1 = -1;\r\n-\t\tyd1 = -1; //+1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y + ph + 1;\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x - pw;\r\n-\r\n-\t\tx0\t= x - (pw-1);\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y + (ph-1);\r\n-\t} else if (dev->_font_direction == 1) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = -1;\r\n-\t\tyd2 = +1; //-1;\r\n-\t\txss =  x + ph;\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y + pw; //y - pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x + (ph-1);\r\n-\t\ty1\t= y + (pw-1);\r\n-\t} else if (dev->_font_direction == 3) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = +1;\r\n-\t\tyd2 = -1; //+1;\r\n-\t\txss =  x - (ph - 1);\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y - pw; //y + pw;\r\n-\r\n-\t\tx0\t= x - (ph-1);\r\n-\t\ty0\t= y - (pw-1);\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y;\r\n-\t}\r\n-\r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n-\t\r\n-\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1, y1, dev->_font_fill_color);\r\n-\r\n-\r\n-\tint bits;\r\n-\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n-\tofs = 0;\r\n-\tyy = yss;\r\n-\txx = xss;\r\n-\tfor(h=0;h<ph;h++) {\r\n-\t\tif(xsd) xx = xss;\r\n-\t\tif(ysd) yy = yss;\r\n-\t\t//for(w=0;w<(pw/8);w++) {\r\n-\t\tbits = pw;\r\n-\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n-\t\t\tmask = 0x80;\r\n-\t\t\tfor(bit=0;bit<8;bit++) {\r\n-\t\t\t\tbits--;\r\n-\t\t\t\tif (bits < 0) continue;\r\n-\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n-\t\t\t\tif (fonts[ofs] & mask) {\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n-\t\t\t\t}\r\n-\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\txx = xx + xd1;\r\n-\t\t\t\tyy = yy + yd2;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t}\r\n-\t\t\tofs++;\r\n-\t\t}\r\n-\t\tyy = yy + yd1;\r\n-\t\txx = xx + xd2;\r\n-\t}\r\n-\r\n-\tif (next < 0) next = 0;\r\n-\treturn next;\r\n-}\r\n-\r\n-int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n-\tint length = strlen((char *)ascii);\r\n-\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n-\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n-\tfor(int i=0;i<length;i++) {\r\n-\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-\r\n-// Draw Non-Alphanumeric character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// code:character code\r\n-// color:color\r\n-int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n-\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n-\tif (dev->_font_direction == 0)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 1)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 2)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 3)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-#if 0\r\n-// Draw UTF8 character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utf8:UTF8 code\r\n-// color:color\r\n-int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n-    uint16_t sjis[1];\r\n-\r\n-    sjis[0] = UTF2SJIS(utf8);\r\n-    if(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n-    return lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n-}\r\n-\r\n-// Draw UTF8 string\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utfs:UTF8 string\r\n-// color:color\r\n-int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n-\r\n-    int i;\r\n-    int spos;\r\n-    uint16_t sjis[64];\r\n-    spos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n-    if(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n-    ESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n-    for(i=0;i<spos;i++) {\r\n-        if(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n-        if (dev->_font_direction == 0)\r\n-            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 1)\r\n-            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 2)\r\n-            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 3)\r\n-            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-    }\r\n-    if (dev->_font_direction == 0) return x;\r\n-    if (dev->_font_direction == 2) return x;\r\n-    if (dev->_font_direction == 1) return y;\r\n-    if (dev->_font_direction == 3) return y;\r\n-    return 0;\r\n-}\r\n-#endif\r\n-\r\n-// Set font direction\r\n-// dir:Direction\r\n-void lcdSetFontDirection(TFT_t *dev, uint16_t dir) {\r\n-    dev->_font_direction = dir;\r\n-}\r\n-\r\n-// Set font filling\r\n-// color:fill color\r\n-void lcdSetFontFill(TFT_t *dev, uint16_t color) {\r\n-    dev->_font_fill = true;\r\n-    dev->_font_fill_color = color;\r\n-}\r\n-\r\n-// UnSet font filling\r\n-void lcdUnsetFontFill(TFT_t *dev) {\r\n-    dev->_font_fill = false;\r\n-}\r\n-\r\n-// Set font underline\r\n-// color:frame color\r\n-void lcdSetFontUnderLine(TFT_t *dev, uint16_t color) {\r\n-    dev->_font_underline = true;\r\n-    dev->_font_underline_color = color;\r\n-}\r\n-\r\n-// UnSet font underline\r\n-void lcdUnsetFontUnderLine(TFT_t *dev) {\r\n-    dev->_font_underline = false;\r\n-}\r\n-\r\n-// Backlight OFF\r\n-void lcdBacklightOff(TFT_t *dev) {\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 12);\r\n-        ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n-    }\r\n-}\r\n-\r\n-// Backlight ON\r\n-void lcdBacklightOn(TFT_t *dev) {\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 0);\r\n-        ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n-    }\r\n-}\r\n-\r\n-// Display Inversion Off\r\n-void lcdInversionOff(TFT_t *dev) {\r\n-    ESP_LOGI(TAG, \"Disabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x20);  // INVOFF: Display Inversion Off\r\n-}\r\n-\r\n-// Display Inversion On\r\n-void lcdInversionOn(TFT_t *dev) {\r\n-    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n-}\r\n"
                },
                {
                    "date": 1731818281892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1011 @@\n+#include <string.h>\r\n+#include <inttypes.h>\r\n+#include <math.h>\r\n+\r\n+#include \"freertos/FreeRTOS.h\"\r\n+#include \"freertos/task.h\"\r\n+\r\n+#include <driver/spi_master.h>\r\n+#include <driver/gpio.h>\r\n+#include \"esp_log.h\"\r\n+\r\n+#include \"st7796s.h\"  // Updated to the correct header file\r\n+\r\n+#define TAG \"ST7796S\"\r\n+#define _DEBUG_ 0\r\n+\r\n+#if CONFIG_SPI2_HOST\r\n+#define HOST_ID SPI2_HOST\r\n+#elif CONFIG_SPI3_HOST\r\n+#define HOST_ID SPI3_HOST\r\n+#endif\r\n+\r\n+static const int SPI_Command_Mode = 0;\r\n+static const int SPI_Data_Mode = 1;\r\n+static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n+\r\n+void spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n+                     int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n+    esp_err_t ret;\r\n+\r\n+    // Initialize CS pin\r\n+    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n+    if (GPIO_CS >= 0) {\r\n+        gpio_reset_pin(GPIO_CS);\r\n+        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_CS, 1);\r\n+    }\r\n+\r\n+    // Initialize DC pin\r\n+    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n+    gpio_reset_pin(GPIO_DC);\r\n+    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n+    gpio_set_level(GPIO_DC, 0);\r\n+\r\n+    // Initialize RESET pin\r\n+    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n+    if (GPIO_RESET >= 0) {\r\n+        gpio_reset_pin(GPIO_RESET);\r\n+        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_RESET, 1);  // Ensure the reset pin starts high\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 0);  // Pulse reset pin\r\n+        delayMS(100);\r\n+        gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n+        delayMS(100);\r\n+    }\r\n+\r\n+    // Initialize SPI bus\r\n+    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n+    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n+    spi_bus_config_t buscfg = {\r\n+        .mosi_io_num = GPIO_MOSI,\r\n+        .miso_io_num = -1,\r\n+        .sclk_io_num = GPIO_SCLK,\r\n+        .quadwp_io_num = -1,\r\n+        .quadhd_io_num = -1,\r\n+        .max_transfer_sz = 6 * 1024,\r\n+        .flags = SPICOMMON_BUSFLAG_MASTER,\r\n+    };\r\n+\r\n+    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n+    ESP_LOGI(TAG, \"spi_bus_initialize=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    spi_device_interface_config_t devcfg;\r\n+    memset(&devcfg, 0, sizeof(devcfg));\r\n+    devcfg.clock_speed_hz = SPI_Frequency;\r\n+    devcfg.queue_size = 7;\r\n+    devcfg.mode = 0;  // SPI mode 0\r\n+    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n+\r\n+    if (GPIO_CS >= 0) {\r\n+        devcfg.spics_io_num = GPIO_CS;\r\n+    } else {\r\n+        devcfg.spics_io_num = -1;\r\n+    }\r\n+\r\n+    spi_device_handle_t handle;\r\n+    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n+    ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n+    assert(ret == ESP_OK);\r\n+\r\n+    // Store GPIO numbers and SPI handle in device structure\r\n+    dev->_dc = GPIO_DC;\r\n+    dev->_bl = GPIO_BL;\r\n+    dev->_SPIHandle = handle;\r\n+\r\n+    // Initialize Backlight pin AFTER SPI initialization\r\n+    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n+    if (GPIO_BL >= 0) {\r\n+        gpio_reset_pin(GPIO_BL);\r\n+        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n+        gpio_set_level(GPIO_BL, 0);  // Set GPIO_BL high to turn on the backlight\r\n+        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n+    }\r\n+}\r\n+\r\n+\r\n+bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n+    spi_transaction_t SPITransaction;\r\n+    esp_err_t ret;\r\n+\r\n+    if (DataLength > 0) {\r\n+        memset(&SPITransaction, 0, sizeof(spi_transaction_t));\r\n+        SPITransaction.length = DataLength * 8;\r\n+        SPITransaction.tx_buffer = Data;\r\n+        ret = spi_device_polling_transmit(SPIHandle, &SPITransaction);\r\n+        assert(ret == ESP_OK);\r\n+    }\r\n+\r\n+    return true;\r\n+}\r\n+\r\n+bool spi_master_write_command(TFT_t *dev, uint8_t cmd) {\r\n+    uint8_t Byte = cmd;\r\n+    gpio_set_level(dev->_dc, SPI_Command_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n+}\r\n+\r\n+bool spi_master_write_data_byte(TFT_t *dev, uint8_t data) {\r\n+    uint8_t Byte = data;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n+}\r\n+\r\n+bool spi_master_write_data_word(TFT_t *dev, uint16_t data) {\r\n+    uint8_t Byte[2];\r\n+    Byte[0] = (data >> 8) & 0xFF;\r\n+    Byte[1] = data & 0xFF;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, Byte, 2);\r\n+}\r\n+\r\n+bool spi_master_write_addr(TFT_t *dev, uint16_t addr1, uint16_t addr2) {\r\n+    uint8_t Byte[4];\r\n+    Byte[0] = (addr1 >> 8) & 0xFF;\r\n+    Byte[1] = addr1 & 0xFF;\r\n+    Byte[2] = (addr2 >> 8) & 0xFF;\r\n+    Byte[3] = addr2 & 0xFF;\r\n+    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+    return spi_master_write_byte(dev->_SPIHandle, Byte, 4);\r\n+}\r\n+\r\n+bool spi_master_write_color(TFT_t *dev, uint16_t color, uint32_t size) {\r\n+    uint8_t Byte[1024];\r\n+    uint32_t len = size * 2;\r\n+    uint32_t max_chunk = sizeof(Byte);\r\n+\r\n+    while (len > 0) {\r\n+        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n+        uint32_t color_count = chunk_size / 2;\r\n+        for (uint32_t i = 0; i < color_count; i++) {\r\n+            Byte[i * 2] = (color >> 8) & 0xFF;\r\n+            Byte[i * 2 + 1] = color & 0xFF;\r\n+        }\r\n+        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n+        len -= chunk_size;\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+// Add 202001\r\n+bool spi_master_write_colors(TFT_t *dev, uint16_t *colors, uint16_t size) {\r\n+    uint8_t Byte[1024];\r\n+    uint32_t index = 0;\r\n+    uint32_t len = size * 2;\r\n+    uint32_t max_chunk = sizeof(Byte);\r\n+\r\n+    while (len > 0) {\r\n+        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n+        uint32_t color_count = chunk_size / 2;\r\n+        for (uint32_t i = 0; i < color_count; i++) {\r\n+            Byte[i * 2] = (colors[index] >> 8) & 0xFF;\r\n+            Byte[i * 2 + 1] = colors[index] & 0xFF;\r\n+            index++;\r\n+        }\r\n+        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n+        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n+        len -= chunk_size;\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+void delayMS(int ms) {\r\n+    vTaskDelay(pdMS_TO_TICKS(ms));\r\n+}\r\n+\r\n+void lcdInit(TFT_t *dev, int width, int height, int offsetx, int offsety) {\r\n+    dev->_width = width;\r\n+    dev->_height = height;\r\n+    dev->_offsetx = offsetx;\r\n+    dev->_offsety = offsety;\r\n+    dev->_font_direction = DIRECTION0;\r\n+    dev->_font_fill = false;\r\n+    dev->_font_underline = false;\r\n+\r\n+    ESP_LOGI(TAG, \"Initializing ST7796S LCD\");\r\n+\r\n+    // Hardware reset\r\n+    if (dev->_reset >= 0) {\r\n+        gpio_set_level(dev->_reset, 0); // Set RESX low\r\n+        delayMS(20);                   // Minimum 10ms\r\n+        gpio_set_level(dev->_reset, 1); // Set RESX high\r\n+        delayMS(120);                  // Wait for reset complete\r\n+    }\r\n+\r\n+    // Software reset\r\n+    ESP_LOGI(TAG, \"Sending Software Reset\");\r\n+    spi_master_write_command(dev, 0x01);  // SWRESET: Software Reset\r\n+    delayMS(150);                        // Wait for reset process\r\n+\r\n+    // Exit Sleep mode\r\n+    ESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n+    spi_master_write_command(dev, 0x11);  // SLPOUT: Sleep Out\r\n+    delayMS(120);\r\n+\r\n+    // Memory Data Access Control\r\n+    ESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n+    spi_master_write_command(dev, 0x36);  // MADCTL: Memory Data Access Control\r\n+    spi_master_write_data_byte(dev, 0x48); // Adjust orientation (0x48 for default landscape)\r\n+    delayMS(10);\r\n+\r\n+    // Interface Pixel Format (16-bit/pixel)\r\n+    ESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n+    spi_master_write_command(dev, 0x3A);  // COLMOD: Interface Pixel Format\r\n+    spi_master_write_data_byte(dev, 0x55); // 16-bit/pixel (RGB 5-6-5)\r\n+    delayMS(10);\r\n+\r\n+    // Porch Setting\r\n+    ESP_LOGI(TAG, \"Setting Porch Control\");\r\n+    spi_master_write_command(dev, 0xB2);  // PORCTRL: Porch Control\r\n+    spi_master_write_data_byte(dev, 0x0C); // Front Porch\r\n+    spi_master_write_data_byte(dev, 0x0C); // Back Porch\r\n+    spi_master_write_data_byte(dev, 0x00); // Vertical Porch\r\n+    spi_master_write_data_byte(dev, 0x33);\r\n+    spi_master_write_data_byte(dev, 0x33);\r\n+    delayMS(10);\r\n+\r\n+    // VCOM Setting\r\n+    ESP_LOGI(TAG, \"Setting VCOM\");\r\n+    spi_master_write_command(dev, 0xBB);  // VCOMS: VCOM Setting\r\n+    spi_master_write_data_byte(dev, 0x35); // VCOM voltage level (1.175V)\r\n+    delayMS(10);\r\n+\r\n+    // LCM Control\r\n+    ESP_LOGI(TAG, \"Setting LCM Control\");\r\n+    spi_master_write_command(dev, 0xC0);  // LCMCTRL: LCM Control\r\n+    spi_master_write_data_byte(dev, 0x2C); // Default\r\n+    delayMS(10);\r\n+\r\n+    // VDV and VRH Command Enable\r\n+    ESP_LOGI(TAG, \"Enabling VDV and VRH Commands\");\r\n+    spi_master_write_command(dev, 0xC2);  // VDVVRHEN: Enable VDV and VRH\r\n+    spi_master_write_data_byte(dev, 0x01); // Enable\r\n+    delayMS(10);\r\n+\r\n+    // VRH Set\r\n+    ESP_LOGI(TAG, \"Setting VRH\");\r\n+    spi_master_write_command(dev, 0xC3);  // VRHS: VRH Set\r\n+    spi_master_write_data_byte(dev, 0x12); // Default\r\n+    delayMS(10);\r\n+\r\n+    // VDV Set\r\n+    ESP_LOGI(TAG, \"Setting VDV\");\r\n+    spi_master_write_command(dev, 0xC4);  // VDVS: VDV Set\r\n+    spi_master_write_data_byte(dev, 0x20); // Default\r\n+    delayMS(10);\r\n+\r\n+    // Frame Rate Control\r\n+    ESP_LOGI(TAG, \"Setting Frame Rate Control\");\r\n+    spi_master_write_command(dev, 0xC6);  // FRCTRL2: Frame Rate Control\r\n+    spi_master_write_data_byte(dev, 0x0F); // Default frame rate: 60Hz\r\n+    delayMS(10);\r\n+\r\n+    // Power Control 1\r\n+    ESP_LOGI(TAG, \"Setting Power Control 1\");\r\n+    spi_master_write_command(dev, 0xD0);  // PWCTRL1: Power Control 1\r\n+    spi_master_write_data_byte(dev, 0xA4); // Default\r\n+    spi_master_write_data_byte(dev, 0xA1); // Default\r\n+    delayMS(10);\r\n+\r\n+    // Positive Voltage Gamma Control\r\n+    ESP_LOGI(TAG, \"Setting Positive Voltage Gamma Control\");\r\n+    spi_master_write_command(dev, 0xE0);  // PGAMCTRL: Positive Gamma Control\r\n+    uint8_t positive_gamma[] = {0xD0, 0x08, 0x11, 0x08, 0x0C, 0x15, 0x39, 0x33, 0x50, 0x36, 0x13, 0x14, 0x29, 0x2D};\r\n+    for (int i = 0; i < sizeof(positive_gamma); i++) {\r\n+        spi_master_write_data_byte(dev, positive_gamma[i]);\r\n+    }\r\n+    delayMS(10);\r\n+\r\n+    // Negative Voltage Gamma Control\r\n+    ESP_LOGI(TAG, \"Setting Negative Voltage Gamma Control\");\r\n+    spi_master_write_command(dev, 0xE1);  // NVGAMCTRL: Negative Gamma Control\r\n+    uint8_t negative_gamma[] = {0xD0, 0x08, 0x10, 0x08, 0x06, 0x06, 0x39, 0x44, 0x51, 0x0B, 0x16, 0x14, 0x2F, 0x31};\r\n+    for (int i = 0; i < sizeof(negative_gamma); i++) {\r\n+        spi_master_write_data_byte(dev, negative_gamma[i]);\r\n+    }\r\n+    delayMS(10);\r\n+\r\n+    // Enable Display Inversion\r\n+    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n+    delayMS(10);\r\n+\r\n+    // Normal Display Mode On\r\n+    ESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n+    spi_master_write_command(dev, 0x13);  // NORON: Normal Display Mode On\r\n+    delayMS(10);\r\n+\r\n+    // Turn on Display\r\n+    ESP_LOGI(TAG, \"Turning Display On\");\r\n+    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n+    delayMS(120);                          // Wait for display to turn on\r\n+\r\n+    // Backlight control\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 1);\r\n+        ESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n+    }\r\n+}\r\n+\r\n+// Draw pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// color:color\r\n+void lcdDrawPixel(TFT_t *dev, uint16_t x, uint16_t y, uint16_t color) {\r\n+    if (x >= dev->_width)\r\n+        return;\r\n+    if (y >= dev->_height)\r\n+        return;\r\n+\r\n+    uint16_t _x = x + dev->_offsetx;\r\n+    uint16_t _y = y + dev->_offsety;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x, _x);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y, _y);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+    spi_master_write_data_word(dev, color);\r\n+}\r\n+\r\n+// Draw multi pixel\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// size:Number of colors\r\n+// colors:colors\r\n+void lcdDrawMultiPixels(TFT_t *dev, uint16_t x, uint16_t y, uint16_t size, uint16_t *colors) {\r\n+    if (x + size > dev->_width)\r\n+        return;\r\n+    if (y >= dev->_height)\r\n+        return;\r\n+\r\n+    uint16_t _x1 = x + dev->_offsetx;\r\n+    uint16_t _x2 = _x1 + (size - 1);\r\n+    uint16_t _y1 = y + dev->_offsety;\r\n+    uint16_t _y2 = _y1;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x1, _x2);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y1, _y2);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+    spi_master_write_colors(dev, colors, size);\r\n+}\r\n+\r\n+// Draw rectangle of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End X coordinate\r\n+// y2:End Y coordinate\r\n+// color:color\r\n+void lcdDrawFillRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    if (x1 >= dev->_width)\r\n+        return;\r\n+    if (x2 >= dev->_width)\r\n+        x2 = dev->_width - 1;\r\n+    if (y1 >= dev->_height)\r\n+        return;\r\n+    if (y2 >= dev->_height)\r\n+        y2 = dev->_height - 1;\r\n+\r\n+    uint16_t _x1 = x1 + dev->_offsetx;\r\n+    uint16_t _x2 = x2 + dev->_offsetx;\r\n+    uint16_t _y1 = y1 + dev->_offsety;\r\n+    uint16_t _y2 = y2 + dev->_offsety;\r\n+\r\n+    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n+    spi_master_write_addr(dev, _x1, _x2);\r\n+    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n+    spi_master_write_addr(dev, _y1, _y2);\r\n+    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n+\r\n+    uint32_t size = (_x2 - _x1 + 1) * (_y2 - _y1 + 1);\r\n+    spi_master_write_color(dev, color, size);\r\n+}\r\n+\r\n+// Display OFF\r\n+void lcdDisplayOff(TFT_t *dev) {\r\n+    spi_master_write_command(dev, 0x28);  // DISPOFF: Display Off\r\n+}\r\n+\r\n+// Display ON\r\n+void lcdDisplayOn(TFT_t *dev) {\r\n+    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n+}\r\n+\r\n+// Fill screen\r\n+// color:color\r\n+void lcdFillScreen(TFT_t *dev, uint16_t color) {\r\n+    lcdDrawFillRect(dev, 0, 0, dev->_width - 1, dev->_height - 1, color);\r\n+}\r\n+\r\n+// Draw line\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawLine(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    int dx, dy, sx, sy, err, e2;\r\n+\r\n+    dx = abs(x2 - x1);\r\n+    dy = -abs(y2 - y1);\r\n+\r\n+    sx = (x1 < x2) ? 1 : -1;\r\n+    sy = (y1 < y2) ? 1 : -1;\r\n+\r\n+    err = dx + dy;\r\n+\r\n+    while (1) {\r\n+        lcdDrawPixel(dev, x1, y1, color);\r\n+        if (x1 == x2 && y1 == y2)\r\n+            break;\r\n+        e2 = 2 * err;\r\n+        if (e2 >= dy) {\r\n+            err += dy;\r\n+            x1 += sx;\r\n+        }\r\n+        if (e2 <= dx) {\r\n+            err += dx;\r\n+            y1 += sy;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// Draw rectangle\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// color:color\r\n+void lcdDrawRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n+    lcdDrawLine(dev, x1, y1, x2, y1, color);\r\n+    lcdDrawLine(dev, x2, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x2, y2, x1, y2, color);\r\n+    lcdDrawLine(dev, x1, y2, x1, y1, color);\r\n+}\r\n+\r\n+// Draw rectangle with angle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of rectangle\r\n+// h:Height of rectangle\r\n+// angle:Angle of rectangle\r\n+// color:color\r\n+\r\n+// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawRectAngle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+    double xd, yd, rd;\r\n+    int x1, y1;\r\n+    int x2, y2;\r\n+    int x3, y3;\r\n+    int x4, y4;\r\n+    rd = -angle * M_PI / 180.0;\r\n+    xd = 0.0 - w / 2;\r\n+    yd = h / 2;\r\n+    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    yd = 0.0 - yd;\r\n+    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = w / 2;\r\n+    yd = h / 2;\r\n+    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    yd = 0.0 - yd;\r\n+    x4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+    lcdDrawLine(dev, x2, y2, x4, y4, color);\r\n+    lcdDrawLine(dev, x3, y3, x4, y4, color);\r\n+}\r\n+\r\n+// Draw triangle\r\n+// xc:Center X coordinate\r\n+// yc:Center Y coordinate\r\n+// w:Width of triangle\r\n+// h:Height of triangle\r\n+// angle:Angle of triangle\r\n+// color:color\r\n+\r\n+// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n+// x1 = x * cos(angle) - y * sin(angle)\r\n+// y1 = x * sin(angle) + y * cos(angle)\r\n+void lcdDrawTriangle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n+    double xd, yd, rd;\r\n+    int x1, y1;\r\n+    int x2, y2;\r\n+    int x3, y3;\r\n+    rd = -angle * M_PI / 180.0;\r\n+    xd = 0.0;\r\n+    yd = h / 2;\r\n+    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = w / 2;\r\n+    yd = 0.0 - yd;\r\n+    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    xd = 0.0 - w / 2;\r\n+    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n+    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n+\r\n+    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n+    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n+    lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n+}\r\n+\r\n+// Draw circle\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    do {\r\n+        lcdDrawPixel(dev, x0 - x, y0 + y, color);\r\n+        lcdDrawPixel(dev, x0 - y, y0 - x, color);\r\n+        lcdDrawPixel(dev, x0 + x, y0 - y, color);\r\n+        lcdDrawPixel(dev, x0 + y, y0 + x, color);\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+}\r\n+\r\n+// Draw circle of filling\r\n+// x0:Central X coordinate\r\n+// y0:Central Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawFillCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    int ChangeX;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+    ChangeX = 1;\r\n+    do {\r\n+        if (ChangeX) {\r\n+            lcdDrawLine(dev, x0 - x, y0 - y, x0 - x, y0 + y, color);\r\n+            lcdDrawLine(dev, x0 + x, y0 - y, x0 + x, y0 + y, color);\r\n+        }\r\n+        ChangeX = (old_err = err) <= x;\r\n+        if (ChangeX)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y <= 0);\r\n+}\r\n+\r\n+// Draw rectangle with round corner\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// r:radius\r\n+// color:color\r\n+void lcdDrawRoundRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n+    int x;\r\n+    int y;\r\n+    int err;\r\n+    int old_err;\r\n+    uint16_t temp;\r\n+\r\n+    if (x1 > x2) {\r\n+        temp = x1;\r\n+        x1 = x2;\r\n+        x2 = temp;\r\n+    }\r\n+\r\n+    if (y1 > y2) {\r\n+        temp = y1;\r\n+        y1 = y2;\r\n+        y2 = temp;\r\n+    }\r\n+\r\n+    if (x2 - x1 < r)\r\n+        return;\r\n+    if (y2 - y1 < r)\r\n+        return;\r\n+\r\n+    x = 0;\r\n+    y = -r;\r\n+    err = 2 - 2 * r;\r\n+\r\n+    do {\r\n+        if (x) {\r\n+            lcdDrawPixel(dev, x1 + r - x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y1 + r + y, color);\r\n+            lcdDrawPixel(dev, x1 + r - x, y2 - r - y, color);\r\n+            lcdDrawPixel(dev, x2 - r + x, y2 - r - y, color);\r\n+        }\r\n+        if ((old_err = err) <= x)\r\n+            err += ++x * 2 + 1;\r\n+        if (old_err > y || err > x)\r\n+            err += ++y * 2 + 1;\r\n+    } while (y < 0);\r\n+\r\n+    lcdDrawLine(dev, x1 + r, y1, x2 - r, y1, color);\r\n+    lcdDrawLine(dev, x1 + r, y2, x2 - r, y2, color);\r\n+    lcdDrawLine(dev, x1, y1 + r, x1, y2 - r, color);\r\n+    lcdDrawLine(dev, x2, y1 + r, x2, y2 - r, color);\r\n+}\r\n+\r\n+// Draw arrow\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n+void lcdDrawArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+}\r\n+\r\n+// Draw arrow of filling\r\n+// x1:Start X coordinate\r\n+// y1:Start Y coordinate\r\n+// x2:End   X coordinate\r\n+// y2:End   Y coordinate\r\n+// w:Width of the bottom\r\n+// color:color\r\n+void lcdDrawFillArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n+    double Vx = x1 - x0;\r\n+    double Vy = y1 - y0;\r\n+    double v = sqrt(Vx * Vx + Vy * Vy);\r\n+    double Ux = Vx / v;\r\n+    double Uy = Vy / v;\r\n+\r\n+    uint16_t L[2], R[2];\r\n+    L[0] = x1 - Uy * w - Ux * v;\r\n+    L[1] = y1 + Ux * w - Uy * v;\r\n+    R[0] = x1 + Uy * w - Ux * v;\r\n+    R[1] = y1 - Ux * w - Uy * v;\r\n+\r\n+    lcdDrawLine(dev, x0, y0, x1, y1, color);\r\n+    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n+\r\n+    for (int ww = w - 1; ww > 0; ww--) {\r\n+        L[0] = x1 - Uy * ww - Ux * v;\r\n+        L[1] = y1 + Ux * ww - Uy * v;\r\n+        R[0] = x1 + Uy * ww - Ux * v;\r\n+        R[1] = y1 - Ux * ww - Uy * v;\r\n+        lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n+        lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n+    }\r\n+}\r\n+\r\n+// RGB565 conversion\r\n+// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n+// Bit image \"RRRRRGGGGGGBBBBB\"\r\n+uint16_t rgb565_conv(uint16_t r, uint16_t g, uint16_t b) {\r\n+    return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n+}\r\n+\r\n+// Draw ASCII character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// ascii: ascii code\r\n+// color:color\r\n+int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n+\tuint16_t xx,yy,bit,ofs;\r\n+\tunsigned char fonts[128]; // font pattern\r\n+\tunsigned char pw, ph;\r\n+\tint h,w;\r\n+\tuint16_t mask;\r\n+\tbool rc;\r\n+\r\n+\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n+\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n+\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n+\tif (!rc) return 0;\r\n+\r\n+\tint16_t xd1 = 0;\r\n+\tint16_t yd1 = 0;\r\n+\tint16_t xd2 = 0;\r\n+\tint16_t yd2 = 0;\r\n+\tuint16_t xss = 0;\r\n+\tuint16_t yss = 0;\r\n+\tint16_t xsd = 0;\r\n+\tint16_t ysd = 0;\r\n+\tint16_t next = 0;\r\n+\tuint16_t x0  = 0;\r\n+\tuint16_t x1  = 0;\r\n+\tuint16_t y0  = 0;\r\n+\tuint16_t y1  = 0;\r\n+\tif (dev->_font_direction == 0) {\r\n+\t\txd1 = +1;\r\n+\t\tyd1 = +1; //-1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y - (ph - 1);\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x + pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y - (ph-1);\r\n+\t\tx1\t= x + (pw-1);\r\n+\t\ty1\t= y;\r\n+\t} else if (dev->_font_direction == 2) {\r\n+\t\txd1 = -1;\r\n+\t\tyd1 = -1; //+1;\r\n+\t\txd2 =  0;\r\n+\t\tyd2 =  0;\r\n+\t\txss =  x;\r\n+\t\tyss =  y + ph + 1;\r\n+\t\txsd =  1;\r\n+\t\tysd =  0;\r\n+\t\tnext = x - pw;\r\n+\r\n+\t\tx0\t= x - (pw-1);\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y + (ph-1);\r\n+\t} else if (dev->_font_direction == 1) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = -1;\r\n+\t\tyd2 = +1; //-1;\r\n+\t\txss =  x + ph;\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y + pw; //y - pw;\r\n+\r\n+\t\tx0\t= x;\r\n+\t\ty0\t= y;\r\n+\t\tx1\t= x + (ph-1);\r\n+\t\ty1\t= y + (pw-1);\r\n+\t} else if (dev->_font_direction == 3) {\r\n+\t\txd1 =  0;\r\n+\t\tyd1 =  0;\r\n+\t\txd2 = +1;\r\n+\t\tyd2 = -1; //+1;\r\n+\t\txss =  x - (ph - 1);\r\n+\t\tyss =  y;\r\n+\t\txsd =  0;\r\n+\t\tysd =  1;\r\n+\t\tnext = y - pw; //y + pw;\r\n+\r\n+\t\tx0\t= x - (ph-1);\r\n+\t\ty0\t= y - (pw-1);\r\n+\t\tx1\t= x;\r\n+\t\ty1\t= y;\r\n+\t}\r\n+\r\n+\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n+\t\r\n+\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1, y1, dev->_font_fill_color);\r\n+\r\n+\r\n+\tint bits;\r\n+\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n+\tofs = 0;\r\n+\tyy = yss;\r\n+\txx = xss;\r\n+\tfor(h=0;h<ph;h++) {\r\n+\t\tif(xsd) xx = xss;\r\n+\t\tif(ysd) yy = yss;\r\n+\t\t//for(w=0;w<(pw/8);w++) {\r\n+\t\tbits = pw;\r\n+\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n+\t\t\tmask = 0x80;\r\n+\t\t\tfor(bit=0;bit<8;bit++) {\r\n+\t\t\t\tbits--;\r\n+\t\t\t\tif (bits < 0) continue;\r\n+\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n+\t\t\t\tif (fonts[ofs] & mask) {\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n+\t\t\t\t} else {\r\n+\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n+\t\t\t\t}\r\n+\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n+\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n+\t\t\t\txx = xx + xd1;\r\n+\t\t\t\tyy = yy + yd2;\r\n+\t\t\t\tmask = mask >> 1;\r\n+\t\t\t}\r\n+\t\t\tofs++;\r\n+\t\t}\r\n+\t\tyy = yy + yd1;\r\n+\t\txx = xx + xd2;\r\n+\t}\r\n+\r\n+\tif (next < 0) next = 0;\r\n+\treturn next;\r\n+}\r\n+\r\n+int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n+\tint length = strlen((char *)ascii);\r\n+\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n+\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n+\tfor(int i=0;i<length;i++) {\r\n+\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n+\t\tif (dev->_font_direction == 0)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 1)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 2)\r\n+\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t\tif (dev->_font_direction == 3)\r\n+\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n+\t}\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+\r\n+// Draw Non-Alphanumeric character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// code:character code\r\n+// color:color\r\n+int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n+\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n+\tif (dev->_font_direction == 0)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 1)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 2)\r\n+\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 3)\r\n+\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n+\tif (dev->_font_direction == 0) return x;\r\n+\tif (dev->_font_direction == 2) return x;\r\n+\tif (dev->_font_direction == 1) return y;\r\n+\tif (dev->_font_direction == 3) return y;\r\n+\treturn 0;\r\n+}\r\n+\r\n+#if 0\r\n+// Draw UTF8 character\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utf8:UTF8 code\r\n+// color:color\r\n+int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n+    uint16_t sjis[1];\r\n+\r\n+    sjis[0] = UTF2SJIS(utf8);\r\n+    if(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n+    return lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n+}\r\n+\r\n+// Draw UTF8 string\r\n+// x:X coordinate\r\n+// y:Y coordinate\r\n+// utfs:UTF8 string\r\n+// color:color\r\n+int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n+\r\n+    int i;\r\n+    int spos;\r\n+    uint16_t sjis[64];\r\n+    spos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n+    if(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n+    ESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n+    for(i=0;i<spos;i++) {\r\n+        if(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n+        if (dev->_font_direction == 0)\r\n+            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 1)\r\n+            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 2)\r\n+            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+        if (dev->_font_direction == 3)\r\n+            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n+    }\r\n+    if (dev->_font_direction == 0) return x;\r\n+    if (dev->_font_direction == 2) return x;\r\n+    if (dev->_font_direction == 1) return y;\r\n+    if (dev->_font_direction == 3) return y;\r\n+    return 0;\r\n+}\r\n+#endif\r\n+\r\n+// Set font direction\r\n+// dir:Direction\r\n+void lcdSetFontDirection(TFT_t *dev, uint16_t dir) {\r\n+    dev->_font_direction = dir;\r\n+}\r\n+\r\n+// Set font filling\r\n+// color:fill color\r\n+void lcdSetFontFill(TFT_t *dev, uint16_t color) {\r\n+    dev->_font_fill = true;\r\n+    dev->_font_fill_color = color;\r\n+}\r\n+\r\n+// UnSet font filling\r\n+void lcdUnsetFontFill(TFT_t *dev) {\r\n+    dev->_font_fill = false;\r\n+}\r\n+\r\n+// Set font underline\r\n+// color:frame color\r\n+void lcdSetFontUnderLine(TFT_t *dev, uint16_t color) {\r\n+    dev->_font_underline = true;\r\n+    dev->_font_underline_color = color;\r\n+}\r\n+\r\n+// UnSet font underline\r\n+void lcdUnsetFontUnderLine(TFT_t *dev) {\r\n+    dev->_font_underline = false;\r\n+}\r\n+\r\n+// Backlight ON\r\n+void lcdBacklightOn(TFT_t *dev) {\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 1);  // Set backlight pin high\r\n+        ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n+    }\r\n+}\r\n+\r\n+// Backlight OFF\r\n+void lcdBacklightOff(TFT_t *dev) {\r\n+    if (dev->_bl >= 0) {\r\n+        gpio_set_level(dev->_bl, 0);  // Set backlight pin low\r\n+        ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n+    }\r\n+}\r\n+\r\n+\r\n+// Display Inversion Off\r\n+void lcdInversionOff(TFT_t *dev) {\r\n+    ESP_LOGI(TAG, \"Disabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x20);  // INVOFF: Display Inversion Off\r\n+}\r\n+\r\n+// Display Inversion On\r\n+void lcdInversionOn(TFT_t *dev) {\r\n+    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n+    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n+}\r\n"
                },
                {
                    "date": 1731818332667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n     dev->_SPIHandle = handle;\r\n \r\n     // Initialize Backlight pin AFTER SPI initialization\r\n     ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n+    if (GPIO_BL = 0) {\r\n         gpio_reset_pin(GPIO_BL);\r\n         gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n         gpio_set_level(GPIO_BL, 0);  // Set GPIO_BL high to turn on the backlight\r\n         ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n@@ -1008,1015 +1008,4 @@\n void lcdInversionOn(TFT_t *dev) {\r\n     ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n     spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n }\r\n-#include <string.h>\r\n-#include <inttypes.h>\r\n-#include <math.h>\r\n-\r\n-#include \"freertos/FreeRTOS.h\"\r\n-#include \"freertos/task.h\"\r\n-\r\n-#include <driver/spi_master.h>\r\n-#include <driver/gpio.h>\r\n-#include \"esp_log.h\"\r\n-\r\n-#include \"st7796s.h\"  // Updated to the correct header file\r\n-\r\n-#define TAG \"ST7796S\"\r\n-#define _DEBUG_ 0\r\n-\r\n-#if CONFIG_SPI2_HOST\r\n-#define HOST_ID SPI2_HOST\r\n-#elif CONFIG_SPI3_HOST\r\n-#define HOST_ID SPI3_HOST\r\n-#endif\r\n-\r\n-static const int SPI_Command_Mode = 0;\r\n-static const int SPI_Data_Mode = 1;\r\n-static const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n-\r\n-void spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n-                     int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n-    esp_err_t ret;\r\n-\r\n-    // Initialize CS pin\r\n-    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n-    if (GPIO_CS >= 0) {\r\n-        gpio_reset_pin(GPIO_CS);\r\n-        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_CS, 1);\r\n-    }\r\n-\r\n-    // Initialize DC pin\r\n-    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n-    gpio_reset_pin(GPIO_DC);\r\n-    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n-    gpio_set_level(GPIO_DC, 0);\r\n-\r\n-    // Initialize RESET pin\r\n-    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n-    if (GPIO_RESET >= 0) {\r\n-        gpio_reset_pin(GPIO_RESET);\r\n-        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_RESET, 1);  // Ensure the reset pin starts high\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 0);  // Pulse reset pin\r\n-        delayMS(100);\r\n-        gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n-        delayMS(100);\r\n-    }\r\n-\r\n-    // Initialize SPI bus\r\n-    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n-    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n-    spi_bus_config_t buscfg = {\r\n-        .mosi_io_num = GPIO_MOSI,\r\n-        .miso_io_num = -1,\r\n-        .sclk_io_num = GPIO_SCLK,\r\n-        .quadwp_io_num = -1,\r\n-        .quadhd_io_num = -1,\r\n-        .max_transfer_sz = 6 * 1024,\r\n-        .flags = SPICOMMON_BUSFLAG_MASTER,\r\n-    };\r\n-\r\n-    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n-    ESP_LOGI(TAG, \"spi_bus_initialize=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    spi_device_interface_config_t devcfg;\r\n-    memset(&devcfg, 0, sizeof(devcfg));\r\n-    devcfg.clock_speed_hz = SPI_Frequency;\r\n-    devcfg.queue_size = 7;\r\n-    devcfg.mode = 0;  // SPI mode 0\r\n-    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n-\r\n-    if (GPIO_CS >= 0) {\r\n-        devcfg.spics_io_num = GPIO_CS;\r\n-    } else {\r\n-        devcfg.spics_io_num = -1;\r\n-    }\r\n-\r\n-    spi_device_handle_t handle;\r\n-    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n-    ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n-    assert(ret == ESP_OK);\r\n-\r\n-    // Store GPIO numbers and SPI handle in device structure\r\n-    dev->_dc = GPIO_DC;\r\n-    dev->_bl = GPIO_BL;\r\n-    dev->_SPIHandle = handle;\r\n-\r\n-    // Initialize Backlight pin AFTER SPI initialization\r\n-    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL >= 0) {\r\n-        gpio_reset_pin(GPIO_BL);\r\n-        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n-        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n-        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n-    }\r\n-}\r\n-\r\n-\r\n-bool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n-    spi_transaction_t SPITransaction;\r\n-    esp_err_t ret;\r\n-\r\n-    if (DataLength > 0) {\r\n-        memset(&SPITransaction, 0, sizeof(spi_transaction_t));\r\n-        SPITransaction.length = DataLength * 8;\r\n-        SPITransaction.tx_buffer = Data;\r\n-        ret = spi_device_polling_transmit(SPIHandle, &SPITransaction);\r\n-        assert(ret == ESP_OK);\r\n-    }\r\n-\r\n-    return true;\r\n-}\r\n-\r\n-bool spi_master_write_command(TFT_t *dev, uint8_t cmd) {\r\n-    uint8_t Byte = cmd;\r\n-    gpio_set_level(dev->_dc, SPI_Command_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n-}\r\n-\r\n-bool spi_master_write_data_byte(TFT_t *dev, uint8_t data) {\r\n-    uint8_t Byte = data;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n-}\r\n-\r\n-bool spi_master_write_data_word(TFT_t *dev, uint16_t data) {\r\n-    uint8_t Byte[2];\r\n-    Byte[0] = (data >> 8) & 0xFF;\r\n-    Byte[1] = data & 0xFF;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, Byte, 2);\r\n-}\r\n-\r\n-bool spi_master_write_addr(TFT_t *dev, uint16_t addr1, uint16_t addr2) {\r\n-    uint8_t Byte[4];\r\n-    Byte[0] = (addr1 >> 8) & 0xFF;\r\n-    Byte[1] = addr1 & 0xFF;\r\n-    Byte[2] = (addr2 >> 8) & 0xFF;\r\n-    Byte[3] = addr2 & 0xFF;\r\n-    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-    return spi_master_write_byte(dev->_SPIHandle, Byte, 4);\r\n-}\r\n-\r\n-bool spi_master_write_color(TFT_t *dev, uint16_t color, uint32_t size) {\r\n-    uint8_t Byte[1024];\r\n-    uint32_t len = size * 2;\r\n-    uint32_t max_chunk = sizeof(Byte);\r\n-\r\n-    while (len > 0) {\r\n-        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n-        uint32_t color_count = chunk_size / 2;\r\n-        for (uint32_t i = 0; i < color_count; i++) {\r\n-            Byte[i * 2] = (color >> 8) & 0xFF;\r\n-            Byte[i * 2 + 1] = color & 0xFF;\r\n-        }\r\n-        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n-        len -= chunk_size;\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-// Add 202001\r\n-bool spi_master_write_colors(TFT_t *dev, uint16_t *colors, uint16_t size) {\r\n-    uint8_t Byte[1024];\r\n-    uint32_t index = 0;\r\n-    uint32_t len = size * 2;\r\n-    uint32_t max_chunk = sizeof(Byte);\r\n-\r\n-    while (len > 0) {\r\n-        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n-        uint32_t color_count = chunk_size / 2;\r\n-        for (uint32_t i = 0; i < color_count; i++) {\r\n-            Byte[i * 2] = (colors[index] >> 8) & 0xFF;\r\n-            Byte[i * 2 + 1] = colors[index] & 0xFF;\r\n-            index++;\r\n-        }\r\n-        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n-        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n-        len -= chunk_size;\r\n-    }\r\n-    return true;\r\n-}\r\n-\r\n-void delayMS(int ms) {\r\n-    vTaskDelay(pdMS_TO_TICKS(ms));\r\n-}\r\n-\r\n-void lcdInit(TFT_t *dev, int width, int height, int offsetx, int offsety) {\r\n-    dev->_width = width;\r\n-    dev->_height = height;\r\n-    dev->_offsetx = offsetx;\r\n-    dev->_offsety = offsety;\r\n-    dev->_font_direction = DIRECTION0;\r\n-    dev->_font_fill = false;\r\n-    dev->_font_underline = false;\r\n-\r\n-    ESP_LOGI(TAG, \"Initializing ST7796S LCD\");\r\n-\r\n-    // Hardware reset\r\n-    if (dev->_reset >= 0) {\r\n-        gpio_set_level(dev->_reset, 0); // Set RESX low\r\n-        delayMS(20);                   // Minimum 10ms\r\n-        gpio_set_level(dev->_reset, 1); // Set RESX high\r\n-        delayMS(120);                  // Wait for reset complete\r\n-    }\r\n-\r\n-    // Software reset\r\n-    ESP_LOGI(TAG, \"Sending Software Reset\");\r\n-    spi_master_write_command(dev, 0x01);  // SWRESET: Software Reset\r\n-    delayMS(150);                        // Wait for reset process\r\n-\r\n-    // Exit Sleep mode\r\n-    ESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n-    spi_master_write_command(dev, 0x11);  // SLPOUT: Sleep Out\r\n-    delayMS(120);\r\n-\r\n-    // Memory Data Access Control\r\n-    ESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n-    spi_master_write_command(dev, 0x36);  // MADCTL: Memory Data Access Control\r\n-    spi_master_write_data_byte(dev, 0x48); // Adjust orientation (0x48 for default landscape)\r\n-    delayMS(10);\r\n-\r\n-    // Interface Pixel Format (16-bit/pixel)\r\n-    ESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n-    spi_master_write_command(dev, 0x3A);  // COLMOD: Interface Pixel Format\r\n-    spi_master_write_data_byte(dev, 0x55); // 16-bit/pixel (RGB 5-6-5)\r\n-    delayMS(10);\r\n-\r\n-    // Porch Setting\r\n-    ESP_LOGI(TAG, \"Setting Porch Control\");\r\n-    spi_master_write_command(dev, 0xB2);  // PORCTRL: Porch Control\r\n-    spi_master_write_data_byte(dev, 0x0C); // Front Porch\r\n-    spi_master_write_data_byte(dev, 0x0C); // Back Porch\r\n-    spi_master_write_data_byte(dev, 0x00); // Vertical Porch\r\n-    spi_master_write_data_byte(dev, 0x33);\r\n-    spi_master_write_data_byte(dev, 0x33);\r\n-    delayMS(10);\r\n-\r\n-    // VCOM Setting\r\n-    ESP_LOGI(TAG, \"Setting VCOM\");\r\n-    spi_master_write_command(dev, 0xBB);  // VCOMS: VCOM Setting\r\n-    spi_master_write_data_byte(dev, 0x35); // VCOM voltage level (1.175V)\r\n-    delayMS(10);\r\n-\r\n-    // LCM Control\r\n-    ESP_LOGI(TAG, \"Setting LCM Control\");\r\n-    spi_master_write_command(dev, 0xC0);  // LCMCTRL: LCM Control\r\n-    spi_master_write_data_byte(dev, 0x2C); // Default\r\n-    delayMS(10);\r\n-\r\n-    // VDV and VRH Command Enable\r\n-    ESP_LOGI(TAG, \"Enabling VDV and VRH Commands\");\r\n-    spi_master_write_command(dev, 0xC2);  // VDVVRHEN: Enable VDV and VRH\r\n-    spi_master_write_data_byte(dev, 0x01); // Enable\r\n-    delayMS(10);\r\n-\r\n-    // VRH Set\r\n-    ESP_LOGI(TAG, \"Setting VRH\");\r\n-    spi_master_write_command(dev, 0xC3);  // VRHS: VRH Set\r\n-    spi_master_write_data_byte(dev, 0x12); // Default\r\n-    delayMS(10);\r\n-\r\n-    // VDV Set\r\n-    ESP_LOGI(TAG, \"Setting VDV\");\r\n-    spi_master_write_command(dev, 0xC4);  // VDVS: VDV Set\r\n-    spi_master_write_data_byte(dev, 0x20); // Default\r\n-    delayMS(10);\r\n-\r\n-    // Frame Rate Control\r\n-    ESP_LOGI(TAG, \"Setting Frame Rate Control\");\r\n-    spi_master_write_command(dev, 0xC6);  // FRCTRL2: Frame Rate Control\r\n-    spi_master_write_data_byte(dev, 0x0F); // Default frame rate: 60Hz\r\n-    delayMS(10);\r\n-\r\n-    // Power Control 1\r\n-    ESP_LOGI(TAG, \"Setting Power Control 1\");\r\n-    spi_master_write_command(dev, 0xD0);  // PWCTRL1: Power Control 1\r\n-    spi_master_write_data_byte(dev, 0xA4); // Default\r\n-    spi_master_write_data_byte(dev, 0xA1); // Default\r\n-    delayMS(10);\r\n-\r\n-    // Positive Voltage Gamma Control\r\n-    ESP_LOGI(TAG, \"Setting Positive Voltage Gamma Control\");\r\n-    spi_master_write_command(dev, 0xE0);  // PGAMCTRL: Positive Gamma Control\r\n-    uint8_t positive_gamma[] = {0xD0, 0x08, 0x11, 0x08, 0x0C, 0x15, 0x39, 0x33, 0x50, 0x36, 0x13, 0x14, 0x29, 0x2D};\r\n-    for (int i = 0; i < sizeof(positive_gamma); i++) {\r\n-        spi_master_write_data_byte(dev, positive_gamma[i]);\r\n-    }\r\n-    delayMS(10);\r\n-\r\n-    // Negative Voltage Gamma Control\r\n-    ESP_LOGI(TAG, \"Setting Negative Voltage Gamma Control\");\r\n-    spi_master_write_command(dev, 0xE1);  // NVGAMCTRL: Negative Gamma Control\r\n-    uint8_t negative_gamma[] = {0xD0, 0x08, 0x10, 0x08, 0x06, 0x06, 0x39, 0x44, 0x51, 0x0B, 0x16, 0x14, 0x2F, 0x31};\r\n-    for (int i = 0; i < sizeof(negative_gamma); i++) {\r\n-        spi_master_write_data_byte(dev, negative_gamma[i]);\r\n-    }\r\n-    delayMS(10);\r\n-\r\n-    // Enable Display Inversion\r\n-    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n-    delayMS(10);\r\n-\r\n-    // Normal Display Mode On\r\n-    ESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n-    spi_master_write_command(dev, 0x13);  // NORON: Normal Display Mode On\r\n-    delayMS(10);\r\n-\r\n-    // Turn on Display\r\n-    ESP_LOGI(TAG, \"Turning Display On\");\r\n-    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n-    delayMS(120);                          // Wait for display to turn on\r\n-\r\n-    // Backlight control\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 1);\r\n-        ESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n-    }\r\n-}\r\n-\r\n-// Draw pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// color:color\r\n-void lcdDrawPixel(TFT_t *dev, uint16_t x, uint16_t y, uint16_t color) {\r\n-    if (x >= dev->_width)\r\n-        return;\r\n-    if (y >= dev->_height)\r\n-        return;\r\n-\r\n-    uint16_t _x = x + dev->_offsetx;\r\n-    uint16_t _y = y + dev->_offsety;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x, _x);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y, _y);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-    spi_master_write_data_word(dev, color);\r\n-}\r\n-\r\n-// Draw multi pixel\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// size:Number of colors\r\n-// colors:colors\r\n-void lcdDrawMultiPixels(TFT_t *dev, uint16_t x, uint16_t y, uint16_t size, uint16_t *colors) {\r\n-    if (x + size > dev->_width)\r\n-        return;\r\n-    if (y >= dev->_height)\r\n-        return;\r\n-\r\n-    uint16_t _x1 = x + dev->_offsetx;\r\n-    uint16_t _x2 = _x1 + (size - 1);\r\n-    uint16_t _y1 = y + dev->_offsety;\r\n-    uint16_t _y2 = _y1;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x1, _x2);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y1, _y2);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-    spi_master_write_colors(dev, colors, size);\r\n-}\r\n-\r\n-// Draw rectangle of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End X coordinate\r\n-// y2:End Y coordinate\r\n-// color:color\r\n-void lcdDrawFillRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    if (x1 >= dev->_width)\r\n-        return;\r\n-    if (x2 >= dev->_width)\r\n-        x2 = dev->_width - 1;\r\n-    if (y1 >= dev->_height)\r\n-        return;\r\n-    if (y2 >= dev->_height)\r\n-        y2 = dev->_height - 1;\r\n-\r\n-    uint16_t _x1 = x1 + dev->_offsetx;\r\n-    uint16_t _x2 = x2 + dev->_offsetx;\r\n-    uint16_t _y1 = y1 + dev->_offsety;\r\n-    uint16_t _y2 = y2 + dev->_offsety;\r\n-\r\n-    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n-    spi_master_write_addr(dev, _x1, _x2);\r\n-    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n-    spi_master_write_addr(dev, _y1, _y2);\r\n-    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n-\r\n-    uint32_t size = (_x2 - _x1 + 1) * (_y2 - _y1 + 1);\r\n-    spi_master_write_color(dev, color, size);\r\n-}\r\n-\r\n-// Display OFF\r\n-void lcdDisplayOff(TFT_t *dev) {\r\n-    spi_master_write_command(dev, 0x28);  // DISPOFF: Display Off\r\n-}\r\n-\r\n-// Display ON\r\n-void lcdDisplayOn(TFT_t *dev) {\r\n-    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n-}\r\n-\r\n-// Fill screen\r\n-// color:color\r\n-void lcdFillScreen(TFT_t *dev, uint16_t color) {\r\n-    lcdDrawFillRect(dev, 0, 0, dev->_width - 1, dev->_height - 1, color);\r\n-}\r\n-\r\n-// Draw line\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawLine(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    int dx, dy, sx, sy, err, e2;\r\n-\r\n-    dx = abs(x2 - x1);\r\n-    dy = -abs(y2 - y1);\r\n-\r\n-    sx = (x1 < x2) ? 1 : -1;\r\n-    sy = (y1 < y2) ? 1 : -1;\r\n-\r\n-    err = dx + dy;\r\n-\r\n-    while (1) {\r\n-        lcdDrawPixel(dev, x1, y1, color);\r\n-        if (x1 == x2 && y1 == y2)\r\n-            break;\r\n-        e2 = 2 * err;\r\n-        if (e2 >= dy) {\r\n-            err += dy;\r\n-            x1 += sx;\r\n-        }\r\n-        if (e2 <= dx) {\r\n-            err += dx;\r\n-            y1 += sy;\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-// Draw rectangle\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// color:color\r\n-void lcdDrawRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n-    lcdDrawLine(dev, x1, y1, x2, y1, color);\r\n-    lcdDrawLine(dev, x2, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x2, y2, x1, y2, color);\r\n-    lcdDrawLine(dev, x1, y2, x1, y1, color);\r\n-}\r\n-\r\n-// Draw rectangle with angle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of rectangle\r\n-// h:Height of rectangle\r\n-// angle:Angle of rectangle\r\n-// color:color\r\n-\r\n-// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawRectAngle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-    double xd, yd, rd;\r\n-    int x1, y1;\r\n-    int x2, y2;\r\n-    int x3, y3;\r\n-    int x4, y4;\r\n-    rd = -angle * M_PI / 180.0;\r\n-    xd = 0.0 - w / 2;\r\n-    yd = h / 2;\r\n-    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    yd = 0.0 - yd;\r\n-    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = w / 2;\r\n-    yd = h / 2;\r\n-    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    yd = 0.0 - yd;\r\n-    x4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-    lcdDrawLine(dev, x2, y2, x4, y4, color);\r\n-    lcdDrawLine(dev, x3, y3, x4, y4, color);\r\n-}\r\n-\r\n-// Draw triangle\r\n-// xc:Center X coordinate\r\n-// yc:Center Y coordinate\r\n-// w:Width of triangle\r\n-// h:Height of triangle\r\n-// angle:Angle of triangle\r\n-// color:color\r\n-\r\n-// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n-// x1 = x * cos(angle) - y * sin(angle)\r\n-// y1 = x * sin(angle) + y * cos(angle)\r\n-void lcdDrawTriangle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n-    double xd, yd, rd;\r\n-    int x1, y1;\r\n-    int x2, y2;\r\n-    int x3, y3;\r\n-    rd = -angle * M_PI / 180.0;\r\n-    xd = 0.0;\r\n-    yd = h / 2;\r\n-    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = w / 2;\r\n-    yd = 0.0 - yd;\r\n-    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    xd = 0.0 - w / 2;\r\n-    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n-    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n-\r\n-    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n-    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n-    lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n-}\r\n-\r\n-// Draw circle\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-    do {\r\n-        lcdDrawPixel(dev, x0 - x, y0 + y, color);\r\n-        lcdDrawPixel(dev, x0 - y, y0 - x, color);\r\n-        lcdDrawPixel(dev, x0 + x, y0 - y, color);\r\n-        lcdDrawPixel(dev, x0 + y, y0 + x, color);\r\n-        if ((old_err = err) <= x)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y < 0);\r\n-}\r\n-\r\n-// Draw circle of filling\r\n-// x0:Central X coordinate\r\n-// y0:Central Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawFillCircle(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-    int ChangeX;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-    ChangeX = 1;\r\n-    do {\r\n-        if (ChangeX) {\r\n-            lcdDrawLine(dev, x0 - x, y0 - y, x0 - x, y0 + y, color);\r\n-            lcdDrawLine(dev, x0 + x, y0 - y, x0 + x, y0 + y, color);\r\n-        }\r\n-        ChangeX = (old_err = err) <= x;\r\n-        if (ChangeX)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y <= 0);\r\n-}\r\n-\r\n-// Draw rectangle with round corner\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// r:radius\r\n-// color:color\r\n-void lcdDrawRoundRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t r, uint16_t color) {\r\n-    int x;\r\n-    int y;\r\n-    int err;\r\n-    int old_err;\r\n-    uint16_t temp;\r\n-\r\n-    if (x1 > x2) {\r\n-        temp = x1;\r\n-        x1 = x2;\r\n-        x2 = temp;\r\n-    }\r\n-\r\n-    if (y1 > y2) {\r\n-        temp = y1;\r\n-        y1 = y2;\r\n-        y2 = temp;\r\n-    }\r\n-\r\n-    if (x2 - x1 < r)\r\n-        return;\r\n-    if (y2 - y1 < r)\r\n-        return;\r\n-\r\n-    x = 0;\r\n-    y = -r;\r\n-    err = 2 - 2 * r;\r\n-\r\n-    do {\r\n-        if (x) {\r\n-            lcdDrawPixel(dev, x1 + r - x, y1 + r + y, color);\r\n-            lcdDrawPixel(dev, x2 - r + x, y1 + r + y, color);\r\n-            lcdDrawPixel(dev, x1 + r - x, y2 - r - y, color);\r\n-            lcdDrawPixel(dev, x2 - r + x, y2 - r - y, color);\r\n-        }\r\n-        if ((old_err = err) <= x)\r\n-            err += ++x * 2 + 1;\r\n-        if (old_err > y || err > x)\r\n-            err += ++y * 2 + 1;\r\n-    } while (y < 0);\r\n-\r\n-    lcdDrawLine(dev, x1 + r, y1, x2 - r, y1, color);\r\n-    lcdDrawLine(dev, x1 + r, y2, x2 - r, y2, color);\r\n-    lcdDrawLine(dev, x1, y1 + r, x1, y2 - r, color);\r\n-    lcdDrawLine(dev, x2, y1 + r, x2, y2 - r, color);\r\n-}\r\n-\r\n-// Draw arrow\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the bottom\r\n-// color:color\r\n-// Thanks http://k-hiura.cocolog-nifty.com/blog/2010/11/post-2a62.html\r\n-void lcdDrawArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n-    double Vx = x1 - x0;\r\n-    double Vy = y1 - y0;\r\n-    double v = sqrt(Vx * Vx + Vy * Vy);\r\n-    double Ux = Vx / v;\r\n-    double Uy = Vy / v;\r\n-\r\n-    uint16_t L[2], R[2];\r\n-    L[0] = x1 - Uy * w - Ux * v;\r\n-    L[1] = y1 + Ux * w - Uy * v;\r\n-    R[0] = x1 + Uy * w - Ux * v;\r\n-    R[1] = y1 - Ux * w - Uy * v;\r\n-\r\n-    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-}\r\n-\r\n-// Draw arrow of filling\r\n-// x1:Start X coordinate\r\n-// y1:Start Y coordinate\r\n-// x2:End   X coordinate\r\n-// y2:End   Y coordinate\r\n-// w:Width of the bottom\r\n-// color:color\r\n-void lcdDrawFillArrow(TFT_t *dev, uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1, uint16_t w, uint16_t color) {\r\n-    double Vx = x1 - x0;\r\n-    double Vy = y1 - y0;\r\n-    double v = sqrt(Vx * Vx + Vy * Vy);\r\n-    double Ux = Vx / v;\r\n-    double Uy = Vy / v;\r\n-\r\n-    uint16_t L[2], R[2];\r\n-    L[0] = x1 - Uy * w - Ux * v;\r\n-    L[1] = y1 + Ux * w - Uy * v;\r\n-    R[0] = x1 + Uy * w - Ux * v;\r\n-    R[1] = y1 - Ux * w - Uy * v;\r\n-\r\n-    lcdDrawLine(dev, x0, y0, x1, y1, color);\r\n-    lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-    lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    lcdDrawLine(dev, L[0], L[1], R[0], R[1], color);\r\n-\r\n-    for (int ww = w - 1; ww > 0; ww--) {\r\n-        L[0] = x1 - Uy * ww - Ux * v;\r\n-        L[1] = y1 + Ux * ww - Uy * v;\r\n-        R[0] = x1 + Uy * ww - Ux * v;\r\n-        R[1] = y1 - Ux * ww - Uy * v;\r\n-        lcdDrawLine(dev, x1, y1, L[0], L[1], color);\r\n-        lcdDrawLine(dev, x1, y1, R[0], R[1], color);\r\n-    }\r\n-}\r\n-\r\n-// RGB565 conversion\r\n-// RGB565 is R(5)+G(6)+B(5)=16bit color format.\r\n-// Bit image \"RRRRRGGGGGGBBBBB\"\r\n-uint16_t rgb565_conv(uint16_t r, uint16_t g, uint16_t b) {\r\n-    return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));\r\n-}\r\n-\r\n-// Draw ASCII character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// ascii: ascii code\r\n-// color:color\r\n-int lcdDrawChar(TFT_t * dev, FontxFile *fxs, uint16_t x, uint16_t y, uint8_t ascii, uint16_t color) {\r\n-\tuint16_t xx,yy,bit,ofs;\r\n-\tunsigned char fonts[128]; // font pattern\r\n-\tunsigned char pw, ph;\r\n-\tint h,w;\r\n-\tuint16_t mask;\r\n-\tbool rc;\r\n-\r\n-\tif(_DEBUG_)printf(\"_font_direction=%d\\n\",dev->_font_direction);\r\n-\trc = GetFontx(fxs, ascii, fonts, &pw, &ph);\r\n-\tif(_DEBUG_)printf(\"GetFontx rc=%d pw=%d ph=%d\\n\",rc,pw,ph);\r\n-\tif (!rc) return 0;\r\n-\r\n-\tint16_t xd1 = 0;\r\n-\tint16_t yd1 = 0;\r\n-\tint16_t xd2 = 0;\r\n-\tint16_t yd2 = 0;\r\n-\tuint16_t xss = 0;\r\n-\tuint16_t yss = 0;\r\n-\tint16_t xsd = 0;\r\n-\tint16_t ysd = 0;\r\n-\tint16_t next = 0;\r\n-\tuint16_t x0  = 0;\r\n-\tuint16_t x1  = 0;\r\n-\tuint16_t y0  = 0;\r\n-\tuint16_t y1  = 0;\r\n-\tif (dev->_font_direction == 0) {\r\n-\t\txd1 = +1;\r\n-\t\tyd1 = +1; //-1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y - (ph - 1);\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x + pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y - (ph-1);\r\n-\t\tx1\t= x + (pw-1);\r\n-\t\ty1\t= y;\r\n-\t} else if (dev->_font_direction == 2) {\r\n-\t\txd1 = -1;\r\n-\t\tyd1 = -1; //+1;\r\n-\t\txd2 =  0;\r\n-\t\tyd2 =  0;\r\n-\t\txss =  x;\r\n-\t\tyss =  y + ph + 1;\r\n-\t\txsd =  1;\r\n-\t\tysd =  0;\r\n-\t\tnext = x - pw;\r\n-\r\n-\t\tx0\t= x - (pw-1);\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y + (ph-1);\r\n-\t} else if (dev->_font_direction == 1) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = -1;\r\n-\t\tyd2 = +1; //-1;\r\n-\t\txss =  x + ph;\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y + pw; //y - pw;\r\n-\r\n-\t\tx0\t= x;\r\n-\t\ty0\t= y;\r\n-\t\tx1\t= x + (ph-1);\r\n-\t\ty1\t= y + (pw-1);\r\n-\t} else if (dev->_font_direction == 3) {\r\n-\t\txd1 =  0;\r\n-\t\tyd1 =  0;\r\n-\t\txd2 = +1;\r\n-\t\tyd2 = -1; //+1;\r\n-\t\txss =  x - (ph - 1);\r\n-\t\tyss =  y;\r\n-\t\txsd =  0;\r\n-\t\tysd =  1;\r\n-\t\tnext = y - pw; //y + pw;\r\n-\r\n-\t\tx0\t= x - (ph-1);\r\n-\t\ty0\t= y - (pw-1);\r\n-\t\tx1\t= x;\r\n-\t\ty1\t= y;\r\n-\t}\r\n-\r\n-\tif (dev->_font_fill) lcdDrawFillRect(dev, x0, y0, x1, y1, dev->_font_fill_color);\r\n-\t\r\n-\tESP_LOGD(TAG, \"Filling font background: x0=%d y0=%d x1=%d y1=%d color=0x%04X\", x0, y0, x1, y1, dev->_font_fill_color);\r\n-\r\n-\r\n-\tint bits;\r\n-\tif(_DEBUG_)printf(\"xss=%d yss=%d\\n\",xss,yss);\r\n-\tofs = 0;\r\n-\tyy = yss;\r\n-\txx = xss;\r\n-\tfor(h=0;h<ph;h++) {\r\n-\t\tif(xsd) xx = xss;\r\n-\t\tif(ysd) yy = yss;\r\n-\t\t//for(w=0;w<(pw/8);w++) {\r\n-\t\tbits = pw;\r\n-\t\tfor(w=0;w<((pw+4)/8);w++) {\r\n-\t\t\tmask = 0x80;\r\n-\t\t\tfor(bit=0;bit<8;bit++) {\r\n-\t\t\t\tbits--;\r\n-\t\t\t\tif (bits < 0) continue;\r\n-\t\t\t\t//if(_DEBUG_)printf(\"xx=%d yy=%d mask=%02x fonts[%d]=%02x\\n\",xx,yy,mask,ofs,fonts[ofs]);\r\n-\t\t\t\tif (fonts[ofs] & mask) {\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, color);\r\n-\t\t\t\t} else {\r\n-\t\t\t\t\t//if (dev->_font_fill) lcdDrawPixel(dev, xx, yy, dev->_font_fill_color);\r\n-\t\t\t\t}\r\n-\t\t\t\tif (h == (ph-2) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\tif (h == (ph-1) && dev->_font_underline)\r\n-\t\t\t\t\tlcdDrawPixel(dev, xx, yy, dev->_font_underline_color);\r\n-\t\t\t\txx = xx + xd1;\r\n-\t\t\t\tyy = yy + yd2;\r\n-\t\t\t\tmask = mask >> 1;\r\n-\t\t\t}\r\n-\t\t\tofs++;\r\n-\t\t}\r\n-\t\tyy = yy + yd1;\r\n-\t\txx = xx + xd2;\r\n-\t}\r\n-\r\n-\tif (next < 0) next = 0;\r\n-\treturn next;\r\n-}\r\n-\r\n-int lcdDrawString(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, uint8_t * ascii, uint16_t color) {\r\n-\tint length = strlen((char *)ascii);\r\n-\tif(_DEBUG_)printf(\"lcdDrawString length=%d\\n\",length);\r\n-\tESP_LOGD(TAG, \"Drawing string: \\\"%s\\\" at x=%d y=%d color=0x%04X\", ascii, x, y, color);\r\n-\tfor(int i=0;i<length;i++) {\r\n-\t\tif(_DEBUG_)printf(\"ascii[%d]=%x x=%d y=%d\\n\",i,ascii[i],x,y);\r\n-\t\tif (dev->_font_direction == 0)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 1)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 2)\r\n-\t\t\tx = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t\tif (dev->_font_direction == 3)\r\n-\t\t\ty = lcdDrawChar(dev, fx, x, y, ascii[i], color);\r\n-\t}\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-\r\n-// Draw Non-Alphanumeric character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// code:character code\r\n-// color:color\r\n-int lcdDrawCode(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t code,uint16_t color) {\r\n-\tif(_DEBUG_)printf(\"code=%x x=%d y=%d\\n\",code,x,y);\r\n-\tif (dev->_font_direction == 0)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 1)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 2)\r\n-\t\tx = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 3)\r\n-\t\ty = lcdDrawChar(dev, fx, x, y, code, color);\r\n-\tif (dev->_font_direction == 0) return x;\r\n-\tif (dev->_font_direction == 2) return x;\r\n-\tif (dev->_font_direction == 1) return y;\r\n-\tif (dev->_font_direction == 3) return y;\r\n-\treturn 0;\r\n-}\r\n-\r\n-#if 0\r\n-// Draw UTF8 character\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utf8:UTF8 code\r\n-// color:color\r\n-int lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n-    uint16_t sjis[1];\r\n-\r\n-    sjis[0] = UTF2SJIS(utf8);\r\n-    if(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n-    return lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n-}\r\n-\r\n-// Draw UTF8 string\r\n-// x:X coordinate\r\n-// y:Y coordinate\r\n-// utfs:UTF8 string\r\n-// color:color\r\n-int lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n-\r\n-    int i;\r\n-    int spos;\r\n-    uint16_t sjis[64];\r\n-    spos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n-    if(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n-    ESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n-    for(i=0;i<spos;i++) {\r\n-        if(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n-        if (dev->_font_direction == 0)\r\n-            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 1)\r\n-            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 2)\r\n-            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-        if (dev->_font_direction == 3)\r\n-            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n-    }\r\n-    if (dev->_font_direction == 0) return x;\r\n-    if (dev->_font_direction == 2) return x;\r\n-    if (dev->_font_direction == 1) return y;\r\n-    if (dev->_font_direction == 3) return y;\r\n-    return 0;\r\n-}\r\n-#endif\r\n-\r\n-// Set font direction\r\n-// dir:Direction\r\n-void lcdSetFontDirection(TFT_t *dev, uint16_t dir) {\r\n-    dev->_font_direction = dir;\r\n-}\r\n-\r\n-// Set font filling\r\n-// color:fill color\r\n-void lcdSetFontFill(TFT_t *dev, uint16_t color) {\r\n-    dev->_font_fill = true;\r\n-    dev->_font_fill_color = color;\r\n-}\r\n-\r\n-// UnSet font filling\r\n-void lcdUnsetFontFill(TFT_t *dev) {\r\n-    dev->_font_fill = false;\r\n-}\r\n-\r\n-// Set font underline\r\n-// color:frame color\r\n-void lcdSetFontUnderLine(TFT_t *dev, uint16_t color) {\r\n-    dev->_font_underline = true;\r\n-    dev->_font_underline_color = color;\r\n-}\r\n-\r\n-// UnSet font underline\r\n-void lcdUnsetFontUnderLine(TFT_t *dev) {\r\n-    dev->_font_underline = false;\r\n-}\r\n-\r\n-// Backlight ON\r\n-void lcdBacklightOn(TFT_t *dev) {\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 1);  // Set backlight pin high\r\n-        ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n-    }\r\n-}\r\n-\r\n-// Backlight OFF\r\n-void lcdBacklightOff(TFT_t *dev) {\r\n-    if (dev->_bl >= 0) {\r\n-        gpio_set_level(dev->_bl, 0);  // Set backlight pin low\r\n-        ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n-    }\r\n-}\r\n-\r\n-\r\n-// Display Inversion Off\r\n-void lcdInversionOff(TFT_t *dev) {\r\n-    ESP_LOGI(TAG, \"Disabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x20);  // INVOFF: Display Inversion Off\r\n-}\r\n-\r\n-// Display Inversion On\r\n-void lcdInversionOn(TFT_t *dev) {\r\n-    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n-    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n-}\r\n"
                },
                {
                    "date": 1731818364696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n     dev->_SPIHandle = handle;\r\n \r\n     // Initialize Backlight pin AFTER SPI initialization\r\n     ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n-    if (GPIO_BL = 1) {\r\n+    if (GPIO_BL >= 0) {\r\n         gpio_reset_pin(GPIO_BL);\r\n         gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n         gpio_set_level(GPIO_BL, 0);  // Set GPIO_BL high to turn on the backlight\r\n         ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n"
                }
            ],
            "date": 1731814870967,
            "name": "Commit-0",
            "content": "#include <string.h>\r\n#include <inttypes.h>\r\n#include <math.h>\r\n\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n\r\n#include <driver/spi_master.h>\r\n#include <driver/gpio.h>\r\n#include \"esp_log.h\"\r\n\r\n#include \"st7796s.h\"  // Updated to the correct header file\r\n\r\n#define TAG \"ST7796S\"\r\n#define _DEBUG_ 0\r\n\r\n#if CONFIG_SPI2_HOST\r\n#define HOST_ID SPI2_HOST\r\n#elif CONFIG_SPI3_HOST\r\n#define HOST_ID SPI3_HOST\r\n#endif\r\n\r\nstatic const int SPI_Command_Mode = 0;\r\nstatic const int SPI_Data_Mode = 1;\r\nstatic const int SPI_Frequency = SPI_MASTER_FREQ_40M;\r\n\r\nvoid spi_master_init(TFT_t *dev, int16_t GPIO_MOSI, int16_t GPIO_SCLK, int16_t GPIO_CS,\r\n                     int16_t GPIO_DC, int16_t GPIO_RESET, int16_t GPIO_BL) {\r\n    esp_err_t ret;\r\n\r\n    ESP_LOGI(TAG, \"GPIO_CS=%d\", GPIO_CS);\r\n    if (GPIO_CS >= 0) {\r\n        gpio_reset_pin(GPIO_CS);\r\n        gpio_set_direction(GPIO_CS, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_CS, 1);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_DC=%d\", GPIO_DC);\r\n    gpio_reset_pin(GPIO_DC);\r\n    gpio_set_direction(GPIO_DC, GPIO_MODE_OUTPUT);\r\n    gpio_set_level(GPIO_DC, 0);\r\n\r\n    ESP_LOGI(TAG, \"GPIO_RESET=%d\", GPIO_RESET);\r\n    if (GPIO_RESET >= 0) {\r\n        gpio_reset_pin(GPIO_RESET);\r\n        gpio_set_direction(GPIO_RESET, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_RESET, 1);  // Ensure the reset pin starts high\r\n        delayMS(100);\r\n        gpio_set_level(GPIO_RESET, 0);  // Pulse reset pin\r\n        delayMS(100);\r\n        gpio_set_level(GPIO_RESET, 1);  // Set back to high\r\n        delayMS(100);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_BL=%d\", GPIO_BL);\r\n    if (GPIO_BL >= 0) {\r\n        gpio_reset_pin(GPIO_BL);\r\n        gpio_set_direction(GPIO_BL, GPIO_MODE_OUTPUT);\r\n        gpio_set_level(GPIO_BL, 1);  // Set GPIO_BL high to turn on the backlight\r\n        ESP_LOGI(TAG, \"Backlight enabled on GPIO_BL=%d\", GPIO_BL);\r\n    }\r\n\r\n    ESP_LOGI(TAG, \"GPIO_MOSI=%d\", GPIO_MOSI);\r\n    ESP_LOGI(TAG, \"GPIO_SCLK=%d\", GPIO_SCLK);\r\n    spi_bus_config_t buscfg = {\r\n        .mosi_io_num = GPIO_MOSI,\r\n        .miso_io_num = -1,\r\n        .sclk_io_num = GPIO_SCLK,\r\n        .quadwp_io_num = -1,\r\n        .quadhd_io_num = -1,\r\n        .max_transfer_sz = 6 * 1024,\r\n        .flags = SPICOMMON_BUSFLAG_MASTER,\r\n    };\r\n\r\n    ret = spi_bus_initialize(HOST_ID, &buscfg, SPI_DMA_CH_AUTO);\r\n    ESP_LOGI(TAG, \"spi_bus_initialize=%d\", ret);\r\n    assert(ret == ESP_OK);\r\n\r\n    spi_device_interface_config_t devcfg;\r\n    memset(&devcfg, 0, sizeof(devcfg));\r\n    devcfg.clock_speed_hz = SPI_Frequency;\r\n    devcfg.queue_size = 7;\r\n    devcfg.mode = 0;  // Changed from 2 to 0\r\n    devcfg.flags = SPI_DEVICE_NO_DUMMY;\r\n\r\n    if (GPIO_CS >= 0) {\r\n        devcfg.spics_io_num = GPIO_CS;\r\n    } else {\r\n        devcfg.spics_io_num = -1;\r\n    }\r\n\r\n    spi_device_handle_t handle;\r\n    ret = spi_bus_add_device(HOST_ID, &devcfg, &handle);\r\n    ESP_LOGI(TAG, \"spi_bus_add_device=%d\", ret);\r\n    assert(ret == ESP_OK);\r\n\r\n    dev->_dc = GPIO_DC;\r\n    dev->_bl = GPIO_BL;\r\n    dev->_SPIHandle = handle;\r\n}\r\n\r\nbool spi_master_write_byte(spi_device_handle_t SPIHandle, const uint8_t *Data, size_t DataLength) {\r\n    spi_transaction_t SPITransaction;\r\n    esp_err_t ret;\r\n\r\n    if (DataLength > 0) {\r\n        memset(&SPITransaction, 0, sizeof(spi_transaction_t));\r\n        SPITransaction.length = DataLength * 8;\r\n        SPITransaction.tx_buffer = Data;\r\n        ret = spi_device_polling_transmit(SPIHandle, &SPITransaction);\r\n        assert(ret == ESP_OK);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nbool spi_master_write_command(TFT_t *dev, uint8_t cmd) {\r\n    uint8_t Byte = cmd;\r\n    gpio_set_level(dev->_dc, SPI_Command_Mode);\r\n    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n}\r\n\r\nbool spi_master_write_data_byte(TFT_t *dev, uint8_t data) {\r\n    uint8_t Byte = data;\r\n    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n    return spi_master_write_byte(dev->_SPIHandle, &Byte, 1);\r\n}\r\n\r\nbool spi_master_write_data_word(TFT_t *dev, uint16_t data) {\r\n    uint8_t Byte[2];\r\n    Byte[0] = (data >> 8) & 0xFF;\r\n    Byte[1] = data & 0xFF;\r\n    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n    return spi_master_write_byte(dev->_SPIHandle, Byte, 2);\r\n}\r\n\r\nbool spi_master_write_addr(TFT_t *dev, uint16_t addr1, uint16_t addr2) {\r\n    uint8_t Byte[4];\r\n    Byte[0] = (addr1 >> 8) & 0xFF;\r\n    Byte[1] = addr1 & 0xFF;\r\n    Byte[2] = (addr2 >> 8) & 0xFF;\r\n    Byte[3] = addr2 & 0xFF;\r\n    gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n    return spi_master_write_byte(dev->_SPIHandle, Byte, 4);\r\n}\r\n\r\nbool spi_master_write_color(TFT_t *dev, uint16_t color, uint32_t size) {\r\n    uint8_t Byte[1024];\r\n    uint32_t len = size * 2;\r\n    uint32_t max_chunk = sizeof(Byte);\r\n\r\n    while (len > 0) {\r\n        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n        uint32_t color_count = chunk_size / 2;\r\n        for (uint32_t i = 0; i < color_count; i++) {\r\n            Byte[i * 2] = (color >> 8) & 0xFF;\r\n            Byte[i * 2 + 1] = color & 0xFF;\r\n        }\r\n        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n        len -= chunk_size;\r\n    }\r\n    return true;\r\n}\r\n\r\n// Add 202001\r\nbool spi_master_write_colors(TFT_t *dev, uint16_t *colors, uint16_t size) {\r\n    uint8_t Byte[1024];\r\n    uint32_t index = 0;\r\n    uint32_t len = size * 2;\r\n    uint32_t max_chunk = sizeof(Byte);\r\n\r\n    while (len > 0) {\r\n        uint32_t chunk_size = (len > max_chunk) ? max_chunk : len;\r\n        uint32_t color_count = chunk_size / 2;\r\n        for (uint32_t i = 0; i < color_count; i++) {\r\n            Byte[i * 2] = (colors[index] >> 8) & 0xFF;\r\n            Byte[i * 2 + 1] = colors[index] & 0xFF;\r\n            index++;\r\n        }\r\n        gpio_set_level(dev->_dc, SPI_Data_Mode);\r\n        spi_master_write_byte(dev->_SPIHandle, Byte, chunk_size);\r\n        len -= chunk_size;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid delayMS(int ms) {\r\n    vTaskDelay(pdMS_TO_TICKS(ms));\r\n}\r\n\r\nvoid lcdInit(TFT_t *dev, int width, int height, int offsetx, int offsety) {\r\n    dev->_width = width;\r\n    dev->_height = height;\r\n    dev->_offsetx = offsetx;\r\n    dev->_offsety = offsety;\r\n    dev->_font_direction = DIRECTION0;\r\n    dev->_font_fill = false;\r\n    dev->_font_underline = false;\r\n\r\n    ESP_LOGI(TAG, \"Initializing ST7796S LCD\");\r\n\r\n    // Hardware reset\r\n    if (dev->_reset >= 0) {\r\n        gpio_set_level(dev->_reset, 0); // Set RESX low\r\n        delayMS(20);                   // Minimum 10ms\r\n        gpio_set_level(dev->_reset, 1); // Set RESX high\r\n        delayMS(120);                  // Wait for reset complete\r\n    }\r\n\r\n    // Software reset\r\n    ESP_LOGI(TAG, \"Sending Software Reset\");\r\n    spi_master_write_command(dev, 0x01);  // SWRESET: Software Reset\r\n    delayMS(150);                        // Wait for reset process\r\n\r\n    // Exit Sleep mode\r\n    ESP_LOGI(TAG, \"Exiting Sleep Mode\");\r\n    spi_master_write_command(dev, 0x11);  // SLPOUT: Sleep Out\r\n    delayMS(120);\r\n\r\n    // Memory Data Access Control\r\n    ESP_LOGI(TAG, \"Setting Memory Data Access Control\");\r\n    spi_master_write_command(dev, 0x36);  // MADCTL: Memory Data Access Control\r\n    spi_master_write_data_byte(dev, 0x48); // Adjust orientation (0x48 for default landscape)\r\n    delayMS(10);\r\n\r\n    // Interface Pixel Format (16-bit/pixel)\r\n    ESP_LOGI(TAG, \"Setting Interface Pixel Format\");\r\n    spi_master_write_command(dev, 0x3A);  // COLMOD: Interface Pixel Format\r\n    spi_master_write_data_byte(dev, 0x55); // 16-bit/pixel (RGB 5-6-5)\r\n    delayMS(10);\r\n\r\n    // Porch Setting\r\n    ESP_LOGI(TAG, \"Setting Porch Control\");\r\n    spi_master_write_command(dev, 0xB2);  // PORCTRL: Porch Control\r\n    spi_master_write_data_byte(dev, 0x0C); // Front Porch\r\n    spi_master_write_data_byte(dev, 0x0C); // Back Porch\r\n    spi_master_write_data_byte(dev, 0x00); // Vertical Porch\r\n    spi_master_write_data_byte(dev, 0x33);\r\n    spi_master_write_data_byte(dev, 0x33);\r\n    delayMS(10);\r\n\r\n    // VCOM Setting\r\n    ESP_LOGI(TAG, \"Setting VCOM\");\r\n    spi_master_write_command(dev, 0xBB);  // VCOMS: VCOM Setting\r\n    spi_master_write_data_byte(dev, 0x35); // VCOM voltage level (1.175V)\r\n    delayMS(10);\r\n\r\n    // LCM Control\r\n    ESP_LOGI(TAG, \"Setting LCM Control\");\r\n    spi_master_write_command(dev, 0xC0);  // LCMCTRL: LCM Control\r\n    spi_master_write_data_byte(dev, 0x2C); // Default\r\n    delayMS(10);\r\n\r\n    // VDV and VRH Command Enable\r\n    ESP_LOGI(TAG, \"Enabling VDV and VRH Commands\");\r\n    spi_master_write_command(dev, 0xC2);  // VDVVRHEN: Enable VDV and VRH\r\n    spi_master_write_data_byte(dev, 0x01); // Enable\r\n    delayMS(10);\r\n\r\n    // VRH Set\r\n    ESP_LOGI(TAG, \"Setting VRH\");\r\n    spi_master_write_command(dev, 0xC3);  // VRHS: VRH Set\r\n    spi_master_write_data_byte(dev, 0x12); // Default\r\n    delayMS(10);\r\n\r\n    // VDV Set\r\n    ESP_LOGI(TAG, \"Setting VDV\");\r\n    spi_master_write_command(dev, 0xC4);  // VDVS: VDV Set\r\n    spi_master_write_data_byte(dev, 0x20); // Default\r\n    delayMS(10);\r\n\r\n    // Frame Rate Control\r\n    ESP_LOGI(TAG, \"Setting Frame Rate Control\");\r\n    spi_master_write_command(dev, 0xC6);  // FRCTRL2: Frame Rate Control\r\n    spi_master_write_data_byte(dev, 0x0F); // Default frame rate: 60Hz\r\n    delayMS(10);\r\n\r\n    // Power Control 1\r\n    ESP_LOGI(TAG, \"Setting Power Control 1\");\r\n    spi_master_write_command(dev, 0xD0);  // PWCTRL1: Power Control 1\r\n    spi_master_write_data_byte(dev, 0xA4); // Default\r\n    spi_master_write_data_byte(dev, 0xA1); // Default\r\n    delayMS(10);\r\n\r\n    // Positive Voltage Gamma Control\r\n    ESP_LOGI(TAG, \"Setting Positive Voltage Gamma Control\");\r\n    spi_master_write_command(dev, 0xE0);  // PGAMCTRL: Positive Gamma Control\r\n    uint8_t positive_gamma[] = {0xD0, 0x08, 0x11, 0x08, 0x0C, 0x15, 0x39, 0x33, 0x50, 0x36, 0x13, 0x14, 0x29, 0x2D};\r\n    for (int i = 0; i < sizeof(positive_gamma); i++) {\r\n        spi_master_write_data_byte(dev, positive_gamma[i]);\r\n    }\r\n    delayMS(10);\r\n\r\n    // Negative Voltage Gamma Control\r\n    ESP_LOGI(TAG, \"Setting Negative Voltage Gamma Control\");\r\n    spi_master_write_command(dev, 0xE1);  // NVGAMCTRL: Negative Gamma Control\r\n    uint8_t negative_gamma[] = {0xD0, 0x08, 0x10, 0x08, 0x06, 0x06, 0x39, 0x44, 0x51, 0x0B, 0x16, 0x14, 0x2F, 0x31};\r\n    for (int i = 0; i < sizeof(negative_gamma); i++) {\r\n        spi_master_write_data_byte(dev, negative_gamma[i]);\r\n    }\r\n    delayMS(10);\r\n\r\n    // Enable Display Inversion\r\n    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n    delayMS(10);\r\n\r\n    // Normal Display Mode On\r\n    ESP_LOGI(TAG, \"Setting Normal Display Mode\");\r\n    spi_master_write_command(dev, 0x13);  // NORON: Normal Display Mode On\r\n    delayMS(10);\r\n\r\n    // Turn on Display\r\n    ESP_LOGI(TAG, \"Turning Display On\");\r\n    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n    delayMS(120);                          // Wait for display to turn on\r\n\r\n    // Backlight control\r\n    if (dev->_bl >= 0) {\r\n        gpio_set_level(dev->_bl, 1);\r\n        ESP_LOGI(TAG, \"Backlight turned on via lcdInit\");\r\n    }\r\n}\r\n\r\n// Draw pixel\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// color:color\r\nvoid lcdDrawPixel(TFT_t *dev, uint16_t x, uint16_t y, uint16_t color) {\r\n    if (x >= dev->_width)\r\n        return;\r\n    if (y >= dev->_height)\r\n        return;\r\n\r\n    uint16_t _x = x + dev->_offsetx;\r\n    uint16_t _y = y + dev->_offsety;\r\n\r\n    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n    spi_master_write_addr(dev, _x, _x);\r\n    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n    spi_master_write_addr(dev, _y, _y);\r\n    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n    spi_master_write_data_word(dev, color);\r\n}\r\n\r\n// Draw multi pixel\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// size:Number of colors\r\n// colors:colors\r\nvoid lcdDrawMultiPixels(TFT_t *dev, uint16_t x, uint16_t y, uint16_t size, uint16_t *colors) {\r\n    if (x + size > dev->_width)\r\n        return;\r\n    if (y >= dev->_height)\r\n        return;\r\n\r\n    uint16_t _x1 = x + dev->_offsetx;\r\n    uint16_t _x2 = _x1 + (size - 1);\r\n    uint16_t _y1 = y + dev->_offsety;\r\n    uint16_t _y2 = _y1;\r\n\r\n    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n    spi_master_write_addr(dev, _x1, _x2);\r\n    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n    spi_master_write_addr(dev, _y1, _y2);\r\n    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n    spi_master_write_colors(dev, colors, size);\r\n}\r\n\r\n// Draw rectangle of filling\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End X coordinate\r\n// y2:End Y coordinate\r\n// color:color\r\nvoid lcdDrawFillRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n    if (x1 >= dev->_width)\r\n        return;\r\n    if (x2 >= dev->_width)\r\n        x2 = dev->_width - 1;\r\n    if (y1 >= dev->_height)\r\n        return;\r\n    if (y2 >= dev->_height)\r\n        y2 = dev->_height - 1;\r\n\r\n    uint16_t _x1 = x1 + dev->_offsetx;\r\n    uint16_t _x2 = x2 + dev->_offsetx;\r\n    uint16_t _y1 = y1 + dev->_offsety;\r\n    uint16_t _y2 = y2 + dev->_offsety;\r\n\r\n    spi_master_write_command(dev, 0x2A);  // CASET: Column Address Set\r\n    spi_master_write_addr(dev, _x1, _x2);\r\n    spi_master_write_command(dev, 0x2B);  // RASET: Row Address Set\r\n    spi_master_write_addr(dev, _y1, _y2);\r\n    spi_master_write_command(dev, 0x2C);  // RAMWR: Memory Write\r\n\r\n    uint32_t size = (_x2 - _x1 + 1) * (_y2 - _y1 + 1);\r\n    spi_master_write_color(dev, color, size);\r\n}\r\n\r\n// Display OFF\r\nvoid lcdDisplayOff(TFT_t *dev) {\r\n    spi_master_write_command(dev, 0x28);  // DISPOFF: Display Off\r\n}\r\n\r\n// Display ON\r\nvoid lcdDisplayOn(TFT_t *dev) {\r\n    spi_master_write_command(dev, 0x29);  // DISPON: Display On\r\n}\r\n\r\n// Fill screen\r\n// color:color\r\nvoid lcdFillScreen(TFT_t *dev, uint16_t color) {\r\n    lcdDrawFillRect(dev, 0, 0, dev->_width - 1, dev->_height - 1, color);\r\n}\r\n\r\n// Draw line\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// color:color\r\nvoid lcdDrawLine(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n    int dx, dy, sx, sy, err, e2;\r\n\r\n    dx = abs(x2 - x1);\r\n    dy = -abs(y2 - y1);\r\n\r\n    sx = (x1 < x2) ? 1 : -1;\r\n    sy = (y1 < y2) ? 1 : -1;\r\n\r\n    err = dx + dy;\r\n\r\n    while (1) {\r\n        lcdDrawPixel(dev, x1, y1, color);\r\n        if (x1 == x2 && y1 == y2)\r\n            break;\r\n        e2 = 2 * err;\r\n        if (e2 >= dy) {\r\n            err += dy;\r\n            x1 += sx;\r\n        }\r\n        if (e2 <= dx) {\r\n            err += dx;\r\n            y1 += sy;\r\n        }\r\n    }\r\n}\r\n\r\n// Draw rectangle\r\n// x1:Start X coordinate\r\n// y1:Start Y coordinate\r\n// x2:End   X coordinate\r\n// y2:End   Y coordinate\r\n// color:color\r\nvoid lcdDrawRect(TFT_t *dev, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color) {\r\n    lcdDrawLine(dev, x1, y1, x2, y1, color);\r\n    lcdDrawLine(dev, x2, y1, x2, y2, color);\r\n    lcdDrawLine(dev, x2, y2, x1, y2, color);\r\n    lcdDrawLine(dev, x1, y2, x1, y1, color);\r\n}\r\n\r\n// Draw rectangle with angle\r\n// xc:Center X coordinate\r\n// yc:Center Y coordinate\r\n// w:Width of rectangle\r\n// h:Height of rectangle\r\n// angle:Angle of rectangle\r\n// color:color\r\n\r\n// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n// x1 = x * cos(angle) - y * sin(angle)\r\n// y1 = x * sin(angle) + y * cos(angle)\r\nvoid lcdDrawRectAngle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n    double xd, yd, rd;\r\n    int x1, y1;\r\n    int x2, y2;\r\n    int x3, y3;\r\n    int x4, y4;\r\n    rd = -angle * M_PI / 180.0;\r\n    xd = 0.0 - w / 2;\r\n    yd = h / 2;\r\n    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    yd = 0.0 - yd;\r\n    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    xd = w / 2;\r\n    yd = h / 2;\r\n    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    yd = 0.0 - yd;\r\n    x4 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y4 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n    lcdDrawLine(dev, x2, y2, x4, y4, color);\r\n    lcdDrawLine(dev, x3, y3, x4, y4, color);\r\n}\r\n\r\n// Draw triangle\r\n// xc:Center X coordinate\r\n// yc:Center Y coordinate\r\n// w:Width of triangle\r\n// h:Height of triangle\r\n// angle:Angle of triangle\r\n// color:color\r\n\r\n// When the origin is (0, 0), the point (x1, y1) after rotating the point (x, y) by the angle is obtained by the following calculation.\r\n// x1 = x * cos(angle) - y * sin(angle)\r\n// y1 = x * sin(angle) + y * cos(angle)\r\nvoid lcdDrawTriangle(TFT_t *dev, uint16_t xc, uint16_t yc, uint16_t w, uint16_t h, uint16_t angle, uint16_t color) {\r\n    double xd, yd, rd;\r\n    int x1, y1;\r\n    int x2, y2;\r\n    int x3, y3;\r\n    rd = -angle * M_PI / 180.0;\r\n    xd = 0.0;\r\n    yd = h / 2;\r\n    x1 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y1 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    xd = w / 2;\r\n    yd = 0.0 - yd;\r\n    x2 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y2 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    xd = 0.0 - w / 2;\r\n    x3 = (int)(xd * cos(rd) - yd * sin(rd) + xc);\r\n    y3 = (int)(xd * sin(rd) + yd * cos(rd) + yc);\r\n\r\n    lcdDrawLine(dev, x1, y1, x2, y2, color);\r\n    lcdDrawLine(dev, x1, y1, x3, y3, color);\r\n    lcdDrawLine(dev, x2, y2, x3, y3, color);\r\n}\r\n\r\n#if 0\r\n// Draw UTF8 character\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// utf8:UTF8 code\r\n// color:color\r\nint lcdDrawUTF8Char(TFT_t * dev, FontxFile *fx, uint16_t x,uint16_t y,uint8_t *utf8,uint16_t color) {\r\n    uint16_t sjis[1];\r\n\r\n    sjis[0] = UTF2SJIS(utf8);\r\n    if(_DEBUG_)printf(\"sjis=%04x\\n\",sjis[0]);\r\n    return lcdDrawSJISChar(dev, fx, x, y, sjis[0], color);\r\n}\r\n\r\n// Draw UTF8 string\r\n// x:X coordinate\r\n// y:Y coordinate\r\n// utfs:UTF8 string\r\n// color:color\r\nint lcdDrawUTF8String(TFT_t * dev, FontxFile *fx, uint16_t x, uint16_t y, unsigned char *utfs, uint16_t color) {\r\n\r\n    int i;\r\n    int spos;\r\n    uint16_t sjis[64];\r\n    spos = String2SJIS(utfs, strlen((char *)utfs), sjis, 64);\r\n    if(_DEBUG_)printf(\"spos=%d\\n\",spos);\r\n    ESP_LOGD(TAG, \"Drawing UTF8 string with %d characters\", spos);\r\n    for(i=0;i<spos;i++) {\r\n        if(_DEBUG_)printf(\"sjis[%d]=%x y=%d\\n\",i,sjis[i],y);\r\n        if (dev->_font_direction == 0)\r\n            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n        if (dev->_font_direction == 1)\r\n            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n        if (dev->_font_direction == 2)\r\n            x = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n        if (dev->_font_direction == 3)\r\n            y = lcdDrawSJISChar(dev, fx, x, y, sjis[i], color);\r\n    }\r\n    if (dev->_font_direction == 0) return x;\r\n    if (dev->_font_direction == 2) return x;\r\n    if (dev->_font_direction == 1) return y;\r\n    if (dev->_font_direction == 3) return y;\r\n    return 0;\r\n}\r\n#endif\r\n\r\n// Set font direction\r\n// dir:Direction\r\nvoid lcdSetFontDirection(TFT_t *dev, uint16_t dir) {\r\n    dev->_font_direction = dir;\r\n}\r\n\r\n// Set font filling\r\n// color:fill color\r\nvoid lcdSetFontFill(TFT_t *dev, uint16_t color) {\r\n    dev->_font_fill = true;\r\n    dev->_font_fill_color = color;\r\n}\r\n\r\n// UnSet font filling\r\nvoid lcdUnsetFontFill(TFT_t *dev) {\r\n    dev->_font_fill = false;\r\n}\r\n\r\n// Set font underline\r\n// color:frame color\r\nvoid lcdSetFontUnderLine(TFT_t *dev, uint16_t color) {\r\n    dev->_font_underline = true;\r\n    dev->_font_underline_color = color;\r\n}\r\n\r\n// UnSet font underline\r\nvoid lcdUnsetFontUnderLine(TFT_t *dev) {\r\n    dev->_font_underline = false;\r\n}\r\n\r\n// Backlight OFF\r\nvoid lcdBacklightOff(TFT_t *dev) {\r\n    if (dev->_bl >= 0) {\r\n        gpio_set_level(dev->_bl, 0);\r\n        ESP_LOGI(TAG, \"Backlight turned off via lcdBacklightOff\");\r\n    }\r\n}\r\n\r\n// Backlight ON\r\nvoid lcdBacklightOn(TFT_t *dev) {\r\n    if (dev->_bl >= 0) {\r\n        gpio_set_level(dev->_bl, 1);\r\n        ESP_LOGI(TAG, \"Backlight turned on via lcdBacklightOn\");\r\n    }\r\n}\r\n\r\n// Display Inversion Off\r\nvoid lcdInversionOff(TFT_t *dev) {\r\n    ESP_LOGI(TAG, \"Disabling Display Inversion\");\r\n    spi_master_write_command(dev, 0x20);  // INVOFF: Display Inversion Off\r\n}\r\n\r\n// Display Inversion On\r\nvoid lcdInversionOn(TFT_t *dev) {\r\n    ESP_LOGI(TAG, \"Enabling Display Inversion\");\r\n    spi_master_write_command(dev, 0x21);  // INVON: Display Inversion On\r\n}\r\n"
        }
    ]
}