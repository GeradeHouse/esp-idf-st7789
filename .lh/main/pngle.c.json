{
    "sourceFile": "main/pngle.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1731797770714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1731797770714,
            "name": "Commit-0",
            "content": "/*-\r\n * MIT License\r\n *\r\n * Copyright (c) 2019 kikuchan\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdint.h>\r\n#include <math.h>\r\n\r\n#include \"esp_log.h\"\r\n//#include \"miniz.h\"\r\n// #include \"rom/miniz.h\"\r\n#include \"pngle.h\"\r\n\r\n#define PNGLE_ERROR(s) (pngle->error = (s), pngle->state = PNGLE_STATE_ERROR, -1)\r\n#define PNGLE_CALLOC(a, b, name) (debug_printf(\"[pngle] Allocating %zu bytes for %s\\n\", (size_t)(a) * (size_t)(b), (name)), calloc((size_t)(a), (size_t)(b)))\r\n\r\n#define PNGLE_UNUSED(x) (void)(x)\r\n\r\n// magic\r\nstatic const uint8_t png_sig[] = { 137, 80, 78, 71, 13, 10, 26, 10 };\r\nstatic uint32_t interlace_off_x[8] = { 0,  0, 4, 0, 2, 0, 1, 0 };\r\nstatic uint32_t interlace_off_y[8] = { 0,  0, 0, 4, 0, 2, 0, 1 };\r\nstatic uint32_t interlace_div_x[8] = { 1,  8, 8, 4, 4, 2, 2, 1 };\r\nstatic uint32_t interlace_div_y[8] = { 1,  8, 8, 8, 4, 4, 2, 2 };\r\n\r\n\r\nstatic inline uint8_t  read_uint8(const uint8_t *p)\r\n{\r\n\treturn *p;\r\n}\r\n\r\nstatic inline uint32_t read_uint32(const uint8_t *p)\r\n{\r\n\treturn (p[0] << 24)\r\n\t     | (p[1] << 16)\r\n\t     | (p[2] <<  8)\r\n\t     | (p[3] <<  0)\r\n\t;\r\n}\r\n\r\nstatic inline uint32_t U32_CLAMP_ADD(uint32_t a, uint32_t b, uint32_t top)\r\n{\r\n\tuint32_t v = a + b;\r\n\tif (v < a) return top; // uint32 overflow\r\n\tif (v > top) return top; // clamp\r\n\treturn v;\r\n}\r\n\r\n\r\nvoid pngle_reset(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return ;\r\n\r\n\tpngle->state = PNGLE_STATE_INITIAL;\r\n\tpngle->error = \"No error\";\r\n\r\n\tif (pngle->scanline_ringbuf) free(pngle->scanline_ringbuf);\r\n\tif (pngle->palette) free(pngle->palette);\r\n\tif (pngle->trans_palette) free(pngle->trans_palette);\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n\tif (pngle->gamma_table) free(pngle->gamma_table);\r\n#endif\r\n\r\n\tpngle->scanline_ringbuf = NULL;\r\n\tpngle->palette = NULL;\r\n\tpngle->trans_palette = NULL;\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n\tpngle->gamma_table = NULL;\r\n#endif\r\n\r\n\tpngle->channels = 0; // indicates IHDR hasn't been processed yet\r\n\tpngle->next_out = NULL; // indicates IDAT hasn't been processed yet\r\n\r\n\t// clear them just in case...\r\n\tmemset(&pngle->hdr, 0, sizeof(pngle->hdr));\r\n\tpngle->n_palettes = 0;\r\n\tpngle->n_trans_palettes = 0;\r\n\r\n\ttinfl_init(&pngle->inflator);\r\n}\r\n\r\npngle_t *pngle_new(uint16_t width, uint16_t height)\r\n{\r\n\tpngle_t *pngle = (pngle_t *)PNGLE_CALLOC(1, sizeof(pngle_t), \"pngle_t\");\r\n\tif (!pngle) return NULL;\r\n\r\n\tpngle_reset(pngle);\r\n\r\n\tpngle->pixels = NULL;\r\n\r\n    //Alocate pixel memory. Each line is an array of IMAGE_W 16-bit pixels; the `*pixels` array itself contains pointers to these lines.\r\n\tESP_LOGD(__FUNCTION__, \"height=%d sizeof(pixel_png *)=%d\", height, sizeof(pixel_png *));\r\n    pngle->pixels = calloc(height, sizeof(pixel_png *));\r\n    if (pngle->pixels == NULL) {\r\n        ESP_LOGE(__FUNCTION__, \"Error allocating memory for lines\");\r\n        //ret = ESP_ERR_NO_MEM;\r\n        goto err;\r\n    }\r\n\tESP_LOGD(__FUNCTION__, \"width=%d sizeof(pixel_png)=%d\", width, sizeof(pixel_png));\r\n    for (int i = 0; i < height; i++) {\r\n        (pngle->pixels)[i] = malloc(width * sizeof(pixel_png));\r\n        if ((pngle->pixels)[i] == NULL) {\r\n            ESP_LOGE(__FUNCTION__, \"Error allocating memory for line %d\", i);\r\n            //ret = ESP_ERR_NO_MEM;\r\n            goto err;\r\n        }\r\n    }\r\n\r\n\tpngle->screenWidth = width;\r\n\tpngle->screenHeight = height;\r\n\treturn pngle;\r\n\r\n    err:\r\n    //Something went wrong! Exit cleanly, de-allocating everything we allocated.\r\n    if (pngle->pixels != NULL) {\r\n        for (int i = 0; i < height; i++) {\r\n            free((pngle->pixels)[i]);\r\n        }\r\n        free(pngle->pixels);\r\n    }\r\n\treturn NULL;\r\n}\r\n\r\nvoid pngle_destroy(pngle_t *pngle, uint16_t width, uint16_t height)\r\n{\r\n\tif (pngle) {\r\n    \tif (pngle->pixels != NULL) {\r\n       \t\tfor (int i = 0; i < height; i++) {\r\n            \tfree((pngle->pixels)[i]);\r\n       \t\t}\r\n        \tfree(pngle->pixels);\r\n    \t}\r\n\t\tpngle_reset(pngle);\r\n\t\tfree(pngle);\r\n\t}\r\n}\r\n\r\nconst char *pngle_error(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return \"Uninitialized\";\r\n\treturn pngle->error;\r\n}\r\n\r\nuint32_t pngle_get_width(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return 0;\r\n\treturn pngle->hdr.width;\r\n}\r\n\r\nuint32_t pngle_get_height(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return 0;\r\n\treturn pngle->hdr.height;\r\n}\r\n\r\npngle_ihdr_t *pngle_get_ihdr(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return NULL;\r\n\tif (pngle->channels == 0) return NULL;\r\n\treturn &pngle->hdr;\r\n}\r\n\r\n\r\nstatic int is_trans_color(pngle_t *pngle, uint16_t *value, size_t n)\r\n{\r\n\tif (pngle->n_trans_palettes != 1) return 0; // false (none or indexed)\r\n\r\n\tfor (size_t i = 0; i < n; i++) {\r\n\t\tif (value[i] != (pngle->trans_palette[i * 2 + 0] * 0x100 + pngle->trans_palette[i * 2 + 1])) return 0; // false\r\n\t}\r\n\treturn 1; // true\r\n}\r\n\r\nstatic inline void scanline_ringbuf_push(pngle_t *pngle, uint8_t value)\r\n{\r\n\tpngle->scanline_ringbuf[pngle->scanline_ringbuf_cidx] = value;\r\n\tpngle->scanline_ringbuf_cidx = (pngle->scanline_ringbuf_cidx + 1) % pngle->scanline_ringbuf_size;\r\n}\r\n\r\nstatic inline uint16_t get_value(pngle_t *pngle, size_t *ridx, int *bitcount, int depth)\r\n{\r\n\tuint16_t v;\r\n\r\n\tswitch (depth) {\r\n\tcase 1:\r\n\tcase 2:\r\n\tcase 4:\r\n\t\tif (*bitcount >= 8) {\r\n\t\t\t*bitcount = 0;\r\n\t\t\t*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;\r\n\t\t}\r\n\t\t*bitcount += depth;\r\n\t\tuint8_t mask = ((1UL << depth) - 1);\r\n\t\tuint8_t shift = (8 - *bitcount);\r\n\t\treturn (pngle->scanline_ringbuf[*ridx] >> shift) & mask;\r\n\r\n\tcase 8:\r\n\t\tv = pngle->scanline_ringbuf[*ridx];\r\n\t\t*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;\r\n\t\treturn v;\r\n\r\n\tcase 16:\r\n\t\tv = pngle->scanline_ringbuf[*ridx];\r\n\t\t*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;\r\n\r\n\t\tv = v * 0x100 + pngle->scanline_ringbuf[*ridx];\r\n\t\t*ridx = (*ridx + 1) % pngle->scanline_ringbuf_size;\r\n\t\treturn v;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic int pngle_draw_pixels(pngle_t *pngle, size_t scanline_ringbuf_xidx)\r\n{\r\n\tuint16_t v[4]; // MAX_CHANNELS\r\n\tint bitcount = 0;\r\n\tuint8_t pixel_depth = (pngle->hdr.color_type & 1) ? 8 : pngle->hdr.depth;\r\n\tuint16_t maxval = (1UL << pixel_depth) - 1;\r\n\r\n\tint n_pixels = pngle->hdr.depth == 16 ? 1 : (8 / pngle->hdr.depth);\r\n\r\n\tfor (; n_pixels-- > 0 && pngle->drawing_x < pngle->hdr.width; pngle->drawing_x = U32_CLAMP_ADD(pngle->drawing_x, interlace_div_x[pngle->interlace_pass], pngle->hdr.width)) {\r\n\t\tfor (uint_fast8_t c = 0; c < pngle->channels; c++) {\r\n\t\t\tv[c] = get_value(pngle, &scanline_ringbuf_xidx, &bitcount, pngle->hdr.depth);\r\n\t\t}\r\n\r\n\t\t// color type: 0000 0111\r\n\t\t//                     ^-- indexed color (palette)\r\n\t\t//                    ^--- Color\r\n\t\t//                   ^---- Alpha channel\r\n\r\n\t\tif (pngle->hdr.color_type & 2) {\r\n\t\t\t// color\r\n\t\t\tif (pngle->hdr.color_type & 1) {\r\n\t\t\t\t// indexed color: type 3\r\n\r\n\t\t\t\t// lookup palette info\r\n\t\t\t\tuint16_t pidx = v[0];\r\n\t\t\t\tif (pidx >= pngle->n_palettes) return PNGLE_ERROR(\"Color index is out of range\");\r\n\r\n\t\t\t\tv[0] = pngle->palette[pidx * 3 + 0];\r\n\t\t\t\tv[1] = pngle->palette[pidx * 3 + 1];\r\n\t\t\t\tv[2] = pngle->palette[pidx * 3 + 2];\r\n\r\n\t\t\t\t// tRNS as an indexed alpha value table (for color type 3)\r\n\t\t\t\tv[3] = pidx < pngle->n_trans_palettes ? pngle->trans_palette[pidx] : maxval;\r\n\t\t\t} else {\r\n\t\t\t\t// true color: 2, and 6\r\n\t\t\t\tv[3] = (pngle->hdr.color_type & 4) ? v[3] : is_trans_color(pngle, v, 3) ? 0 : maxval;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// alpha, tRNS, or opaque\r\n\t\t\tv[3] = (pngle->hdr.color_type & 4) ? v[1] : is_trans_color(pngle, v, 1) ? 0 : maxval;\r\n\r\n\t\t\t// monochrome\r\n\t\t\tv[1] = v[2] = v[0];\r\n\t\t}\r\n\r\n\t\tif (pngle->draw_callback) {\r\n\t\t\tuint8_t rgba[4] = {\r\n\t\t\t\t(v[0] * 255 + maxval / 2) / maxval,\r\n\t\t\t\t(v[1] * 255 + maxval / 2) / maxval,\r\n\t\t\t\t(v[2] * 255 + maxval / 2) / maxval,\r\n\t\t\t\t(v[3] * 255 + maxval / 2) / maxval\r\n\t\t\t};\r\n\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n\t\t\tif (pngle->gamma_table) {\r\n\t\t\t\tfor (int i = 0; i < 3; i++) {\r\n\t\t\t\t\trgba[i] = pngle->gamma_table[v[i]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n#endif\r\n\r\n\t\t\tpngle->draw_callback(pngle, pngle->drawing_x, pngle->drawing_y\r\n\t\t\t\t, MIN(interlace_div_x[pngle->interlace_pass] - interlace_off_x[pngle->interlace_pass], pngle->hdr.width  - pngle->drawing_x)\r\n\t\t\t\t, MIN(interlace_div_y[pngle->interlace_pass] - interlace_off_y[pngle->interlace_pass], pngle->hdr.height - pngle->drawing_y)\r\n\t\t\t\t, rgba\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic inline int paeth(int a, int b, int c)\r\n{\r\n\tint p = a + b - c;\r\n\tint pa = abs(p - a);\r\n\tint pb = abs(p - b);\r\n\tint pc = abs(p - c);\r\n\r\n\tif (pa <= pb && pa <= pc) return a;\r\n\tif (pb <= pc) return b;\r\n\treturn c;\r\n}\r\n\r\nstatic int set_interlace_pass(pngle_t *pngle, uint_fast8_t pass)\r\n{\r\n\tpngle->interlace_pass = pass;\r\n\r\n\tuint_fast8_t bytes_per_pixel = (pngle->channels * pngle->hdr.depth + 7) / 8; // 1 if depth <= 8\r\n\tsize_t scanline_pixels = (pngle->hdr.width - interlace_off_x[pngle->interlace_pass] + interlace_div_x[pngle->interlace_pass] - 1) / interlace_div_x[pngle->interlace_pass];\r\n\tsize_t scanline_stride = (scanline_pixels * pngle->channels * pngle->hdr.depth + 7) / 8;\r\n\r\n\tpngle->scanline_ringbuf_size = scanline_stride + bytes_per_pixel * 2; // 2 rooms for c/x and a\r\n\r\n\tif (pngle->scanline_ringbuf) free(pngle->scanline_ringbuf);\r\n\tif ((pngle->scanline_ringbuf = PNGLE_CALLOC(pngle->scanline_ringbuf_size, 1, \"scanline ringbuf\")) == NULL) return PNGLE_ERROR(\"Insufficient memory\");\r\n\r\n\tpngle->drawing_x = interlace_off_x[pngle->interlace_pass];\r\n\tpngle->drawing_y = interlace_off_y[pngle->interlace_pass];\r\n\tpngle->filter_type = -1;\r\n\r\n\tpngle->scanline_ringbuf_cidx = 0;\r\n\tpngle->scanline_remain_bytes_to_render = -1;\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic int setup_gamma_table(pngle_t *pngle, uint32_t png_gamma)\r\n{\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n\tif (pngle->gamma_table) free(pngle->gamma_table);\r\n\r\n\tif (pngle->display_gamma <= 0) return 0; // disable gamma correction\r\n\tif (png_gamma == 0) return 0;\r\n\r\n\tuint8_t pixel_depth = (pngle->hdr.color_type & 1) ? 8 : pngle->hdr.depth;\r\n\tuint16_t maxval = (1UL << pixel_depth) - 1;\r\n\r\n\tpngle->gamma_table = PNGLE_CALLOC(1, maxval + 1, \"gamma table\");\r\n\tif (!pngle->gamma_table) return PNGLE_ERROR(\"Insufficient memory\");\r\n\r\n\tfor (int i = 0; i < maxval + 1; i++) {\r\n\t\tpngle->gamma_table[i] = (uint8_t)floor(pow(i / (double)maxval, 100000.0 / png_gamma / pngle->display_gamma) * 255.0 + 0.5);\r\n\t}\r\n\tdebug_printf(\"[pngle] gamma value = %d\\n\", png_gamma);\r\n#else\r\n\tPNGLE_UNUSED(pngle);\r\n\tPNGLE_UNUSED(png_gamma);\r\n#endif\r\n\treturn 0;\r\n}\r\n\r\n\r\nstatic int pngle_on_data(pngle_t *pngle, const uint8_t *p, int len)\r\n{\r\n\tconst uint8_t *ep = p + len;\r\n\r\n\tuint_fast8_t bytes_per_pixel = (pngle->channels * pngle->hdr.depth + 7) / 8; // 1 if depth <= 8\r\n\r\n\twhile (p < ep) {\r\n\t\tif (pngle->drawing_x >= pngle->hdr.width) {\r\n\t\t\t// New row\r\n\t\t\tpngle->drawing_x = interlace_off_x[pngle->interlace_pass];\r\n\t\t\tpngle->drawing_y = U32_CLAMP_ADD(pngle->drawing_y, interlace_div_y[pngle->interlace_pass], pngle->hdr.height);\r\n\t\t\tpngle->filter_type = -1; // Indicate new line\r\n\t\t}\r\n\r\n\t\tif (pngle->drawing_x >= pngle->hdr.width || pngle->drawing_y >= pngle->hdr.height) {\r\n\t\t\tif (pngle->interlace_pass == 0 || pngle->interlace_pass >= 7) return len; // Do nothing further\r\n\r\n\t\t\t// Interlace: Next pass\r\n\t\t\tif (set_interlace_pass(pngle, pngle->interlace_pass + 1) < 0) return -1;\r\n\t\t\tdebug_printf(\"[pngle] interlace pass changed to: %d\\n\", pngle->interlace_pass);\r\n\r\n\t\t\tcontinue; // This is required because \"No filter type bytes are present in an empty pass\".\r\n\t\t}\r\n\r\n\t\tif (pngle->filter_type < 0) {\r\n\t\t\tif (*p > 4) {\r\n\t\t\t\tdebug_printf(\"[pngle] Invalid filter type is found; 0x%02x\\n\", *p);\r\n\t\t\t\treturn PNGLE_ERROR(\"Invalid filter type is found\");\r\n\t\t\t}\r\n\r\n\t\t\tpngle->filter_type = (int_fast8_t)*p++; // 0 - 4\r\n\r\n\t\t\t// push sentinel bytes for new line\r\n\t\t\tfor (uint_fast8_t i = 0; i < bytes_per_pixel; i++) {\r\n\t\t\t\tscanline_ringbuf_push(pngle, 0);\r\n\t\t\t}\r\n\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tsize_t cidx =  pngle->scanline_ringbuf_cidx;\r\n\t\tsize_t bidx = (pngle->scanline_ringbuf_cidx                                + bytes_per_pixel) % pngle->scanline_ringbuf_size;\r\n\t\tsize_t aidx = (pngle->scanline_ringbuf_cidx + pngle->scanline_ringbuf_size - bytes_per_pixel) % pngle->scanline_ringbuf_size;\r\n\t\t// debug_printf(\"[pngle] cidx = %zd, bidx = %zd, aidx = %zd\\n\", cidx, bidx, aidx);\r\n\r\n\t\tuint8_t c = pngle->scanline_ringbuf[cidx]; // left-up\r\n\t\tuint8_t b = pngle->scanline_ringbuf[bidx]; // up\r\n\t\tuint8_t a = pngle->scanline_ringbuf[aidx]; // left\r\n\t\tuint8_t x = *p++; // target\r\n\t\t// debug_printf(\"[pngle] c = 0x%02x, b = 0x%02x, a = 0x%02x, x = 0x%02x\\n\", c, b, a, x);\r\n\r\n\t\t// Reverse the filter\r\n\t\tswitch (pngle->filter_type) {\r\n\t\tcase 0: break; // None\r\n\t\tcase 1: x += a; break; // Sub\r\n\t\tcase 2: x += b; break; // Up\r\n\t\tcase 3: x += (a + b) / 2; break; // Average\r\n\t\tcase 4: x += paeth(a, b, c); break; // Paeth\r\n\t\t}\r\n\r\n\t\tscanline_ringbuf_push(pngle, x); // updates scanline_ringbuf_cidx\r\n\r\n\t\tif (pngle->scanline_remain_bytes_to_render < 0) pngle->scanline_remain_bytes_to_render = bytes_per_pixel;\r\n\t\tif (--pngle->scanline_remain_bytes_to_render == 0) {\r\n\t\t\tsize_t xidx = (pngle->scanline_ringbuf_cidx + pngle->scanline_ringbuf_size - bytes_per_pixel) % pngle->scanline_ringbuf_size;\r\n\r\n\t\t\tif (pngle_draw_pixels(pngle, xidx) < 0) return -1;\r\n\r\n\t\t\tpngle->scanline_remain_bytes_to_render = -1; // reset\r\n\t\t}\r\n\t}\r\n\r\n\treturn len;\r\n}\r\n\r\n\r\nstatic int pngle_handle_chunk(pngle_t *pngle, const uint8_t *buf, size_t len)\r\n{\r\n\tsize_t consume = 0;\r\n\r\n\tswitch (pngle->chunk_type) {\r\n\tcase PNGLE_CHUNK_IHDR:\r\n\t\t// parse IHDR\r\n\t\tconsume = 13;\r\n\t\tif (len < consume) return 0;\r\n\r\n\t\tdebug_printf(\"[pngle]   Parse IHDR\\n\");\r\n\r\n\t\tpngle->hdr.width       = read_uint32(buf +  0);\r\n\t\tpngle->hdr.height      = read_uint32(buf +  4);\r\n\t\tpngle->hdr.depth       = read_uint8 (buf +  8);\r\n\t\tpngle->hdr.color_type  = read_uint8 (buf +  9);\r\n\t\tpngle->hdr.compression = read_uint8 (buf + 10);\r\n\t\tpngle->hdr.filter      = read_uint8 (buf + 11);\r\n\t\tpngle->hdr.interlace   = read_uint8 (buf + 12);\r\n\r\n\r\n\t\tdebug_printf(\"[pngle]     width      : %d\\n\", pngle->hdr.width      );\r\n\t\tdebug_printf(\"[pngle]     height     : %d\\n\", pngle->hdr.height     );\r\n\t\tdebug_printf(\"[pngle]     depth      : %d\\n\", pngle->hdr.depth      );\r\n\t\tdebug_printf(\"[pngle]     color_type : %d\\n\", pngle->hdr.color_type );\r\n\t\tdebug_printf(\"[pngle]     compression: %d\\n\", pngle->hdr.compression);\r\n\t\tdebug_printf(\"[pngle]     filter     : %d\\n\", pngle->hdr.filter     );\r\n\t\tdebug_printf(\"[pngle]     interlace  : %d\\n\", pngle->hdr.interlace  );\r\n\r\n\t\t/*\r\n            Color    Allowed    Interpretation                            channels\r\n            Type    Bit Depths\r\n\r\n            0       1,2,4,8,16  Each pixel is a grayscale sample.         1 channels (Brightness)\r\n\r\n            2       8,16        Each pixel is an R,G,B triple.            3 channels (R, G, B)\r\n\r\n            3       1,2,4,8     Each pixel is a palette index;            1 channels (palette info)\r\n                                a PLTE chunk must appear.\r\n\r\n            4       8,16        Each pixel is a grayscale sample,         2 channels (Brightness, Alpha)\r\n                                followed by an alpha sample.\r\n\r\n            6       8,16        Each pixel is an R,G,B triple,            4 channels (R, G, B, Alpha)\r\n                                followed by an alpha sample.\r\n\t\t*/\r\n\t\t//  111\r\n\t\t//    ^-- indexed color (palette)\r\n\t\t//   ^--- Color\r\n\t\t//  ^---- Alpha channel\r\n\r\n\t\tswitch (pngle->hdr.color_type) {\r\n\t\tcase 0: pngle->channels = 1; if (pngle->hdr.depth != 1 && pngle->hdr.depth != 2 && pngle->hdr.depth != 4 && pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR(\"Invalid bit depth\"); break; // grayscale\r\n\t\tcase 2: pngle->channels = 3; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR(\"Invalid bit depth\"); break; // truecolor\r\n\t\tcase 3: pngle->channels = 1; if (pngle->hdr.depth != 1 && pngle->hdr.depth != 2 && pngle->hdr.depth != 4 && pngle->hdr.depth != 8                          ) return PNGLE_ERROR(\"Invalid bit depth\"); break; // indexed color\r\n\t\tcase 4: pngle->channels = 2; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR(\"Invalid bit depth\"); break; // grayscale + alpha\r\n\t\tcase 6: pngle->channels = 4; if (                                                                           pngle->hdr.depth != 8 && pngle->hdr.depth != 16) return PNGLE_ERROR(\"Invalid bit depth\"); break; // truecolor + alpha\r\n\t\tdefault:\r\n\t\t\treturn PNGLE_ERROR(\"Incorrect IHDR info\");\r\n\t\t}\r\n\r\n\t\tif (pngle->hdr.compression != 0) return PNGLE_ERROR(\"Unsupported compression type in IHDR\");\r\n\t\tif (pngle->hdr.filter      != 0) return PNGLE_ERROR(\"Unsupported filter type in IHDR\");\r\n\r\n\t\t// interlace\r\n\t\tif (set_interlace_pass(pngle, pngle->hdr.interlace ? 1 : 0) < 0) return -1;\r\n\r\n\t\t// callback\r\n\t\tif (pngle->init_callback) pngle->init_callback(pngle, pngle->hdr.width, pngle->hdr.height);\r\n\r\n\t\tbreak;\r\n\r\n\tcase PNGLE_CHUNK_IDAT:\r\n\t\t// parse & decode IDAT chunk\r\n\t\tif (len < 1) return 0;\r\n\r\n\t\tdebug_printf(\"[pngle]   Reading IDAT (len %zd / chunk remain %u)\\n\", len, pngle->chunk_remain);\r\n\r\n\t\tsize_t in_bytes  = len;\r\n\t\tsize_t out_bytes = pngle->avail_out;\r\n\r\n\t\t//debug_printf(\"[pngle]     in_bytes %zd, out_bytes %zd, next_out %p\\n\", in_bytes, out_bytes, pngle->next_out);\r\n\r\n\t\t// XXX: tinfl_decompress always requires (next_out - lz_buf + avail_out) == TINFL_LZ_DICT_SIZE\r\n\t\ttinfl_status status = tinfl_decompress(&pngle->inflator, (const mz_uint8 *)buf, &in_bytes, pngle->lz_buf, (mz_uint8 *)pngle->next_out, &out_bytes, TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_PARSE_ZLIB_HEADER);\r\n\r\n\t\t//debug_printf(\"[pngle]       tinfl_decompress\\n\");\r\n\t\t//debug_printf(\"[pngle]       => in_bytes %zd, out_bytes %zd, next_out %p, status %d\\n\", in_bytes, out_bytes, pngle->next_out, status);\r\n\r\n\t\tif (status < TINFL_STATUS_DONE) {\r\n\t\t\t// Decompression failed.\r\n\t\t\tdebug_printf(\"[pngle] tinfl_decompress() failed with status %d!\\n\", status);\r\n\t\t\treturn PNGLE_ERROR(\"Failed to decompress the IDAT stream\");\r\n\t\t}\r\n\r\n\t\tpngle->next_out   += out_bytes;\r\n\t\tpngle->avail_out  -= out_bytes;\r\n\r\n\t\t// debug_printf(\"[pngle]         => avail_out %zd, next_out %p\\n\", pngle->avail_out, pngle->next_out);\r\n\r\n\t\tif (status == TINFL_STATUS_DONE || pngle->avail_out == 0) {\r\n\t\t\t// Output buffer is full, or decompression is done, so write buffer to output file.\r\n\t\t\t// XXX: This is the only chance to process the buffer.\r\n\t\t\tuint8_t *read_ptr = pngle->lz_buf;\r\n\t\t\tsize_t n = TINFL_LZ_DICT_SIZE - (size_t)pngle->avail_out;\r\n\r\n\t\t\t// pngle_on_data() usually returns n, otherwise -1 on error\r\n\t\t\tif (pngle_on_data(pngle, read_ptr, n) < 0) return -1;\r\n\r\n\t\t\t// XXX: tinfl_decompress always requires (next_out - lz_buf + avail_out) == TINFL_LZ_DICT_SIZE\r\n\t\t\tpngle->next_out = pngle->lz_buf;\r\n\t\t\tpngle->avail_out = TINFL_LZ_DICT_SIZE;\r\n\t\t}\r\n\r\n\t\tconsume = in_bytes;\r\n\t\tbreak;\r\n\r\n\tcase PNGLE_CHUNK_PLTE:\r\n\t\tconsume = 3;\r\n\t\tif (len < consume) return 0;\r\n\r\n\t\tmemcpy(pngle->palette + pngle->n_palettes * 3, buf, 3);\r\n\r\n\t\tdebug_printf(\"[pngle] PLTE[%zd]: (%d, %d, %d)\\n\"\r\n\t\t\t, pngle->n_palettes\r\n\t\t\t, pngle->palette[pngle->n_palettes * 3 + 0]\r\n\t\t\t, pngle->palette[pngle->n_palettes * 3 + 1]\r\n\t\t\t, pngle->palette[pngle->n_palettes * 3 + 2]\r\n\t\t);\r\n\r\n\t\tpngle->n_palettes++;\r\n\r\n\t\tbreak;\r\n\r\n\tcase PNGLE_CHUNK_IEND:\r\n\t\tconsume = 0;\r\n\t\tbreak;\r\n\r\n\tcase PNGLE_CHUNK_tRNS:\r\n\t\tswitch (pngle->hdr.color_type) {\r\n\t\tcase 3: consume =     1; break;\r\n\t\tcase 0: consume = 2 * 1; break;\r\n\t\tcase 2: consume = 2 * 3; break;\r\n\t\tdefault:\r\n\t\t\treturn PNGLE_ERROR(\"tRNS chunk is prohibited on the color type\");\r\n\t\t}\r\n\t\tif (len < consume) return 0;\r\n\r\n\t\tmemcpy(pngle->trans_palette + pngle->n_trans_palettes, buf, consume);\r\n\r\n\t\tpngle->n_trans_palettes++;\r\n\r\n\t\tbreak;\r\n\r\n\tcase PNGLE_CHUNK_gAMA:\r\n\t\tconsume = 4;\r\n\t\tif (len < consume) return 0;\r\n\r\n\t\tif (setup_gamma_table(pngle, read_uint32(buf)) < 0) return -1;\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\t// unknown chunk\r\n\t\tconsume = len;\r\n\r\n\t\tdebug_printf(\"[pngle] Unknown chunk; %zd bytes discarded\\n\", consume);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn consume;\r\n}\r\n\r\nstatic int pngle_feed_internal(pngle_t *pngle, const uint8_t *buf, size_t len)\r\n{\r\n\tif (!pngle) return -1;\r\n\r\n\tswitch (pngle->state) {\r\n\tcase PNGLE_STATE_ERROR:\r\n\t\treturn -1;\r\n\r\n\tcase PNGLE_STATE_EOF:\r\n\t\treturn len;\r\n\r\n\tcase PNGLE_STATE_INITIAL:\r\n\t\t// find PNG header\r\n\t\tif (len < sizeof(png_sig)) return 0;\r\n\r\n\t\tif (memcmp(png_sig, buf, sizeof(png_sig))) return PNGLE_ERROR(\"Incorrect PNG signature\");\r\n\r\n\t\tdebug_printf(\"[pngle] PNG signature found\\n\");\r\n\r\n\t\tpngle->state = PNGLE_STATE_FIND_CHUNK_HEADER;\r\n\t\treturn sizeof(png_sig);\r\n\r\n\tcase PNGLE_STATE_FIND_CHUNK_HEADER:\r\n\t\tif (len < 8) return 0;\r\n\r\n\t\tpngle->chunk_remain = read_uint32(buf);\r\n\t\tpngle->chunk_type = read_uint32(buf + 4);\r\n\r\n\t\tpngle->crc32 = mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)(buf + 4), 4);\r\n\r\n\t\tdebug_printf(\"[pngle] Chunk '%.4s' len %u\\n\", buf + 4, pngle->chunk_remain);\r\n\r\n\t\tpngle->state = PNGLE_STATE_HANDLE_CHUNK;\r\n\r\n\t\t// initialize & sanity check\r\n\t\tswitch (pngle->chunk_type) {\r\n\t\tcase PNGLE_CHUNK_IHDR:\r\n\t\t\tif (pngle->chunk_remain != 13) return PNGLE_ERROR(\"Invalid IHDR chunk size\");\r\n\t\t\tif (pngle->channels != 0) return PNGLE_ERROR(\"Multiple IHDR chunks are not allowed\");\r\n\t\t\tbreak;\r\n\r\n\t\tcase PNGLE_CHUNK_IDAT:\r\n\t\t\tif (pngle->chunk_remain <= 0) return PNGLE_ERROR(\"Invalid IDAT chunk size\");\r\n\t\t\tif (pngle->channels == 0) return PNGLE_ERROR(\"No IHDR chunk is found\");\r\n\t\t\tif (pngle->hdr.color_type == 3 && pngle->palette == NULL) return PNGLE_ERROR(\"No PLTE chunk is found\");\r\n\r\n\t\t\tif (pngle->next_out == NULL) {\r\n\t\t\t\t// Very first IDAT\r\n\t\t\t\tpngle->next_out = pngle->lz_buf;\r\n\t\t\t\tpngle->avail_out = TINFL_LZ_DICT_SIZE;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase PNGLE_CHUNK_PLTE:\r\n\t\t\tif (pngle->chunk_remain <= 0) return PNGLE_ERROR(\"Invalid PLTE chunk size\");\r\n\t\t\tif (pngle->channels == 0) return PNGLE_ERROR(\"No IHDR chunk is found\");\r\n\t\t\tif (pngle->palette) return PNGLE_ERROR(\"Too many PLTE chunk\");\r\n\r\n\t\t\tswitch (pngle->hdr.color_type) {\r\n\t\t\tcase 3: // indexed color\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // truecolor\r\n\t\t\tcase 6: // truecolor + alpha\r\n\t\t\t\t// suggested palettes\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn PNGLE_ERROR(\"PLTE chunk is prohibited on the color type\");\r\n\t\t\t}\r\n\r\n\t\t\tif (pngle->chunk_remain % 3) return PNGLE_ERROR(\"Invalid PLTE chunk size\");\r\n\t\t\tif (pngle->chunk_remain / 3 > MIN(256, (1UL << pngle->hdr.depth))) return PNGLE_ERROR(\"Too many palettes in PLTE\");\r\n\t\t\tif ((pngle->palette = PNGLE_CALLOC(pngle->chunk_remain / 3, 3, \"palette\")) == NULL) return PNGLE_ERROR(\"Insufficient memory\");\r\n\t\t\tpngle->n_palettes = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tcase PNGLE_CHUNK_IEND:\r\n\t\t\tif (pngle->next_out == NULL) return PNGLE_ERROR(\"No IDAT chunk is found\");\r\n\t\t\tif (pngle->chunk_remain > 0) return PNGLE_ERROR(\"Invalid IEND chunk size\");\r\n\t\t\tbreak;\r\n\r\n\t\tcase PNGLE_CHUNK_tRNS:\r\n\t\t\tif (pngle->chunk_remain <= 0) return PNGLE_ERROR(\"Invalid tRNS chunk size\");\r\n\t\t\tif (pngle->channels == 0) return PNGLE_ERROR(\"No IHDR chunk is found\");\r\n\t\t\tif (pngle->trans_palette) return PNGLE_ERROR(\"Too many tRNS chunk\");\r\n\r\n\t\t\tswitch (pngle->hdr.color_type) {\r\n\t\t\tcase 3: // indexed color\r\n\t\t\t\tif (pngle->chunk_remain > (1UL << pngle->hdr.depth)) return PNGLE_ERROR(\"Too many palettes in tRNS\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0: // grayscale\r\n\t\t\t\tif (pngle->chunk_remain != 2) return PNGLE_ERROR(\"Invalid tRNS chunk size\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2: // truecolor\r\n\t\t\t\tif (pngle->chunk_remain != 6) return PNGLE_ERROR(\"Invalid tRNS chunk size\");\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\treturn PNGLE_ERROR(\"tRNS chunk is prohibited on the color type\");\r\n\t\t\t}\r\n\t\t\tif ((pngle->trans_palette = PNGLE_CALLOC(pngle->chunk_remain, 1, \"trans palette\")) == NULL) return PNGLE_ERROR(\"Insufficient memory\");\r\n\t\t\tpngle->n_trans_palettes = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn 8;\r\n\r\n\tcase PNGLE_STATE_HANDLE_CHUNK:\r\n\t\tlen = MIN(len, pngle->chunk_remain);\r\n\r\n\t\tint consumed = pngle_handle_chunk(pngle, buf, len);\r\n\r\n\t\tif (consumed > 0) {\r\n\t\t\tif (pngle->chunk_remain < (uint32_t)consumed) return PNGLE_ERROR(\"Chunk data has been consumed too much\");\r\n\r\n\t\t\tpngle->chunk_remain -= consumed;\r\n\t\t\tpngle->crc32 = mz_crc32(pngle->crc32, (const mz_uint8 *)buf, consumed);\r\n\t\t}\r\n\t\tif (pngle->chunk_remain <= 0) pngle->state = PNGLE_STATE_CRC;\r\n\r\n\t\treturn consumed;\r\n\r\n\tcase PNGLE_STATE_CRC:\r\n\t\tif (len < 4) return 0;\r\n\r\n\t\tuint32_t crc32 = read_uint32(buf);\r\n\r\n\t\tif (crc32 != pngle->crc32) {\r\n\t\t\tdebug_printf(\"[pngle] CRC: %08x vs %08x => NG\\n\", crc32, (uint32_t)pngle->crc32);\r\n\t\t\treturn PNGLE_ERROR(\"CRC mismatch\");\r\n\t\t}\r\n\r\n\t\tdebug_printf(\"[pngle] CRC: %08x vs %08x => OK\\n\", crc32, (uint32_t)pngle->crc32);\r\n\t\tpngle->state = PNGLE_STATE_FIND_CHUNK_HEADER;\r\n\r\n\t\t// XXX:\r\n\t\tif (pngle->chunk_type == PNGLE_CHUNK_IEND) {\r\n\t\t\tpngle->state = PNGLE_STATE_EOF;\r\n\t\t\tif (pngle->done_callback) pngle->done_callback(pngle);\r\n\t\t\tdebug_printf(\"[pngle] DONE\\n\");\r\n\t\t}\r\n\r\n\t\treturn 4;\r\n\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn PNGLE_ERROR(\"Invalid state\");\r\n}\r\n\r\nint pngle_feed(pngle_t *pngle, const void *buf, size_t len)\r\n{\r\n\tsize_t pos = 0;\r\n\tpngle_state_t last_state = pngle->state;\r\n\r\n\twhile (pos < len) {\r\n\t\tint r = pngle_feed_internal(pngle, (const uint8_t *)buf + pos, len - pos);\r\n\t\tif (r < 0) return r; // error\r\n\r\n\t\tif (r == 0 && last_state == pngle->state) break;\r\n\t\tlast_state = pngle->state;\r\n\r\n\t\tpos += r;\r\n\t}\r\n\r\n\treturn pos;\r\n}\r\n\r\nvoid pngle_set_display_gamma(pngle_t *pngle, double display_gamma)\r\n{\r\n\tif (!pngle) return ;\r\n#ifndef PNGLE_NO_GAMMA_CORRECTION\r\n\tpngle->display_gamma = display_gamma;\r\n#else\r\n\tPNGLE_UNUSED(display_gamma);\r\n#endif\r\n}\r\n\r\nvoid pngle_set_init_callback(pngle_t *pngle, pngle_init_callback_t callback)\r\n{\r\n\tif (!pngle) return ;\r\n\tpngle->init_callback = callback;\r\n}\r\n\r\nvoid pngle_set_draw_callback(pngle_t *pngle, pngle_draw_callback_t callback)\r\n{\r\n\tif (!pngle) return ;\r\n\tpngle->draw_callback = callback;\r\n}\r\n\r\nvoid pngle_set_done_callback(pngle_t *pngle, pngle_done_callback_t callback)\r\n{\r\n\tif (!pngle) return ;\r\n\tpngle->done_callback = callback;\r\n}\r\n\r\nvoid pngle_set_user_data(pngle_t *pngle, void *user_data)\r\n{\r\n\tif (!pngle) return ;\r\n\tpngle->user_data = user_data;\r\n}\r\n\r\nvoid *pngle_get_user_data(pngle_t *pngle)\r\n{\r\n\tif (!pngle) return NULL;\r\n\treturn pngle->user_data;\r\n}\r\n\r\n/* vim: set ts=4 sw=4 noexpandtab: */\r\n"
        }
    ]
}